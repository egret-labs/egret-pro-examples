// "use strict"; TODO
/*jslint onevar:true, undef:true, newcap:true, regexp:true, bitwise:true, maxerr:50, indent:4, white:false, nomen:false, plusplus:false */
/*global define:false, require:false, exports:false, module:false, signals:false */

/** @license
 * JS Signals <http://millermedeiros.github.com/js-signals/>
 * Released under the MIT license
 * Author: Miller Medeiros
 * Version: 1.0.0 - Build: 268 (2012/11/29 05:48 PM)
 */

(function (global) {

    // SignalBinding -------------------------------------------------
    //================================================================

    /**
     * Object that represents a binding between a Signal and a listener function.
     * <br />- <strong>This is an internal constructor and shouldn't be called by regular users.</strong>
     * <br />- inspired by Joa Ebert AS3 SignalBinding and Robert Penner's Slot classes.
     * @author Miller Medeiros
     * @constructor
     * @internal
     * @name SignalBinding
     * @param {Signal} signal Reference to Signal object that listener is currently bound to.
     * @param {Function} listener Handler function bound to the signal.
     * @param {boolean} isOnce If binding should be executed just once.
     * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
     * @param {Number} [priority] The priority level of the event listener. (default = 0).
     */
    function SignalBinding(signal, listener, isOnce, listenerContext, priority) {

        /**
         * Handler function bound to the signal.
         * @type Function
         * @private
         */
        this._listener = listener;

        /**
         * If binding should be executed just once.
         * @type boolean
         * @private
         */
        this._isOnce = isOnce;

        /**
         * Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @memberOf SignalBinding.prototype
         * @name context
         * @type Object|undefined|null
         */
        this.context = listenerContext;

        /**
         * Reference to Signal object that listener is currently bound to.
         * @type Signal
         * @private
         */
        this._signal = signal;

        /**
         * Listener priority
         * @type Number
         * @private
         */
        this._priority = priority || 0;
    }

    SignalBinding.prototype = {

        /**
         * If binding is active and should be executed.
         * @type boolean
         */
        active: true,

        /**
         * Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute`. (curried parameters)
         * @type Array|null
         */
        params: null,

        /**
         * Call listener passing arbitrary parameters.
         * <p>If binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue, this method is used internally for the signal dispatch.</p>
         * @param {Array} [paramsArr] Array of parameters that should be passed to the listener
         * @return {*} Value returned by the listener.
         */
        execute: function (paramsArr) {
            var handlerReturn, params;
            if (this.active && !!this._listener) {
                params = this.params ? this.params.concat(paramsArr) : paramsArr;
                handlerReturn = this._listener.apply(this.context, params);
                if (this._isOnce) {
                    this.detach();
                }
            }
            return handlerReturn;
        },

        /**
         * Detach binding from signal.
         * - alias to: mySignal.remove(myBinding.getListener());
         * @return {Function|null} Handler function bound to the signal or `null` if binding was previously detached.
         */
        detach: function () {
            return this.isBound() ? this._signal.remove(this._listener, this.context) : null;
        },

        /**
         * @return {Boolean} `true` if binding is still bound to the signal and have a listener.
         */
        isBound: function () {
            return (!!this._signal && !!this._listener);
        },

        /**
         * @return {boolean} If SignalBinding will only be executed once.
         */
        isOnce: function () {
            return this._isOnce;
        },

        /**
         * @return {Function} Handler function bound to the signal.
         */
        getListener: function () {
            return this._listener;
        },

        /**
         * @return {Signal} Signal that listener is currently bound to.
         */
        getSignal: function () {
            return this._signal;
        },

        /**
         * Delete instance properties
         * @private
         */
        _destroy: function () {
            delete this._signal;
            delete this._listener;
            delete this.context;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString: function () {
            return '[SignalBinding isOnce:' + this._isOnce + ', isBound:' + this.isBound() + ', active:' + this.active + ']';
        }

    };


    /*global SignalBinding:false*/

    // Signal --------------------------------------------------------
    //================================================================

    function validateListener(listener, fnName) {
        if (typeof listener !== 'function') {
            throw new Error('listener is a required param of {fn}() and should be a Function.'.replace('{fn}', fnName));
        }
    }

    /**
     * Custom event broadcaster
     * <br />- inspired by Robert Penner's AS3 Signals.
     * @name Signal
     * @author Miller Medeiros
     * @constructor
     */
    function Signal() {
        /**
         * @type Array.<SignalBinding>
         * @private
         */
        this._bindings = [];
        this._prevParams = null;

        // enforce dispatch to aways work on same context (#47)
        var self = this;
        this.dispatch = function () {
            Signal.prototype.dispatch.apply(self, arguments);
        };
    }

    Signal.prototype = {

        /**
         * Signals Version Number
         * @type String
         * @const
         */
        VERSION: '1.0.0',

        /**
         * If Signal should keep record of previously dispatched parameters and
         * automatically execute listener during `add()`/`addOnce()` if Signal was
         * already dispatched before.
         * @type boolean
         */
        memorize: false,

        /**
         * @type boolean
         * @private
         */
        _shouldPropagate: true,

        /**
         * If Signal is active and should broadcast events.
         * <p><strong>IMPORTANT:</strong> Setting this property during a dispatch will only affect the next dispatch, if you want to stop the propagation of a signal use `halt()` instead.</p>
         * @type boolean
         */
        active: true,

        /**
         * @param {Function} listener
         * @param {boolean} isOnce
         * @param {Object} [listenerContext]
         * @param {Number} [priority]
         * @return {SignalBinding}
         * @private
         */
        _registerListener: function (listener, isOnce, listenerContext, priority) {

            var prevIndex = this._indexOfListener(listener, listenerContext),
                binding;

            if (prevIndex !== -1) {
                binding = this._bindings[prevIndex];
                if (binding.isOnce() !== isOnce) {
                    throw new Error('You cannot add' + (isOnce ? '' : 'Once') + '() then add' + (!isOnce ? '' : 'Once') + '() the same listener without removing the relationship first.');
                }
            } else {
                binding = new SignalBinding(this, listener, isOnce, listenerContext, priority);
                this._addBinding(binding);
            }

            if (this.memorize && this._prevParams) {
                binding.execute(this._prevParams);
            }

            return binding;
        },

        /**
         * @param {SignalBinding} binding
         * @private
         */
        _addBinding: function (binding) {
            //simplified insertion sort
            var n = this._bindings.length;
            do { --n; } while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);
            this._bindings.splice(n + 1, 0, binding);
        },

        /**
         * @param {Function} listener
         * @return {number}
         * @private
         */
        _indexOfListener: function (listener, context) {
            var n = this._bindings.length,
                cur;
            while (n--) {
                cur = this._bindings[n];
                if (cur._listener === listener && cur.context === context) {
                    return n;
                }
            }
            return -1;
        },

        /**
         * Check if listener was attached to Signal.
         * @param {Function} listener
         * @param {Object} [context]
         * @return {boolean} if Signal has the specified listener.
         */
        has: function (listener, context) {
            return this._indexOfListener(listener, context) !== -1;
        },

        /**
         * Add a listener to the signal.
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        add: function (listener, listenerContext, priority) {
            validateListener(listener, 'add');
            return this._registerListener(listener, false, listenerContext, priority);
        },

        /**
         * Add listener to the signal that should be removed after first execution (will be executed only once).
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        addOnce: function (listener, listenerContext, priority) {
            validateListener(listener, 'addOnce');
            return this._registerListener(listener, true, listenerContext, priority);
        },

        /**
         * Remove a single listener from the dispatch queue.
         * @param {Function} listener Handler function that should be removed.
         * @param {Object} [context] Execution context (since you can add the same handler multiple times if executing in a different context).
         * @return {Function} Listener handler function.
         */
        remove: function (listener, context) {
            validateListener(listener, 'remove');

            var i = this._indexOfListener(listener, context);
            if (i !== -1) {
                this._bindings[i]._destroy(); //no reason to a SignalBinding exist if it isn't attached to a signal
                this._bindings.splice(i, 1);
            }
            return listener;
        },

        /**
         * Remove all listeners from the Signal.
         */
        removeAll: function () {
            var n = this._bindings.length;
            while (n--) {
                this._bindings[n]._destroy();
            }
            this._bindings.length = 0;
        },

        /**
         * @return {number} Number of listeners attached to the Signal.
         */
        getNumListeners: function () {
            return this._bindings.length;
        },

        /**
         * Stop propagation of the event, blocking the dispatch to next listeners on the queue.
         * <p><strong>IMPORTANT:</strong> should be called only during signal dispatch, calling it before/after dispatch won't affect signal broadcast.</p>
         * @see Signal.prototype.disable
         */
        halt: function () {
            this._shouldPropagate = false;
        },

        /**
         * Dispatch/Broadcast Signal to all listeners added to the queue.
         * @param {...*} [params] Parameters that should be passed to each handler.
         */
        dispatch: function (params) {
            if (!this.active) {
                return;
            }

            var paramsArr = Array.prototype.slice.call(arguments),
                n = this._bindings.length,
                bindings;

            if (this.memorize) {
                this._prevParams = paramsArr;
            }

            if (!n) {
                //should come after memorize
                return;
            }

            bindings = this._bindings.slice(); //clone array in case add/remove items during dispatch
            this._shouldPropagate = true; //in case `halt` was called before dispatch or during the previous dispatch.

            //execute all callbacks until end of the list or until a callback returns `false` or stops propagation
            //reverse loop since listeners with higher priority will be added at the end of the list
            do { n--; } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);
        },

        /**
         * Forget memorized arguments.
         * @see Signal.memorize
         */
        forget: function () {
            this._prevParams = null;
        },

        /**
         * Remove all bindings from signal and destroy any reference to external objects (destroy Signal object).
         * <p><strong>IMPORTANT:</strong> calling any method on the signal instance after calling dispose will throw errors.</p>
         */
        dispose: function () {
            this.removeAll();
            delete this._bindings;
            delete this._prevParams;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString: function () {
            return '[Signal active:' + this.active + ' numListeners:' + this.getNumListeners() + ']';
        }

    };


    // Namespace -----------------------------------------------------
    //================================================================

    /**
     * Signals namespace
     * @namespace
     * @name signals
     */
    var signals = Signal;

    /**
     * Custom event broadcaster
     * @see Signal
     */
    // alias for backwards compatibility (see #gh-44)
    signals.Signal = Signal;
    global['signals'] = signals
}(window));
"use strict";
var __reflect = (this && this.__reflect) || function (p, c, t) {
    p.__class__ = c, t ? t.push(c) : t = [c], p.__types__ = p.__types__ ? t.concat(p.__types__) : t;
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __extends = this && this.__extends || function __extends(t, e) { 
 function r() { 
 this.constructor = t;
}
for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
r.prototype = e.prototype, t.prototype = new r();
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var paper;
(function (paper) {
    /**
     *
     */
    var HideFlags;
    (function (HideFlags) {
        /**
         *
         */
        HideFlags[HideFlags["None"] = 0] = "None";
        /**
         *
         */
        HideFlags[HideFlags["NotEditable"] = 1] = "NotEditable";
        /**
         *
         */
        HideFlags[HideFlags["NotTouchable"] = 2] = "NotTouchable";
        /**
         *
         */
        HideFlags[HideFlags["DontSave"] = 4] = "DontSave";
        /**
         *
         */
        HideFlags[HideFlags["Hide"] = 10] = "Hide";
        /**
         *
         */
        HideFlags[HideFlags["HideAndDontSave"] = 14] = "HideAndDontSave";
    })(HideFlags = paper.HideFlags || (paper.HideFlags = {}));
    /**
     *
     */
    var DefaultNames;
    (function (DefaultNames) {
        DefaultNames["NoName"] = "NoName";
        DefaultNames["Default"] = "Default";
        DefaultNames["Global"] = "Global";
        DefaultNames["MainCamera"] = "Main Camera";
        DefaultNames["EditorCamera"] = "Editor Camera";
        DefaultNames["Editor"] = "Editor";
        DefaultNames["MissingPrefab"] = "Missing Prefab";
    })(DefaultNames = paper.DefaultNames || (paper.DefaultNames = {}));
    /**
     * 默认标识和自定义标识。
     */
    var DefaultTags;
    (function (DefaultTags) {
        DefaultTags["Untagged"] = "Untagged";
        DefaultTags["Respawn"] = "Respawn";
        DefaultTags["Finish"] = "Finish";
        DefaultTags["EditorOnly"] = "EditorOnly";
        DefaultTags["MainCamera"] = "MainCamera";
        DefaultTags["Player"] = "Player";
        DefaultTags["GameController"] = "GameController";
        DefaultTags["Global"] = "Global";
    })(DefaultTags = paper.DefaultTags || (paper.DefaultTags = {}));
    /**
     * 内置层级和自定义层级。
     */
    var Layer;
    (function (Layer) {
        Layer[Layer["Nothing"] = 0] = "Nothing";
        Layer[Layer["Everything"] = 4294967295] = "Everything";
        Layer[Layer["BuiltinLayer0"] = 1] = "BuiltinLayer0";
        Layer[Layer["BuiltinLayer1"] = 2] = "BuiltinLayer1";
        Layer[Layer["BuiltinLayer2"] = 4] = "BuiltinLayer2";
        Layer[Layer["BuiltinLayer3"] = 8] = "BuiltinLayer3";
        Layer[Layer["BuiltinLayer4"] = 16] = "BuiltinLayer4";
        Layer[Layer["BuiltinLayer5"] = 32] = "BuiltinLayer5";
        Layer[Layer["BuiltinLayer6"] = 64] = "BuiltinLayer6";
        Layer[Layer["BuiltinLayer7"] = 128] = "BuiltinLayer7";
        Layer[Layer["UserLayer8"] = 256] = "UserLayer8";
        Layer[Layer["UserLayer9"] = 512] = "UserLayer9";
        Layer[Layer["UserLayer10"] = 1024] = "UserLayer10";
        Layer[Layer["UserLayer11"] = 2048] = "UserLayer11";
        Layer[Layer["UserLayer12"] = 4096] = "UserLayer12";
        Layer[Layer["UserLayer13"] = 8192] = "UserLayer13";
        Layer[Layer["UserLayer14"] = 16384] = "UserLayer14";
        Layer[Layer["UserLayer15"] = 32768] = "UserLayer15";
        Layer[Layer["UserLayer16"] = 65536] = "UserLayer16";
        Layer[Layer["UserLayer17"] = 131072] = "UserLayer17";
        Layer[Layer["UserLayer18"] = 262144] = "UserLayer18";
        Layer[Layer["UserLayer19"] = 524288] = "UserLayer19";
        Layer[Layer["UserLayer20"] = 1048576] = "UserLayer20";
        Layer[Layer["UserLayer21"] = 2097152] = "UserLayer21";
        Layer[Layer["UserLayer22"] = 4194304] = "UserLayer22";
        Layer[Layer["UserLayer23"] = 8388608] = "UserLayer23";
        Layer[Layer["UserLayer24"] = 16777216] = "UserLayer24";
        Layer[Layer["UserLayer25"] = 33554432] = "UserLayer25";
        Layer[Layer["UserLayer26"] = 67108864] = "UserLayer26";
        Layer[Layer["UserLayer27"] = 134217728] = "UserLayer27";
        Layer[Layer["UserLayer28"] = 268435456] = "UserLayer28";
        Layer[Layer["UserLayer29"] = 536870912] = "UserLayer29";
        Layer[Layer["UserLayer30"] = 1073741824] = "UserLayer30";
        Layer[Layer["UserLayer31"] = 2147483648] = "UserLayer31";
        Layer[Layer["Default"] = 1] = "Default";
        Layer[Layer["TransparentFX"] = 2] = "TransparentFX";
        Layer[Layer["IgnoreRayCast"] = 4] = "IgnoreRayCast";
        Layer[Layer["Water"] = 16] = "Water";
        Layer[Layer["UI"] = 32] = "UI";
        Layer[Layer["Editor"] = 64] = "Editor";
        Layer[Layer["EditorUI"] = 128] = "EditorUI";
        Layer[Layer["Postprocessing"] = 256] = "Postprocessing";
    })(Layer = paper.Layer || (paper.Layer = {}));
    /**
     * 系统排序。
     */
    var SystemOrder;
    (function (SystemOrder) {
        SystemOrder[SystemOrder["Begin"] = 0] = "Begin";
        SystemOrder[SystemOrder["Enable"] = 1000] = "Enable";
        SystemOrder[SystemOrder["Start"] = 2000] = "Start";
        SystemOrder[SystemOrder["FixedUpdate"] = 3000] = "FixedUpdate";
        SystemOrder[SystemOrder["Update"] = 4000] = "Update";
        SystemOrder[SystemOrder["Animation"] = 5000] = "Animation";
        SystemOrder[SystemOrder["LateUpdate"] = 6000] = "LateUpdate";
        SystemOrder[SystemOrder["BeforeRenderer"] = 7000] = "BeforeRenderer";
        SystemOrder[SystemOrder["Renderer"] = 8000] = "Renderer";
        SystemOrder[SystemOrder["Disable"] = 9000] = "Disable";
        SystemOrder[SystemOrder["End"] = 10000] = "End";
    })(SystemOrder = paper.SystemOrder || (paper.SystemOrder = {}));
    /**
     * 应用程序运行模式。
     */
    var PlayerMode;
    (function (PlayerMode) {
        /**
         *
         */
        PlayerMode[PlayerMode["Player"] = 1] = "Player";
        /**
         *
         */
        PlayerMode[PlayerMode["DebugPlayer"] = 2] = "DebugPlayer";
        /**
         *
         */
        PlayerMode[PlayerMode["Editor"] = 4] = "Editor";
    })(PlayerMode = paper.PlayerMode || (paper.PlayerMode = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    function registerClass(baseClass) {
        baseClass.__onRegister();
    }
    paper.registerClass = registerClass;
    function serializedField(classPrototypeOrOldKey, key) {
        if (key) {
            var baseClass = classPrototypeOrOldKey.constructor;
            registerClass(baseClass);
            baseClass.__serializeKeys[key] = null;
        }
        else {
            return function (classPrototype, key) {
                var baseClass = classPrototype.constructor;
                registerClass(baseClass);
                baseClass.__serializeKeys[key] = classPrototypeOrOldKey;
            };
        }
    }
    paper.serializedField = serializedField;
    /**
     * 通过装饰器标记反序列化时需要忽略的属性。
     * @param classPrototype 类原型。
     * @param key 键值。
     */
    function deserializedIgnore(classPrototype, key) {
        var baseClass = classPrototype.constructor;
        registerClass(baseClass);
        var keys = baseClass.__deserializeIgnore;
        if (keys.indexOf(key) < 0) {
            keys.push(key);
        }
    }
    paper.deserializedIgnore = deserializedIgnore;
    /**
     * 通过装饰器标记组件是否为抽象组件。
     * @param componentClass 组件类。
     */
    function abstract(componentClass) {
        componentClass.isAbstract = componentClass;
    }
    paper.abstract = abstract;
    /**
     * 通过装饰器标记组件是否为单例组件。
     * @param componentClass 组件类。
     */
    function singleton(componentClass) {
        componentClass.isSingleton = true;
        componentClass.allowMultiple = false;
    }
    paper.singleton = singleton;
    /**
     * 通过装饰器标记组件允许在同一实体上添加多个实例。
     * - 实体上允许添加相同的组件对实体组件系统并不友好，所以通常不要这么做。
     * @param componentClass 组件类。
     */
    function allowMultiple(componentClass) {
        if (!componentClass.isSingleton) {
            componentClass.allowMultiple = true;
        }
    }
    paper.allowMultiple = allowMultiple;
    // executionOrder: number; TODO
    // /**
    //  * 通过装饰器标记脚本组件的生命周期优先级。（默认：0）
    //  */
    // export function executionOrder(order: number = 0) {
    //     return function (componentClass: ComponentClass<Behaviour>) {
    //         registerClass(componentClass);
    //         componentClass.executionOrder = order;
    //     }
    // }
    /**
     * 通过装饰器标记脚本组件是否在编辑模式也拥有生命周期。
     * @param componentClass 组件类。
     */
    function executeInEditMode(componentClass) {
        componentClass.executeInEditMode = true;
    }
    paper.executeInEditMode = executeInEditMode;
    /**
     * 通过装饰器标记组件依赖的其他组件。
     * @param requireComponentClass 依赖的组件类。
     */
    function requireComponent(requireComponentClass) {
        return function (componentClass) {
            var requireComponents = componentClass.requireComponents;
            if (requireComponents.indexOf(requireComponentClass) < 0) {
                requireComponents.push(requireComponentClass);
            }
        };
    }
    paper.requireComponent = requireComponent;
    /**
     * 通过装饰器标记系统在哪些模式可以被执行。
     * @param executeMode 系统可以被运行的模式。
     */
    function executeMode(executeMode) {
        return function (systemClass) {
            systemClass.executeMode = executeMode;
        };
    }
    paper.executeMode = executeMode;
    /**
     * 通过装饰器标记 API 已被废弃。
     * @param version 废弃的版本。
     */
    function deprecated(version) {
        return function (target, key, descriptor) {
            var method = descriptor.value;
            descriptor.value = function () {
                var arg = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    arg[_i] = arguments[_i];
                }
                // TODO 装饰动态、静态、getter setter 等。
                console.warn(target.name + "." + key + "\u5728" + version + "\u7248\u672C\u4E2D\u5DF2\u88AB\u5E9F\u5F03");
                return method.apply(descriptor, arg);
            };
        };
    }
    paper.deprecated = deprecated;
})(paper || (paper = {}));
var paper;
(function (paper) {
    var _hashCount = 1;
    /**
     * 生成 uuid 的方式。
     * @private
     */
    paper.createUUID = function () {
        return (_hashCount++).toString();
    };
    /**
     * 可以被 paper.DisposeCollecter 收集，并在此帧末尾释放的基础对象。
     */
    var BaseRelease = (function () {
        function BaseRelease() {
        }
        /**
         * 更新该对象，使得该对象的 `onUpdate()` 被执行。
         */
        BaseRelease.prototype.update = function () {
            if (this.onUpdate) {
                this.onUpdate.call(this.onUpdateTarget || this, this);
            }
            return this;
        };
        /**
         * 在此帧末尾释放该对象。
         * - 释放该对象后，必须清除所有对该对象的显示引用。（该问题必须引起足够的重视）
         * - 不能在静态解释阶段执行。
         */
        BaseRelease.prototype.release = function () {
            if (this._released) {
                if (true) {
                    console.warn("The object has been released.");
                }
                return this;
            }
            paper.disposeCollecter.releases.push(this);
            this._released = true;
            return this;
        };
        return BaseRelease;
    }());
    paper.BaseRelease = BaseRelease;
    __reflect(BaseRelease.prototype, "paper.BaseRelease");
    /**
     * 基础对象。
     */
    var BaseObject = (function () {
        function BaseObject() {
            this.uuid = paper.createUUID();
        }
        /**
         * @internal
         */
        BaseObject.__onRegister = function () {
            if (this.__owner && this.__owner === this) {
                return false;
            }
            this.__deserializeIgnore = [];
            this.__serializeKeys = {};
            this.__owner = this;
            return true;
        };
        __decorate([
            paper.serializedField
        ], BaseObject.prototype, "uuid", void 0);
        return BaseObject;
    }());
    paper.BaseObject = BaseObject;
    __reflect(BaseObject.prototype, "paper.BaseObject", ["paper.IUUID"]);
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 属性信息。
         */
        var PropertyInfo = (function () {
            function PropertyInfo(name, editType, option) {
                this.name = name;
                this.editType = editType;
                this.option = option;
            }
            return PropertyInfo;
        }());
        editor.PropertyInfo = PropertyInfo;
        __reflect(PropertyInfo.prototype, "paper.editor.PropertyInfo");
        /**
         * 编辑类型。
         */
        var EditType;
        (function (EditType) {
            /**
             * 选中框。
             */
            EditType["CHECKBOX"] = "CHECKBOX";
            /**
             * 正整数。
             */
            EditType["UINT"] = "UINT";
            /**
             * 整数。
             */
            EditType["INT"] = "INT";
            /**
             * 浮点数。
             */
            EditType["FLOAT"] = "FLOAT";
            /**
             * 文本。
             */
            EditType["TEXT"] = "TEXT";
            /**
             * 下拉列表。
             */
            EditType["LIST"] = "LIST";
            /**
             * 数组。
             */
            EditType["ARRAY"] = "ARRAY";
            /**
             * 尺寸。
             */
            EditType["SIZE"] = "SIZE";
            /**
             * 矩形。
             */
            EditType["RECT"] = "RECT";
            /**
             * 二维向量。
             */
            EditType["VECTOR2"] = "VECTOR2";
            /**
             * 三维向量。
             */
            EditType["VECTOR3"] = "VECTOR3";
            /**
             * 四维向量。
             */
            EditType["VECTOR4"] = "VECTOR4";
            /**
             * 四元数。
             */
            EditType["QUATERNION"] = "QUATERNION";
            /**
             * 颜色选择器。
             */
            EditType["COLOR"] = "COLOR";
            /**
             * 着色器。
             */
            EditType["SHADER"] = "SHADER";
            /**
             * 材质。
             */
            EditType["MATERIAL"] = "MATERIAL";
            /**
             * 材质数组。
             */
            EditType["MATERIAL_ARRAY"] = "MATERIAL_ARRAY";
            /**
             * 贴图纹理。
             */
            EditType["TEXTUREDESC"] = "TEXTUREDESC";
            /**
             * 网格。
             */
            EditType["MESH"] = "MESH";
            /**
             * 实体。
             */
            EditType["GAMEOBJECT"] = "GAMEOBJECT";
            /**
             * 组件。
             */
            EditType["COMPONENT"] = "COMPONENT";
            /**
             * 声音。
             */
            EditType["SOUND"] = "SOUND";
            /**
             * 按钮。
             */
            EditType["BUTTON"] = "BUTTON";
            /**
             * 3x3 矩阵。
             */
            EditType["MAT3"] = "MAT3";
            /**
             * 内嵌的。
             */
            EditType["NESTED"] = "NESTED";
            /**变换 TODO remove*/
            EditType["TRANSFROM"] = "TRANSFROM";
        })(EditType = editor.EditType || (editor.EditType = {}));
        /**
         * 自定义装饰器。
         */
        function custom() {
            return function (target) {
                target['__custom__'] = true;
            };
        }
        editor.custom = custom;
        /**
         * 属性装饰器。
         * @param editType 编辑类型。
         * @param option 配置。
         */
        function property(editType, option) {
            return function (target, property) {
                if (!target.hasOwnProperty('__props__')) {
                    target['__props__'] = [];
                }
                if (editType !== undefined) {
                    if (option && option.componentClass) {
                        option.componentClass = egret.getQualifiedClassName(option.componentClass);
                    }
                    target['__props__'].push(new PropertyInfo(property, editType, option));
                }
                else {
                    //TODO:自动分析编辑类型
                }
            };
        }
        editor.property = property;
        /**
         * 从枚举中生成装饰器列表项。
         */
        function getItemsFromEnum(enumObject) {
            var items = [];
            for (var k in enumObject) {
                if (!isNaN(Number(k))) {
                    continue;
                }
                items.push({ label: k, value: enumObject[k] });
            }
            return items;
        }
        editor.getItemsFromEnum = getItemsFromEnum;
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 二维向量。
     */
    var Vector2 = (function (_super) {
        __extends(Vector2, _super);
        /**
         * 请使用 `egret3d.Vector2.create()` 创建实例。
         * @see egret3d.Vector2.create()
         * @deprecated
         * @private
         */
        function Vector2(x, y) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            return _this;
        }
        /**
         * 创建一个二维向量。
         * @param x X 轴分量。
         * @param y Y 轴分量。
         */
        Vector2.create = function (x, y) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(x, y);
                instance._released = false;
                return instance;
            }
            return new Vector2().set(x, y);
        };
        Vector2.prototype.serialize = function () {
            return [this.x, this.y];
        };
        Vector2.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Vector2.prototype.copy = function (value) {
            return this.set(value.x, value.y);
        };
        Vector2.prototype.clone = function () {
            return Vector2.create(this.x, this.y);
        };
        Vector2.prototype.set = function (x, y) {
            this.x = x;
            this.y = y;
            return this;
        };
        Vector2.prototype.clear = function () {
            this.x = 0.0;
            this.y = 0.0;
            return this;
        };
        Vector2.prototype.fromArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            this.x = array[offset];
            this.y = array[offset + 1];
            return this;
        };
        Vector2.prototype.normalize = function (input) {
            if (!input) {
                input = this;
            }
            var x = input.x, y = input.y;
            var l = Math.sqrt(x * x + y * y);
            if (l > 2.220446049250313e-16 /* EPSILON */) {
                l = 1.0 / l;
                this.x = x * l;
                this.y = y * l;
            }
            else {
                this.x = 1.0;
                this.y = 0.0;
            }
            return this;
        };
        Vector2.prototype.add = function (vectorA, vectorB) {
            if (!vectorB) {
                vectorB = vectorA;
                vectorA = this;
            }
            this.x = vectorA.x + vectorB.x;
            this.y = vectorA.y + vectorB.y;
            return this;
        };
        Vector2.prototype.subtract = function (vectorA, vectorB) {
            if (!vectorB) {
                vectorB = vectorA;
                vectorA = this;
            }
            this.x = vectorA.x - vectorB.x;
            this.y = vectorA.y - vectorB.y;
            return this;
        };
        Vector2.prototype.addScalar = function (scalar, input) {
            if (!input) {
                input = this;
            }
            this.x = input.x + scalar;
            this.y = input.y + scalar;
            return this;
        };
        Vector2.prototype.multiplyScalar = function (scalar, input) {
            if (!input) {
                input = this;
            }
            this.x = scalar * input.x;
            this.y = scalar * input.y;
            return this;
        };
        Vector2.prototype.min = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.x = Math.min(valueA.x, valueB.x);
            this.y = Math.min(valueA.y, valueB.y);
            return this;
        };
        Vector2.prototype.max = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.x = Math.max(valueA.x, valueB.x);
            this.y = Math.max(valueA.y, valueB.y);
            return this;
        };
        Vector2.prototype.clamp = function (min, max, input) {
            if (!input) {
                input = this;
            }
            if (true && (min.x > max.x || min.y > max.y)) {
                console.warn("Invalid arguments.");
            }
            // assumes min < max, componentwise
            this.x = Math.max(min.x, Math.min(max.x, input.x));
            this.y = Math.max(min.y, Math.min(max.y, input.y));
            return this;
        };
        Object.defineProperty(Vector2.prototype, "length", {
            /**
             * 该向量的长度。
             * - 该值是实时计算的。
             */
            get: function () {
                return Math.sqrt(this.sqrtLength);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector2.prototype, "sqrtLength", {
            /**
             * 该向量的长度的平方。
             * - 该值是实时计算的。
             */
            get: function () {
                return this.x * this.x + this.y * this.y;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        Vector2.add = function (v1, v2, out) {
            out.x = v1.x + v2.x;
            out.y = v1.y + v2.y;
            return out;
        };
        /**
         * @deprecated
         */
        Vector2.subtract = function (v1, v2, out) {
            out.x = v1.x - v2.x;
            out.y = v1.y - v2.y;
            return out;
        };
        /**
         * @deprecated
         */
        Vector2.multiply = function (v1, v2, out) {
            out.x = v1.x * v2.x;
            out.y = v1.y * v2.y;
            return out;
        };
        /**
         * @deprecated
         */
        Vector2.dot = function (v1, v2) {
            return v1.x * v2.x + v1.y * v2.y;
        };
        /**
         * @deprecated
         */
        Vector2.scale = function (v, scaler) {
            v.x = v.x * scaler;
            v.y = v.y * scaler;
            return v;
        };
        /**
         * @deprecated
         */
        Vector2.getLength = function (v) {
            return Math.sqrt(v.x * v.x + v.y * v.y);
        };
        /**
         * @deprecated
         */
        Vector2.getDistance = function (v1, v2) {
            this.subtract(v1, v2, _helpVector2A);
            return this.getLength(_helpVector2A);
        };
        /**
         * @deprecated
         */
        Vector2.equal = function (v1, v2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(v1.x - v2.x) > threshold) {
                return false;
            }
            if (Math.abs(v1.y - v2.y) > threshold) {
                return false;
            }
            return true;
        };
        /**
         * @deprecated
         */
        Vector2.lerp = function (v1, v2, value, out) {
            out.x = v1.x * (1 - value) + v2.x * value;
            out.y = v1.y * (1 - value) + v2.y * value;
            return out;
        };
        Vector2.ZERO = new Vector2(0.0, 0.0);
        Vector2.ONE = new Vector2(1.0, 1.0);
        Vector2.MINUS_ONE = new Vector2(-1.0, -1.0);
        Vector2._instances = [];
        return Vector2;
    }(paper.BaseRelease));
    egret3d.Vector2 = Vector2;
    __reflect(Vector2.prototype, "egret3d.Vector2", ["egret3d.IVector2", "paper.ICCS", "paper.ISerializable"]);
    var _helpVector2A = new Vector2();
    /**
     * @internal
     */
    egret3d.helpVector2A = Vector2.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 基础资源。
     * - 全部资源的基类。
     */
    var Asset = (function (_super) {
        __extends(Asset, _super);
        /**
         * 请使用 `T.create()` 创建实例。
         */
        function Asset() {
            var _this = _super.call(this) || this;
            /**
             * 资源名称。
             */
            _this.name = "";
            _this._referenceCount = -1;
            return _this;
        }
        /**
         * 将一个资源注册为全局可访问资源。
         * - 引用计数加 1 。
         */
        Asset.register = function (asset) {
            var assetName = asset.name;
            if (!assetName) {
                console.warn("Unable to register an unnamed asset.");
                return false;
            }
            var assets = this._assets;
            if (assetName in assets) {
                var existingAsset = assets[assetName];
                if (existingAsset === asset) {
                    return false;
                }
                console.warn("Replaces an existing asset.", assetName);
            }
            assets[assetName] = asset;
            return true;
        };
        /**
         * 通过资源名获取一个已注册的指定资源。
         */
        Asset.find = function (name) {
            var assets = this._assets;
            if (name in assets) {
                return assets[name];
            }
            return RES.getRes(name);
        };
        /**
         * 该资源内部初始化。
         * - 重写此方法时，必须调用 `super.initialize();`。
         */
        Asset.prototype.initialize = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this._referenceCount = 0;
        };
        /**
         * 该资源的引用计数加一。
         */
        Asset.prototype.retain = function () {
            if (this._referenceCount === 0) {
                if (this.onReferenceCountChange) {
                    var assets = paper.disposeCollecter.assets;
                    var index = assets.indexOf(this);
                    if (index >= 0) {
                        assets.splice(index, 1);
                    }
                    this.onReferenceCountChange(false);
                }
            }
            this._referenceCount++;
            return this;
        };
        /**
         * 该资源的引用计数减一。
         */
        Asset.prototype.release = function () {
            if (this._referenceCount > 0) {
                this._referenceCount--;
                if (this._referenceCount === 0) {
                    if (this.onReferenceCountChange) {
                        var assets = paper.disposeCollecter.assets;
                        if (assets.indexOf(this) < 0) {
                            assets.push(this);
                        }
                    }
                }
            }
            return this;
        };
        /**
         * 释放该资源。
         * - 重写此方法时，必须调用 `super.dispose();`。
         * @returns 释放是否成功。（已经释放过的资源，无法再次释放）
         */
        Asset.prototype.dispose = function () {
            if (this._referenceCount === -1) {
                return false;
            }
            //
            var assets = Asset._assets;
            if (this.name in assets) {
                delete assets[this.name];
            }
            //
            this._referenceCount = -1;
            this.onReferenceCountChange && this.onReferenceCountChange(true);
            return true;
        };
        Object.defineProperty(Asset.prototype, "isDisposed", {
            /**
             * 该资源是否已经被释放。
             */
            get: function () {
                return this._referenceCount === -1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Asset.prototype, "referenceCount", {
            /**
             * 该资源的引用计数。
             * - 当引用计数为 0 时，该资源将在本帧末尾被释放。
             */
            get: function () {
                return this._referenceCount >= 0 ? this._referenceCount : 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * TODO RES 需要有注册的功能，并拥有查询所有指定类型资源的功能。
         * Asset 类型需要引擎枚举，paper 空间还是引擎空间。
         * 空间结构
         * 引擎、res、ecs、2d、3d，其他
         * @internal
         */
        Asset._assets = {};
        return Asset;
    }(paper.BaseObject));
    paper.Asset = Asset;
    __reflect(Asset.prototype, "paper.Asset");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var ComponentLifeState;
    (function (ComponentLifeState) {
        ComponentLifeState[ComponentLifeState["None"] = 0] = "None";
        ComponentLifeState[ComponentLifeState["Reseted"] = 1] = "Reseted";
        ComponentLifeState[ComponentLifeState["Awaked"] = 2] = "Awaked";
        ComponentLifeState[ComponentLifeState["Initialized"] = 4] = "Initialized";
        ComponentLifeState[ComponentLifeState["Started"] = 8] = "Started";
    })(ComponentLifeState = paper.ComponentLifeState || (paper.ComponentLifeState = {}));
    /**
     * 基础组件。
     * - 所有组件的基类。
     * - 在纯粹的实体组件系统中，组件通常应只包含数据，不应有业务逻辑、行为和生命周期。
     */
    var Component = (function (_super) {
        __extends(Component, _super);
        /**
         * 禁止实例化组件。
         * @protected
         */
        function Component() {
            var _this = _super.call(this) || this;
            _this.hideFlags = 0 /* None */;
            _this.entity = null;
            _this.extras = paper.Application.playerMode === 4 /* Editor */ ? {} : undefined;
            _this._isDestroyed = true;
            _this._enabled = false;
            /**
             * @internal
             */
            _this._lifeStates = 0 /* None */;
            return _this;
        }
        Component_1 = Component;
        /**
         * @internal
         */
        Component.__onRegister = function () {
            if (!paper.BaseObject.__onRegister.call(this)) {
                return false;
            }
            if (this.isAbstract === this) {
                this.componentIndex = this._allAbstractComponents.length + 512;
                this._allAbstractComponents.push(this);
                return false;
            }
            if ((this.isSingleton ? this._allSingletonComponents : this._allComponents).indexOf(this) >= 0) {
                console.warn("Register component class again.", egret.getQualifiedClassName(this));
                return false;
            }
            if (this.isSingleton) {
                this.componentIndex = this._allSingletonComponents.length + 256; // This means that a maximum of 256 non-singleton components can be added.
                this._allSingletonComponents.push(this);
            }
            else {
                this.componentIndex = this._allComponents.length;
                this._allComponents.push(this);
            }
            if (this.requireComponents) {
                this.requireComponents = this.requireComponents.concat();
            }
            else {
                this.requireComponents = [];
            }
            return true;
        };
        /**
         * @internal
         */
        Component.create = function (entity, componentClass) {
            var component = new componentClass();
            component.entity = entity;
            component._isDestroyed = false;
            component._enabled = this.createDefaultEnabled;
            return component;
        };
        /**
         * @internal
         */
        Component.prototype._destroy = function () {
            this._isDestroyed = true;
        };
        Component.prototype._setEnabled = function (value) {
            if ((this._lifeStates & 4 /* Initialized */)) {
                this.dispatchEnabledEvent(value);
            }
        };
        Component.prototype.initialize = function (config) {
            this._lifeStates |= 4 /* Initialized */;
        };
        Component.prototype.uninitialize = function () {
            delete this.entity._removedComponents[this.constructor.componentIndex];
            this.entity = null;
            this._lifeStates = 0 /* None */;
        };
        Component.prototype.dispatchEnabledEvent = function (enabled) {
            if (enabled) {
                Component_1.onComponentEnabled.dispatch([this.entity, this]);
            }
            else {
                Component_1.onComponentDisabled.dispatch([this.entity, this]);
            }
        };
        Object.defineProperty(Component.prototype, "isDestroyed", {
            get: function () {
                return this._isDestroyed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Component.prototype, "enabled", {
            get: function () {
                return this._enabled;
            },
            set: function (value) {
                if (this._enabled === value || this._isDestroyed) {
                    return;
                }
                this._enabled = value;
                this._setEnabled(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Component.prototype, "isActiveAndEnabled", {
            get: function () {
                return this._enabled && this.entity.enabled;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 当组件被创建时派发事件。
         */
        Component.onComponentCreated = new signals.Signal();
        /**
         * 当组件被激活时派发事件。
         */
        Component.onComponentEnabled = new signals.Signal();
        /**
         * 当组件被禁用时派发事件。
         */
        Component.onComponentDisabled = new signals.Signal();
        /**
         * 当组件将要被销毁时派发事件。
         */
        Component.onComponentDestroy = new signals.Signal();
        /**
         * 当组件被销毁时派发事件。
         */
        Component.onComponentDestroyed = new signals.Signal();
        /**
         *
         */
        Component.createDefaultEnabled = true;
        /**
         * 该组件的实例是否在编辑模式拥有生命周期。
         */
        Component.executeInEditMode = false;
        /**
         * 是否允许在同一实体上添加多个该组件的实例。
         */
        Component.allowMultiple = false;
        /**
         * 该组件实例依赖的其他前置组件。
         */
        Component.requireComponents = null;
        /**
         *
         */
        Component.isAbstract = Component_1;
        /**
         * 该组件实例是否为单例组件。
         */
        Component.isSingleton = false;
        /**
         *
         */
        Component.isBehaviour = false;
        /**
         * 该组件实例索引。
         */
        Component.componentIndex = -1;
        /**
         * 所有已注册的单例组件类。
         */
        Component._allAbstractComponents = [];
        /**
         * 所有已注册的单例组件类。
         */
        Component._allSingletonComponents = [];
        /**
         * 所有已注册的组件类。
         */
        Component._allComponents = [];
        __decorate([
            paper.serializedField
        ], Component.prototype, "hideFlags", void 0);
        __decorate([
            paper.serializedField
        ], Component.prototype, "extras", void 0);
        __decorate([
            paper.serializedField
        ], Component.prototype, "_enabled", void 0);
        __decorate([
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], Component.prototype, "enabled", null);
        Component = Component_1 = __decorate([
            paper.abstract
        ], Component);
        return Component;
        var Component_1;
    }(paper.BaseObject));
    paper.Component = Component;
    __reflect(Component.prototype, "paper.Component", ["paper.IComponent"]);
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 渲染排序。
     */
    var RenderQueue;
    (function (RenderQueue) {
        RenderQueue[RenderQueue["Background"] = 1000] = "Background";
        RenderQueue[RenderQueue["Geometry"] = 2000] = "Geometry";
        RenderQueue[RenderQueue["Mask"] = 2450] = "Mask";
        RenderQueue[RenderQueue["Blend"] = 3000] = "Blend";
        RenderQueue[RenderQueue["Overlay"] = 4000] = "Overlay";
    })(RenderQueue = egret3d.RenderQueue || (egret3d.RenderQueue = {}));
    /**
     * 混合模式。
     */
    var BlendMode;
    (function (BlendMode) {
        /**
         * 不混合。
         */
        BlendMode[BlendMode["None"] = 0] = "None";
        /**
         * 正常。
         */
        BlendMode[BlendMode["Normal"] = 2] = "Normal";
        /**
         * 正常并预乘。
         */
        BlendMode[BlendMode["Normal_PreMultiply"] = 3] = "Normal_PreMultiply";
        /**
         * 相加。
         */
        BlendMode[BlendMode["Additive"] = 4] = "Additive";
        /**
         * 相加并预乘。
         */
        BlendMode[BlendMode["Additive_PreMultiply"] = 5] = "Additive_PreMultiply";
        /**
         * 相减。
         */
        BlendMode[BlendMode["Subtractive"] = 8] = "Subtractive";
        /**
         * 相减并预乘。
         */
        BlendMode[BlendMode["Subtractive_PreMultiply"] = 9] = "Subtractive_PreMultiply";
        /**
         * 相乘。
         */
        BlendMode[BlendMode["Multiply"] = 16] = "Multiply";
        /**
         * 相乘并预乘。
         */
        BlendMode[BlendMode["Multiply_PreMultiply"] = 17] = "Multiply_PreMultiply";
        /**
         * 自定义混合。
         */
        BlendMode[BlendMode["Custom"] = -1] = "Custom";
    })(BlendMode = egret3d.BlendMode || (egret3d.BlendMode = {}));
    /**
     *
     */
    var ToneMapping;
    (function (ToneMapping) {
        ToneMapping[ToneMapping["None"] = 0] = "None";
        ToneMapping[ToneMapping["LinearToneMapping"] = 1] = "LinearToneMapping";
        ToneMapping[ToneMapping["ReinhardToneMapping"] = 2] = "ReinhardToneMapping";
        ToneMapping[ToneMapping["Uncharted2ToneMapping"] = 3] = "Uncharted2ToneMapping";
        ToneMapping[ToneMapping["CineonToneMapping"] = 4] = "CineonToneMapping";
    })(ToneMapping = egret3d.ToneMapping || (egret3d.ToneMapping = {}));
    /**
     * 纹理编码。
     */
    var TextureEncoding;
    (function (TextureEncoding) {
        TextureEncoding[TextureEncoding["LinearEncoding"] = 1] = "LinearEncoding";
        TextureEncoding[TextureEncoding["sRGBEncoding"] = 2] = "sRGBEncoding";
        TextureEncoding[TextureEncoding["RGBEEncoding"] = 3] = "RGBEEncoding";
        TextureEncoding[TextureEncoding["RGBM7Encoding"] = 4] = "RGBM7Encoding";
        TextureEncoding[TextureEncoding["RGBM16Encoding"] = 5] = "RGBM16Encoding";
        TextureEncoding[TextureEncoding["RGBDEncoding"] = 6] = "RGBDEncoding";
        TextureEncoding[TextureEncoding["GammaEncoding"] = 7] = "GammaEncoding";
    })(TextureEncoding = egret3d.TextureEncoding || (egret3d.TextureEncoding = {}));
    /**
     *
     */
    var TextureUVMapping;
    (function (TextureUVMapping) {
        TextureUVMapping[TextureUVMapping["UV"] = 0] = "UV";
        TextureUVMapping[TextureUVMapping["Cube"] = 1] = "Cube";
        TextureUVMapping[TextureUVMapping["CubeUV"] = 2] = "CubeUV";
        TextureUVMapping[TextureUVMapping["Equirectangular"] = 3] = "Equirectangular";
        TextureUVMapping[TextureUVMapping["Spherical"] = 4] = "Spherical";
    })(TextureUVMapping = egret3d.TextureUVMapping || (egret3d.TextureUVMapping = {}));
    /**
     *
     */
    var ApplyRootMotion;
    (function (ApplyRootMotion) {
        ApplyRootMotion[ApplyRootMotion["X"] = 1] = "X";
        ApplyRootMotion[ApplyRootMotion["Y"] = 2] = "Y";
        ApplyRootMotion[ApplyRootMotion["Z"] = 4] = "Z";
        ApplyRootMotion[ApplyRootMotion["RY"] = 16] = "RY";
        ApplyRootMotion[ApplyRootMotion["XZ"] = 5] = "XZ";
    })(ApplyRootMotion = egret3d.ApplyRootMotion || (egret3d.ApplyRootMotion = {}));
    /**
     * @private
     */
    var AnimationBlendType;
    (function (AnimationBlendType) {
        AnimationBlendType[AnimationBlendType["E1D"] = 0] = "E1D";
    })(AnimationBlendType = egret3d.AnimationBlendType || (egret3d.AnimationBlendType = {}));
})(egret3d || (egret3d = {}));
// For keep const enum.
var gltf;
(function (gltf) {
    /**
     * 绘制缓存掩码。
     */
    var BufferMask;
    (function (BufferMask) {
        BufferMask[BufferMask["None"] = 0] = "None";
        BufferMask[BufferMask["Depth"] = 256] = "Depth";
        BufferMask[BufferMask["Stencil"] = 1024] = "Stencil";
        BufferMask[BufferMask["Color"] = 16384] = "Color";
        BufferMask[BufferMask["DepthAndStencil"] = 1280] = "DepthAndStencil";
        BufferMask[BufferMask["DepthAndColor"] = 16640] = "DepthAndColor";
        BufferMask[BufferMask["StencilAndColor"] = 17408] = "StencilAndColor";
        BufferMask[BufferMask["All"] = 17664] = "All";
    })(BufferMask = gltf.BufferMask || (gltf.BufferMask = {}));
    var BlendEquation;
    (function (BlendEquation) {
        BlendEquation[BlendEquation["Add"] = 32774] = "Add";
        BlendEquation[BlendEquation["Subtract"] = 32778] = "Subtract";
        BlendEquation[BlendEquation["ReverseSubtract"] = 32779] = "ReverseSubtract";
    })(BlendEquation = gltf.BlendEquation || (gltf.BlendEquation = {}));
    var BlendFactor;
    (function (BlendFactor) {
        BlendFactor[BlendFactor["ZERO"] = 0] = "ZERO";
        BlendFactor[BlendFactor["ONE"] = 1] = "ONE";
        BlendFactor[BlendFactor["SRC_COLOR"] = 768] = "SRC_COLOR";
        BlendFactor[BlendFactor["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
        BlendFactor[BlendFactor["DST_COLOR"] = 774] = "DST_COLOR";
        BlendFactor[BlendFactor["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
        BlendFactor[BlendFactor["SRC_ALPHA"] = 770] = "SRC_ALPHA";
        BlendFactor[BlendFactor["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
        BlendFactor[BlendFactor["DST_ALPHA"] = 772] = "DST_ALPHA";
        BlendFactor[BlendFactor["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
        BlendFactor[BlendFactor["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
        BlendFactor[BlendFactor["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
        BlendFactor[BlendFactor["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
        BlendFactor[BlendFactor["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
        BlendFactor[BlendFactor["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
    })(BlendFactor = gltf.BlendFactor || (gltf.BlendFactor = {}));
    var CullFace;
    (function (CullFace) {
        CullFace[CullFace["Front"] = 1028] = "Front";
        CullFace[CullFace["Back"] = 1029] = "Back";
        CullFace[CullFace["FrontAndBack"] = 1032] = "FrontAndBack";
    })(CullFace = gltf.CullFace || (gltf.CullFace = {}));
    var FrontFace;
    (function (FrontFace) {
        FrontFace[FrontFace["CW"] = 2304] = "CW";
        FrontFace[FrontFace["CCW"] = 2305] = "CCW";
    })(FrontFace = gltf.FrontFace || (gltf.FrontFace = {}));
    var MeshPrimitiveMode;
    (function (MeshPrimitiveMode) {
        MeshPrimitiveMode[MeshPrimitiveMode["Points"] = 0] = "Points";
        MeshPrimitiveMode[MeshPrimitiveMode["Lines"] = 1] = "Lines";
        MeshPrimitiveMode[MeshPrimitiveMode["LineLoop"] = 2] = "LineLoop";
        MeshPrimitiveMode[MeshPrimitiveMode["LineStrip"] = 3] = "LineStrip";
        MeshPrimitiveMode[MeshPrimitiveMode["Triangles"] = 4] = "Triangles";
        MeshPrimitiveMode[MeshPrimitiveMode["TrianglesStrip"] = 5] = "TrianglesStrip";
        MeshPrimitiveMode[MeshPrimitiveMode["TrianglesFan"] = 6] = "TrianglesFan";
    })(MeshPrimitiveMode = gltf.MeshPrimitiveMode || (gltf.MeshPrimitiveMode = {}));
    /**
     *
     */
    var DrawMode;
    (function (DrawMode) {
        DrawMode[DrawMode["Stream"] = 35040] = "Stream";
        DrawMode[DrawMode["Static"] = 35044] = "Static";
        DrawMode[DrawMode["Dynamic"] = 35048] = "Dynamic";
    })(DrawMode = gltf.DrawMode || (gltf.DrawMode = {}));
    /**
     *
     */
    var TextureFormat;
    (function (TextureFormat) {
        TextureFormat[TextureFormat["RGB"] = 6407] = "RGB";
        TextureFormat[TextureFormat["RGBA"] = 6408] = "RGBA";
        TextureFormat[TextureFormat["Luminance"] = 6409] = "Luminance";
        TextureFormat[TextureFormat["RGBA4"] = 32854] = "RGBA4";
    })(TextureFormat = gltf.TextureFormat || (gltf.TextureFormat = {}));
    /**
     *
     */
    var TextureFilter;
    (function (TextureFilter) {
        TextureFilter[TextureFilter["Nearest"] = 9728] = "Nearest";
        TextureFilter[TextureFilter["Linear"] = 9729] = "Linear";
        TextureFilter[TextureFilter["NearestMipmapNearest"] = 9984] = "NearestMipmapNearest";
        TextureFilter[TextureFilter["LinearMipmapNearest"] = 9985] = "LinearMipmapNearest";
        TextureFilter[TextureFilter["NearestMipMapLinear"] = 9986] = "NearestMipMapLinear";
        TextureFilter[TextureFilter["LinearMipMapLinear"] = 9987] = "LinearMipMapLinear";
    })(TextureFilter = gltf.TextureFilter || (gltf.TextureFilter = {}));
    /**
     *
     */
    var TextureWrappingMode;
    (function (TextureWrappingMode) {
        TextureWrappingMode[TextureWrappingMode["Repeat"] = 10497] = "Repeat";
        TextureWrappingMode[TextureWrappingMode["ClampToEdge"] = 33071] = "ClampToEdge";
        TextureWrappingMode[TextureWrappingMode["MirroredRepeat"] = 33648] = "MirroredRepeat";
    })(TextureWrappingMode = gltf.TextureWrappingMode || (gltf.TextureWrappingMode = {}));
    /**
     *
     */
    var EnableState;
    (function (EnableState) {
        EnableState[EnableState["Blend"] = 3042] = "Blend";
        EnableState[EnableState["CullFace"] = 2884] = "CullFace";
        EnableState[EnableState["DepthTest"] = 2929] = "DepthTest";
        EnableState[EnableState["StencilTest"] = 2960] = "StencilTest";
        EnableState[EnableState["PolygonOffsetFill"] = 32823] = "PolygonOffsetFill";
        EnableState[EnableState["SampleAlphaToCoverage"] = 32926] = "SampleAlphaToCoverage";
    })(EnableState = gltf.EnableState || (gltf.EnableState = {}));
    /**
     *
     */
    var DepthFunc;
    (function (DepthFunc) {
        DepthFunc[DepthFunc["Never"] = 512] = "Never";
        DepthFunc[DepthFunc["Less"] = 513] = "Less";
        DepthFunc[DepthFunc["Lequal"] = 515] = "Lequal";
        DepthFunc[DepthFunc["Equal"] = 514] = "Equal";
        DepthFunc[DepthFunc["Greater"] = 516] = "Greater";
        DepthFunc[DepthFunc["NotEqual"] = 517] = "NotEqual";
        DepthFunc[DepthFunc["GEqual"] = 518] = "GEqual";
        DepthFunc[DepthFunc["Always"] = 519] = "Always";
    })(DepthFunc = gltf.DepthFunc || (gltf.DepthFunc = {}));
})(gltf || (gltf = {}));
var paper;
(function (paper) {
    /**
     * 传统的基础组件。
     */
    var BaseComponent = (function (_super) {
        __extends(BaseComponent, _super);
        function BaseComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 该组件的游戏实体。
             */
            _this.gameObject = null;
            return _this;
        }
        BaseComponent.prototype._setEnabled = function (value) {
            if ((this._lifeStates & 4 /* Initialized */) && this.gameObject.activeInHierarchy) {
                this.dispatchEnabledEvent(value);
            }
        };
        BaseComponent.prototype.initialize = function (config) {
            _super.prototype.initialize.call(this, config);
            this.gameObject = this.entity;
        };
        BaseComponent.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            this.gameObject = null;
        };
        Object.defineProperty(BaseComponent.prototype, "isActiveAndEnabled", {
            /**
             * 该组件在场景的激活状态。
             */
            get: function () {
                return this._enabled && this.gameObject.activeInHierarchy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "transform", {
            /**
             *
             */
            get: function () {
                return this.gameObject.transform;
            },
            enumerable: true,
            configurable: true
        });
        BaseComponent = __decorate([
            paper.abstract
        ], BaseComponent);
        return BaseComponent;
    }(paper.Component));
    paper.BaseComponent = BaseComponent;
    __reflect(BaseComponent.prototype, "paper.BaseComponent");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    // egret build bug. 
    1000 /* Background */;
    0 /* None */;
    0 /* None */;
    1 /* LinearEncoding */;
    0 /* UV */;
    /**
     * glTF 资源。
     */
    var GLTFAsset = (function (_super) {
        __extends(GLTFAsset, _super);
        function GLTFAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Buffer 列表。
             */
            _this.buffers = [];
            /**
             * 配置。
             */
            _this.config = null;
            return _this;
        }
        /**
         *
         */
        GLTFAsset.getComponentTypeCount = function (type) {
            switch (type) {
                case 5120 /* Byte */:
                case 5121 /* UnsignedByte */:
                    return 1;
                case 5122 /* Short */:
                case 5123 /* UnsignedShort */:
                    return 2;
                case 5124 /* Int */:
                case 5125 /* UnsignedInt */:
                    return 4;
                case 5126 /* Float */:
                    return 4;
                default:
                    throw new Error();
            }
        };
        /**
         *
         */
        GLTFAsset.getAccessorTypeCount = function (type) {
            switch (type) {
                case "SCALAR" /* SCALAR */:
                    return 1;
                case "VEC2" /* VEC2 */:
                    return 2;
                case "VEC3" /* VEC3 */:
                    return 3;
                case "VEC4" /* VEC4 */:
                case "MAT2" /* MAT2 */:
                    return 4;
                case "MAT3" /* MAT3 */:
                    return 9;
                case "MAT4" /* MAT4 */:
                    return 16;
                default:
                    throw new Error();
            }
        };
        /**
         * @private
         */
        GLTFAsset.createConfig = function () {
            var config = {
                version: "5",
                asset: {
                    version: "2.0"
                },
                extensions: {},
                extensionsRequired: ["paper"],
                extensionsUsed: ["paper"],
            };
            return config;
        };
        /**
         * @private
         */
        GLTFAsset.parseFromBinary = function (array) {
            var index = 0;
            var result = { buffers: [] };
            if (array[index++] !== 0x46546C67 ||
                array[index++] !== 2) {
                console.assert(false, "Nonsupport glTF data.");
                return;
            }
            if (array[index++] !== array.byteLength) {
                console.assert(false, "Error glTF data.");
                return;
            }
            var chunkLength = 0;
            var chunkType = 0;
            while (index < array.length) {
                chunkLength = array[index++];
                chunkType = array[index++];
                if (chunkLength % 4) {
                    console.assert(false, "Error glTF data.");
                }
                if (chunkType === 0x4E4F534A) {
                    var jsonArray = new Uint8Array(array.buffer, index * 4 + array.byteOffset, chunkLength / Uint8Array.BYTES_PER_ELEMENT);
                    var jsonString = egret3d.io.BinReader.utf8ArrayToString(jsonArray);
                    result.config = JSON.parse(jsonString);
                }
                else if (chunkType === 0x004E4942) {
                    var buffer = new Uint32Array(array.buffer, index * 4 + array.byteOffset, chunkLength / Uint32Array.BYTES_PER_ELEMENT);
                    result.buffers.push(buffer);
                }
                else {
                    console.assert(false, "Nonsupport glTF data.");
                    return;
                }
                index += chunkLength / 4;
            }
            return result;
        };
        GLTFAsset.prototype.initialize = function (name, config, buffers) {
            var args = [];
            for (var _i = 3; _i < arguments.length; _i++) {
                args[_i - 3] = arguments[_i];
            }
            _super.prototype.initialize.call(this);
            this.name = name;
            this.config = config;
            if (buffers) {
                for (var _a = 0, buffers_1 = buffers; _a < buffers_1.length; _a++) {
                    var buffer = buffers_1[_a];
                    this.buffers.push(buffer);
                }
            }
        };
        GLTFAsset.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            this.buffers.length = 0;
            this.config = null;
            return true;
        };
        /**
         *
         */
        GLTFAsset.prototype.updateAccessorTypeCount = function () {
            var accessors = this.config.accessors;
            if (accessors) {
                for (var _i = 0, accessors_1 = accessors; _i < accessors_1.length; _i++) {
                    var accessor = accessors_1[_i];
                    accessor.typeCount = GLTFAsset.getAccessorTypeCount(accessor.type);
                }
            }
            return this;
        };
        /**
         * 根据指定 BufferView 创建二进制数组。
         */
        GLTFAsset.prototype.createTypeArrayFromBufferView = function (bufferView, componentType) {
            var buffer = this.buffers[bufferView.buffer];
            var bufferOffset = buffer.byteOffset + (bufferView.byteOffset || 0);
            // assert.config.buffers[bufferView.buffer];
            switch (componentType) {
                case 5120 /* Byte */:
                    return new Int8Array(buffer.buffer, bufferOffset, bufferView.byteLength / Int8Array.BYTES_PER_ELEMENT);
                case 5121 /* UnsignedByte */:
                    return new Uint8Array(buffer.buffer, bufferOffset, bufferView.byteLength / Uint8Array.BYTES_PER_ELEMENT);
                case 5122 /* Short */:
                    return new Int16Array(buffer.buffer, bufferOffset, bufferView.byteLength / Int16Array.BYTES_PER_ELEMENT);
                case 5123 /* UnsignedShort */:
                    return new Uint16Array(buffer.buffer, bufferOffset, bufferView.byteLength / Uint16Array.BYTES_PER_ELEMENT);
                case 5124 /* Int */:
                    return new Int32Array(buffer.buffer, bufferOffset, bufferView.byteLength / Int32Array.BYTES_PER_ELEMENT);
                case 5125 /* UnsignedInt */:
                    return new Uint32Array(buffer.buffer, bufferOffset, bufferView.byteLength / Uint32Array.BYTES_PER_ELEMENT);
                case 5126 /* Float */:
                    return new Float32Array(buffer.buffer, bufferOffset, bufferView.byteLength / Float32Array.BYTES_PER_ELEMENT);
                default:
                    throw new Error();
            }
        };
        /**
         * 根据指定 Accessor 创建二进制数组。
         */
        GLTFAsset.prototype.createTypeArrayFromAccessor = function (accessor, offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            var typeCount = accessor.typeCount;
            var bufferCount = typeCount * Math.min(accessor.count - offset, count || accessor.count);
            var bufferView = this.getBufferView(accessor);
            var buffer = this.buffers[bufferView.buffer];
            // assert.config.buffers[bufferView.buffer];
            var bufferOffset = buffer.byteOffset + (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
            if (offset > 0) {
                bufferOffset += offset * typeCount * GLTFAsset.getComponentTypeCount(accessor.componentType);
            }
            switch (accessor.componentType) {
                case 5120 /* Byte */:
                    return new Int8Array(buffer.buffer, bufferOffset, bufferCount);
                case 5121 /* UnsignedByte */:
                    return new Uint8Array(buffer.buffer, bufferOffset, bufferCount);
                case 5122 /* Short */:
                    return new Int16Array(buffer.buffer, bufferOffset, bufferCount);
                case 5123 /* UnsignedShort */:
                    return new Uint16Array(buffer.buffer, bufferOffset, bufferCount);
                case 5124 /* Int */:
                    return new Int32Array(buffer.buffer, bufferOffset, bufferCount);
                case 5125 /* UnsignedInt */:
                    return new Uint32Array(buffer.buffer, bufferOffset, bufferCount);
                case 5126 /* Float */:
                    return new Float32Array(buffer.buffer, bufferOffset, bufferCount);
                default:
                    throw new Error();
            }
        };
        /**
         * 通过 Accessor 获取指定 BufferLength。
         */
        GLTFAsset.prototype.getBufferLength = function (accessor) {
            return accessor.typeCount * GLTFAsset.getComponentTypeCount(accessor.componentType) * accessor.count;
        };
        /**
         * 通过 Accessor 获取指定 BufferOffset。
         */
        GLTFAsset.prototype.getBufferOffset = function (accessor) {
            var bufferView = this.getBufferView(accessor);
            // const buffer = this.buffers[bufferView.buffer];
            return (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
        };
        /**
         * 通过 Accessor 获取指定 Buffer。
         */
        GLTFAsset.prototype.getBuffer = function (accessor) {
            var bufferView = this.getBufferView(accessor);
            // this.config.buffers[bufferView.buffer];
            return this.buffers[bufferView.buffer];
        };
        /**
         * 通过 Accessor 获取指定 BufferView。
         */
        GLTFAsset.prototype.getBufferView = function (accessor) {
            return this.config.bufferViews[accessor.bufferView || 0];
        };
        /**
         * 通过 Accessor 索引，获取指定 Accessor。
         */
        GLTFAsset.prototype.getAccessor = function (index) {
            return this.config.accessors[index];
        };
        /**
         * 获取节点。
         */
        GLTFAsset.prototype.getNode = function (index) {
            return this.config.nodes[index];
        };
        return GLTFAsset;
    }(paper.Asset));
    egret3d.GLTFAsset = GLTFAsset;
    __reflect(GLTFAsset.prototype, "egret3d.GLTFAsset");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 欧拉旋转顺序。
     */
    var EulerOrder;
    (function (EulerOrder) {
        EulerOrder[EulerOrder["XYZ"] = 1] = "XYZ";
        EulerOrder[EulerOrder["XZY"] = 2] = "XZY";
        EulerOrder[EulerOrder["YXZ"] = 3] = "YXZ";
        EulerOrder[EulerOrder["YZX"] = 4] = "YZX";
        EulerOrder[EulerOrder["ZXY"] = 5] = "ZXY";
        EulerOrder[EulerOrder["ZYX"] = 6] = "ZYX";
    })(EulerOrder = egret3d.EulerOrder || (egret3d.EulerOrder = {}));
    /**
     * 三维向量。
     */
    var Vector3 = (function (_super) {
        __extends(Vector3, _super);
        /**
         * 请使用 `egret3d.Vector3.create()` 创建实例。
         * @see egret3d.Vector3.create()
         * @deprecated
         * @private
         */
        function Vector3(x, y, z) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            _this.z = z;
            return _this;
        }
        /**
         * 创建一个三维向量。
         * @param x X 轴分量。
         * @param y Y 轴分量。
         * @param z Z 轴分量。
         */
        Vector3.create = function (x, y, z) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(x, y, z);
                instance._released = false;
                return instance;
            }
            return new Vector3().set(x, y, z);
        };
        Vector3.prototype.serialize = function () {
            return [this.x, this.y, this.z];
        };
        Vector3.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Vector3.prototype.copy = function (value) {
            return this.set(value.x, value.y, value.z);
        };
        Vector3.prototype.clone = function () {
            return Vector3.create(this.x, this.y, this.z);
        };
        Vector3.prototype.set = function (x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        };
        Vector3.prototype.fromArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            return this;
        };
        Vector3.prototype.fromMatrixPosition = function (matrix) {
            var array = matrix.rawData;
            this.x = array[12];
            this.y = array[13];
            this.z = array[14];
            return this.fromArray(matrix.rawData, 12);
        };
        Vector3.prototype.fromMatrixColumn = function (matrix, index) {
            return this.fromArray(matrix.rawData, index * 4);
        };
        Vector3.prototype.clear = function () {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            return this;
        };
        /**
         * 判断该向量是否和一个向量相等。
         * @param value 一个向量。
         * @param threshold 阈值。
         */
        Vector3.prototype.equal = function (value, threshold) {
            if (threshold === void 0) { threshold = 2.220446049250313e-16 /* EPSILON */; }
            if (Math.abs(this.x - value.x) <= threshold &&
                Math.abs(this.y - value.y) <= threshold &&
                Math.abs(this.z - value.z) <= threshold) {
                return true;
            }
            return false;
        };
        Vector3.prototype.normalize = function (input, defaultVector) {
            if (input === void 0) { input = null; }
            if (defaultVector === void 0) { defaultVector = Vector3.FORWARD; }
            if (input === null) {
                input = this;
            }
            var x = input.x, y = input.y, z = input.z;
            var l = Math.sqrt(x * x + y * y + z * z);
            if (l > 2.220446049250313e-16 /* EPSILON */) {
                l = 1.0 / l;
                this.x = x * l;
                this.y = y * l;
                this.z = z * l;
            }
            else {
                this.copy(defaultVector);
            }
            return this;
        };
        Vector3.prototype.orthoNormal = function (input) {
            if (input === void 0) { input = null; }
            if (input === null) {
                input = this;
            }
            var x = input.x, y = input.y, z = input.z;
            if (z > 0.0 ? z > 0.70710678118655 /* SQRT1_2 */ : z < 0.70710678118655 /* SQRT1_2 */) {
                var k = 1.0 / Math.sqrt(y * y + z * z);
                this.x = 0.0;
                this.y = -z * k;
                this.z = y * k;
            }
            else {
                var k = 1.0 / Math.sqrt(x * x + y * y);
                this.x = -y * k;
                this.y = x * k;
                this.z = 0.0;
            }
            return this;
        };
        Vector3.prototype.negate = function (input) {
            if (input === void 0) { input = null; }
            if (input === null) {
                input = this;
            }
            this.x = -input.x;
            this.y = -input.y;
            this.z = -input.z;
            return this;
        };
        Vector3.prototype.fromSphericalCoords = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                p3 = p1.z;
                p2 = p1.y;
                p1 = p1.x;
            }
            var sinPhiRadius = Math.sin(p2) * p1;
            this.x = sinPhiRadius * Math.sin(p3);
            this.y = Math.cos(p2) * p1;
            this.z = sinPhiRadius * Math.cos(p3);
            return this;
        };
        Vector3.prototype.applyMatrix3 = function (matrix, input) {
            if (input === void 0) { input = null; }
            if (input === null) {
                input = this;
            }
            var x = input.x, y = input.y, z = input.z;
            var rawData = matrix.rawData;
            if (matrix.constructor === egret3d.Matrix3) {
                this.x = rawData[0] * x + rawData[3] * y + rawData[6] * z;
                this.y = rawData[1] * x + rawData[4] * y + rawData[7] * z;
                this.z = rawData[2] * x + rawData[5] * y + rawData[8] * z;
            }
            else {
                this.x = rawData[0] * x + rawData[4] * y + rawData[8] * z;
                this.y = rawData[1] * x + rawData[5] * y + rawData[9] * z;
                this.z = rawData[2] * x + rawData[6] * y + rawData[10] * z;
            }
            return this;
        };
        Vector3.prototype.applyMatrix = function (matrix, input) {
            if (input === void 0) { input = null; }
            if (input === null) {
                input = this;
            }
            var x = input.x, y = input.y, z = input.z;
            var rawData = matrix.rawData;
            var w = rawData[3] * x + rawData[7] * y + rawData[11] * z + rawData[15];
            if (w < -2.220446049250313e-16 /* EPSILON */ || 2.220446049250313e-16 /* EPSILON */ < w) {
                w = 1.0 / w;
                this.x = (rawData[0] * x + rawData[4] * y + rawData[8] * z + rawData[12]) * w;
                this.y = (rawData[1] * x + rawData[5] * y + rawData[9] * z + rawData[13]) * w;
                this.z = (rawData[2] * x + rawData[6] * y + rawData[10] * z + rawData[14]) * w;
            }
            else {
                if (true) {
                    console.warn("Dividing by zero.");
                }
                this.x = 0.0;
                this.y = 0.0;
                this.z = 0.0;
            }
            return this;
        };
        Vector3.prototype.applyDirection = function (matrix, input) {
            if (input === void 0) { input = null; }
            if (input === null) {
                input = this;
            }
            var x = input.x, y = input.y, z = input.z;
            var rawData = matrix.rawData;
            this.x = rawData[0] * x + rawData[4] * y + rawData[8] * z;
            this.y = rawData[1] * x + rawData[5] * y + rawData[9] * z;
            this.z = rawData[2] * x + rawData[6] * y + rawData[10] * z;
            return this.normalize();
        };
        Vector3.prototype.applyQuaternion = function (quaternion, input) {
            if (input === void 0) { input = null; }
            if (input === null) {
                input = this;
            }
            var x = input.x, y = input.y, z = input.z;
            var qx = quaternion.x, qy = quaternion.y, qz = quaternion.z, qw = quaternion.w;
            // calculate quat * vector
            var ix = qw * x + qy * z - qz * y;
            var iy = qw * y + qz * x - qx * z;
            var iz = qw * z + qx * y - qy * x;
            var iw = -qx * x - qy * y - qz * z;
            // calculate result * inverse quat
            this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return this;
        };
        Vector3.prototype.addScalar = function (scalar, input) {
            if (input === void 0) { input = null; }
            if (input === null) {
                input = this;
            }
            this.x = input.x + scalar;
            this.y = input.y + scalar;
            this.z = input.z + scalar;
            return this;
        };
        Vector3.prototype.multiplyScalar = function (scalar, input) {
            if (input === void 0) { input = null; }
            if (input === null) {
                input = this;
            }
            this.x = scalar * input.x;
            this.y = scalar * input.y;
            this.z = scalar * input.z;
            return this;
        };
        Vector3.prototype.add = function (vectorA, vectorB) {
            if (vectorB === void 0) { vectorB = null; }
            if (vectorB === null) {
                vectorB = vectorA;
                vectorA = this;
            }
            this.x = vectorA.x + vectorB.x;
            this.y = vectorA.y + vectorB.y;
            this.z = vectorA.z + vectorB.z;
            return this;
        };
        Vector3.prototype.subtract = function (vectorA, vectorB) {
            if (vectorB === void 0) { vectorB = null; }
            if (vectorB === null) {
                vectorB = vectorA;
                vectorA = this;
            }
            this.x = vectorA.x - vectorB.x;
            this.y = vectorA.y - vectorB.y;
            this.z = vectorA.z - vectorB.z;
            return this;
        };
        Vector3.prototype.multiply = function (vectorA, vectorB) {
            if (vectorB === void 0) { vectorB = null; }
            if (vectorB === null) {
                vectorB = vectorA;
                vectorA = this;
            }
            this.x = vectorA.x * vectorB.x;
            this.y = vectorA.y * vectorB.y;
            this.z = vectorA.z * vectorB.z;
            return this;
        };
        Vector3.prototype.divide = function (vectorA, vectorB) {
            if (vectorB === void 0) { vectorB = null; }
            if (vectorB === null) {
                vectorB = vectorA;
                vectorA = this;
            }
            if (true && (vectorB.x === 0.0 || vectorB.y === 0.0 || vectorB.z === 0)) {
                console.warn("Dividing by zero.");
            }
            this.x = vectorA.x / vectorB.x;
            this.y = vectorA.y / vectorB.y;
            this.z = vectorA.z / vectorB.z;
            return this;
        };
        /**
         * 将该向量与一个向量相点乘。
         * - v · vector
         * @param vector 一个向量。
         */
        Vector3.prototype.dot = function (vector) {
            return this.x * vector.x + this.y * vector.y + this.z * vector.z;
        };
        Vector3.prototype.cross = function (vectorA, vectorB) {
            if (vectorB === void 0) { vectorB = null; }
            if (vectorB === null) {
                vectorB = vectorA;
                vectorA = this;
            }
            var x = vectorA.x;
            var y = vectorA.y;
            var z = vectorA.z;
            var xB = vectorB.x;
            var yB = vectorB.y;
            var zB = vectorB.z;
            this.x = y * zB - z * yB;
            this.y = z * xB - x * zB;
            this.z = x * yB - y * xB;
            return this;
        };
        Vector3.prototype.lerp = function (p1, p2, p3) {
            if (typeof p1 === "number") {
                if (!p3) {
                    p3 = p1;
                    p1 = this;
                }
                else {
                    var temp = p1;
                    p1 = p2;
                    p2 = p3;
                    p3 = temp;
                }
            }
            else if (typeof p2 === "number") {
                p3 = p2;
                p2 = p1;
                p1 = this;
            }
            this.x = p1.x + (p2.x - p1.x) * p3;
            this.y = p1.y + (p2.y - p1.y) * p3;
            this.z = p1.z + (p2.z - p1.z) * p3;
            return this;
        };
        Vector3.prototype.slerp = function (from, to, t) {
            if (t === void 0) { t = 0.0; }
            if (typeof to === "number") {
                t = to;
                to = from;
                from = this;
            }
            var fromLength = from.length;
            var toLength = to.length;
            if (fromLength < 2.220446049250313e-16 /* EPSILON */ || toLength < 2.220446049250313e-16 /* EPSILON */) {
                return this.lerp(from, to, t);
            }
            var dot = from.dot(to) / (fromLength * toLength);
            if (dot > 1.0 - 2.220446049250313e-16 /* EPSILON */) {
                return this.lerp(from, to, t);
            }
            var lerpedLength = egret3d.math.lerp(fromLength, toLength, t);
            if (dot < -1.0 + 2.220446049250313e-16 /* EPSILON */) {
                var axis = this.orthoNormal(from);
                egret3d.helpMatrix3A.fromMatrix4(egret3d.helpMatrixA.fromAxis(axis, 3.141592653589793 /* PI */ * t));
                this.multiplyScalar(1.0 / fromLength, from).applyMatrix3(egret3d.helpMatrix3A).multiplyScalar(lerpedLength);
            }
            else {
                var axis = this.cross(from, to).normalize();
                egret3d.helpMatrix3A.fromMatrix4(egret3d.helpMatrixA.fromAxis(axis, Math.acos(dot) * t));
                this.multiplyScalar(1.0 / fromLength, from).applyMatrix3(egret3d.helpMatrix3A).multiplyScalar(lerpedLength);
            }
            return this;
        };
        Vector3.prototype.min = function (valueA, valueB) {
            if (valueB === void 0) { valueB = null; }
            if (valueB === null) {
                valueB = valueA;
                valueA = this;
            }
            this.x = Math.min(valueA.x, valueB.x);
            this.y = Math.min(valueA.y, valueB.y);
            this.z = Math.min(valueA.z, valueB.z);
            return this;
        };
        Vector3.prototype.max = function (valueA, valueB) {
            if (valueB === void 0) { valueB = null; }
            if (valueB === null) {
                valueB = valueA;
                valueA = this;
            }
            this.x = Math.max(valueA.x, valueB.x);
            this.y = Math.max(valueA.y, valueB.y);
            this.z = Math.max(valueA.z, valueB.z);
            return this;
        };
        Vector3.prototype.clamp = function (min, max, input) {
            if (input === void 0) { input = null; }
            if (input === null) {
                input = this;
            }
            if (true && (min.x > max.x || min.y > max.y || min.z > max.z)) {
                console.warn("Invalid arguments.");
            }
            // assumes min < max, componentwise
            this.x = Math.max(min.x, Math.min(max.x, input.x));
            this.y = Math.max(min.y, Math.min(max.y, input.y));
            this.z = Math.max(min.z, Math.min(max.z, input.z));
            return this;
        };
        Vector3.prototype.reflect = function (normal, input) {
            if (input === void 0) { input = null; }
            if (input === null) {
                input = this;
            }
            return this.subtract(input, _helpVector3.multiplyScalar(2.0 * input.dot(normal), normal));
        };
        /**
         * 获取一个向量和该向量的夹角。
         * - 弧度制。
         * @param vector 一个向量。
         */
        Vector3.prototype.getAngle = function (vector) {
            var v = this.squaredLength * vector.squaredLength;
            if (v < 2.220446049250313e-16 /* EPSILON */) {
                if (true) {
                    console.warn("Dividing by zero.");
                }
                return 0.0;
            }
            var theta = this.dot(vector) / Math.sqrt(v);
            // clamp, to handle numerical problems
            return Math.acos(Math.max(-1.0, Math.min(1.0, theta)));
        };
        /**
         * 获取一点到该点的欧氏距离（直线距离）的平方。
         * @param point 一个点。
         */
        Vector3.prototype.getSquaredDistance = function (point) {
            return _helpVector3.subtract(point, this).squaredLength;
        };
        /**
         * 获取一点到该点的欧氏距离（直线距离）。
         * @param point 一个点。
         */
        Vector3.prototype.getDistance = function (point) {
            return _helpVector3.subtract(point, this).length;
        };
        /**
         * 将该向量转换为数组。
         * @param array 数组。
         * @param offset 数组偏移。
         */
        Vector3.prototype.toArray = function (array, offset) {
            if (array === void 0) { array = null; }
            if (offset === void 0) { offset = 0; }
            if (array === null) {
                array = [];
            }
            array[0 + offset] = this.x;
            array[1 + offset] = this.y;
            array[2 + offset] = this.z;
            return array;
        };
        Object.defineProperty(Vector3.prototype, "length", {
            /**
             * 该向量的长度。
             * - 该值是实时计算的。
             */
            get: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3.prototype, "squaredLength", {
            /**
             * 该向量的长度的平方。
             * - 该值是实时计算的。
             */
            get: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        Vector3.set = function (x, y, z, out) {
            out.x = x;
            out.y = y;
            out.z = z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.normalize = function (v) {
            return v.normalize();
        };
        /**
         * @deprecated
         */
        Vector3.copy = function (v, out) {
            out.x = v.x;
            out.y = v.y;
            out.z = v.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.add = function (v1, v2, out) {
            out.x = v1.x + v2.x;
            out.y = v1.y + v2.y;
            out.z = v1.z + v2.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.multiply = function (v1, v2, out) {
            out.x = v1.x * v2.x;
            out.y = v1.y * v2.y;
            out.z = v1.z * v2.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.scale = function (v, scale) {
            v.x = v.x * scale;
            v.y = v.y * scale;
            v.z = v.z * scale;
            return v;
        };
        /**
         * @deprecated
         */
        Vector3.cross = function (lhs, rhs, out) {
            out.x = lhs.y * rhs.z - lhs.z * rhs.y;
            out.y = lhs.z * rhs.x - lhs.x * rhs.z;
            out.z = lhs.x * rhs.y - lhs.y * rhs.x;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.dot = function (v1, v2) {
            return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
        };
        /**
         * @deprecated
         */
        Vector3.lerp = function (v1, v2, v, out) {
            out.x = v1.x * (1 - v) + v2.x * v;
            out.y = v1.y * (1 - v) + v2.y * v;
            out.z = v1.z * (1 - v) + v2.z * v;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.equal = function (v1, v2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(v1.x - v2.x) > threshold) {
                return false;
            }
            if (Math.abs(v1.y - v2.y) > threshold) {
                return false;
            }
            if (Math.abs(v1.z - v2.z) > threshold) {
                return false;
            }
            return true;
        };
        /**
         * @deprecated
         */
        Vector3.subtract = function (v1, v2, out) {
            out.x = v1.x - v2.x;
            out.y = v1.y - v2.y;
            out.z = v1.z - v2.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.getSqrLength = function (v) {
            return v.x * v.x + v.y * v.y + v.z * v.z;
        };
        /**
         * @deprecated
         */
        Vector3.getLength = function (v) {
            return Math.sqrt(this.getSqrLength(v));
        };
        /**
         * @deprecated
         */
        Vector3.getDistance = function (a, b) {
            return this.getLength(this.subtract(a, b, _helpVector3));
        };
        /**
         * 零向量。
         * - 请注意不要修改该值。
         */
        Vector3.ZERO = new Vector3(0.0, 0.0, 0.0);
        /**
         * 三方向均为一的向量。
         * - 请注意不要修改该值。
         */
        Vector3.ONE = new Vector3(1.0, 1.0, 1.0);
        /**
         * 三方向均为负一的向量。
         * - 请注意不要修改该值。
         */
        Vector3.MINUS_ONE = new Vector3(-1.0, -1.0, -1.0);
        /**
         * 上向量。
         * - 请注意不要修改该值。
         */
        Vector3.UP = new Vector3(0.0, 1.0, 0.0);
        /**
         * 下向量。
         * - 请注意不要修改该值。
         */
        Vector3.DOWN = new Vector3(0.0, -1.0, 0.0);
        /**
         * 左向量。
         * - 请注意不要修改该值。
         */
        Vector3.LEFT = new Vector3(-1.0, 0.0, 0.0);
        /**
         * 右向量。
         * - 请注意不要修改该值。
         */
        Vector3.RIGHT = new Vector3(1.0, 0.0, 0.0);
        /**
         * 前向量。
         * - 请注意不要修改该值。
         */
        Vector3.FORWARD = new Vector3(0.0, 0.0, 1.0);
        /**
         * 后向量。
         * - 请注意不要修改该值。
         */
        Vector3.BACK = new Vector3(0.0, 0.0, -1.0);
        Vector3._instances = [];
        return Vector3;
    }(paper.BaseRelease));
    egret3d.Vector3 = Vector3;
    __reflect(Vector3.prototype, "egret3d.Vector3", ["egret3d.IVector3", "egret3d.IVector2", "paper.ICCS", "paper.ISerializable"]);
    var _helpVector3 = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3A = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3B = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3C = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3D = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3E = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3F = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3G = Vector3.create();
    /**
     * @internal
     */
    egret3d.helpVector3H = Vector3.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 基础实体。
     */
    var Entity = (function (_super) {
        __extends(Entity, _super);
        /**
         * 禁止实例化实体。
         * @protected
         */
        function Entity() {
            var _this = _super.call(this) || this;
            _this.name = "";
            _this.tag = "";
            _this.hideFlags = 0 /* None */;
            _this.extras = paper.Application.playerMode === 4 /* Editor */ ? {} : undefined;
            _this._componentsDirty = false;
            _this._isDestroyed = true;
            _this._enabled = false;
            _this._components = [];
            /**
             * @internal
             */
            _this._removedComponents = [];
            _this._cachedComponents = [];
            _this._scene = null;
            return _this;
        }
        Entity.prototype._destroy = function () {
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (component) {
                    this._removeComponent(component, null);
                }
            }
        };
        Entity.prototype._setScene = function (value, dispatchEvent) {
            if (value) {
                if (this._scene) {
                    this._scene._removeEntity(this);
                }
                value._addEntity(this);
                this._scene = value;
            }
            if (dispatchEvent) {
                Entity.onEntityAddedToScene.dispatch(this);
            }
        };
        Entity.prototype._setEnabled = function (value) {
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (!component) {
                    continue;
                }
                if (component.constructor === paper.GroupComponent) {
                    for (var _b = 0, _c = component.components; _b < _c.length; _b++) {
                        var componentInGroup = _c[_b];
                        if (componentInGroup.enabled) {
                            componentInGroup.dispatchEnabledEvent(value);
                        }
                    }
                }
                else if (component.enabled) {
                    component.dispatchEnabledEvent(value);
                }
            }
        };
        Entity.prototype._addComponent = function (component, config) {
            component.initialize(config);
            paper.Component.onComponentCreated.dispatch([this, component]);
            if (component.isActiveAndEnabled) {
                component.dispatchEnabledEvent(true);
            }
        };
        /**
         * @internal
         */
        Entity.prototype._removeComponent = function (component, groupComponent) {
            var componentClass = component.constructor;
            component.enabled = false;
            //
            paper.Component.onComponentDestroy.dispatch([this, component]);
            component._destroy();
            if (groupComponent) {
                groupComponent.removeComponent(component);
                if (groupComponent.components.length === 0) {
                    this._removeComponent(groupComponent, null);
                }
            }
            else if (componentClass === paper.GroupComponent) {
                groupComponent = component;
                for (var _i = 0, _a = groupComponent.components; _i < _a.length; _i++) {
                    var componentInGroup = _a[_i];
                    this._removeComponent(componentInGroup, groupComponent);
                }
                delete this._components[groupComponent.componentIndex];
            }
            else {
                this._removedComponents[componentClass.componentIndex] = component;
                delete this._components[componentClass.componentIndex];
            }
            paper.Component.onComponentDestroyed.dispatch([this, component]);
            this._componentsDirty = true;
        };
        Entity.prototype._getComponent = function (componentClass) {
            var componentIndex = componentClass.componentIndex;
            return componentIndex < 0 ? undefined : this._components[componentIndex];
        };
        Entity.prototype._isRequireComponent = function (componentClass) {
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (component) {
                    var requireComponents = ((component.constructor === paper.GroupComponent) ?
                        component.components[0] :
                        component).constructor.requireComponents;
                    if (requireComponents &&
                        requireComponents.indexOf(componentClass) >= 0) {
                        // TODO
                        // console.warn(`Cannot remove the ${egret.getQualifiedClassName(value)} component from the game object (${this.path}), because it is required from the ${egret.getQualifiedClassName(component)} component.`);
                        return true;
                    }
                }
            }
            return false;
        };
        Entity.prototype.initialize = function () {
        };
        Entity.prototype.uninitialize = function () {
            this.name = "";
            this.tag = "";
            this.hideFlags = 0 /* None */;
            if (this.extras) {
                this.extras = {};
            }
            this._componentsDirty = false;
            this._cachedComponents.length = 0;
            this._removedComponents.length = 0;
            this._scene = null;
        };
        Entity.prototype.destroy = function () {
            if (this._isDestroyed) {
                if (true) {
                    console.warn("The entity has been destroyed.");
                }
                return false;
            }
            if (this === paper.Application.sceneManager._globalEntity) {
                if (true) {
                    console.warn("Cannot destroy global entity.");
                }
                return false;
            }
            Entity.onEntityDestroy.dispatch(this);
            this._destroy();
            this._scene._removeEntity(this);
            this._isDestroyed = true;
            this._components.length = 0;
            this._scene = null;
            Entity.onEntityDestroyed.dispatch(this);
            return true;
        };
        Entity.prototype.addComponent = function (componentClass, config) {
            if (!componentClass) {
                throw new Error();
            }
            if (this._isDestroyed) {
                throw new Error("The entity has been destroyed.");
            }
            //
            paper.registerClass(componentClass);
            // Singleton component.
            var globalEntity = paper.Application.sceneManager._globalEntity;
            if (componentClass.isSingleton && globalEntity && this !== globalEntity) {
                return globalEntity.getComponent(componentClass) || globalEntity.addComponent(componentClass, config);
            }
            var componentIndex = componentClass.componentIndex;
            var components = this._components;
            var existedComponent = components[componentIndex];
            // Check multiple component.
            if (!componentClass.allowMultiple && existedComponent) {
                if (true) {
                    console.warn("Cannot add the " + egret.getQualifiedClassName(componentClass) + " component to the entity (" + this.name + ") again.");
                }
                return existedComponent;
            }
            // Require components.
            if (componentClass.requireComponents) {
                for (var _i = 0, _a = componentClass.requireComponents; _i < _a.length; _i++) {
                    var requireComponentClass = _a[_i];
                    this.getComponent(requireComponentClass) || this.addComponent(requireComponentClass);
                }
            }
            // Create and add component.
            var component = paper.Component.create(this, componentClass);
            if (existedComponent) {
                if (existedComponent.constructor === paper.GroupComponent) {
                    existedComponent.addComponent(component);
                }
                else {
                    paper.registerClass(paper.GroupComponent); // TODO
                    //
                    var groupComponent = paper.Component.create(this, paper.GroupComponent);
                    groupComponent.initialize(componentIndex);
                    groupComponent.addComponent(existedComponent);
                    groupComponent.addComponent(component);
                    components[componentIndex] = groupComponent;
                }
            }
            else {
                components[componentIndex] = component;
            }
            this._componentsDirty = true;
            this._addComponent(component, config);
            return component;
        };
        Entity.prototype.removeComponent = function (componentInstanceOrClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (true && !componentInstanceOrClass) {
                throw new Error();
            }
            var result = false;
            var globalEntity = paper.Application.sceneManager._globalEntity;
            if (componentInstanceOrClass instanceof paper.Component) {
                var componentClass = componentInstanceOrClass.constructor;
                if (componentClass.isSingleton && globalEntity && this !== globalEntity) {
                    return globalEntity.removeComponent(componentInstanceOrClass);
                }
                if (!this._isRequireComponent(componentClass)) {
                    this._removeComponent(componentInstanceOrClass, null);
                    result = true;
                }
            }
            else {
                var componentClass = componentInstanceOrClass;
                if (componentClass.isSingleton && globalEntity && this !== globalEntity) {
                    return globalEntity.removeComponent(componentClass, isExtends);
                }
                if (isExtends) {
                    for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                        var component = _a[_i];
                        if (component) {
                            var groupComponent = null;
                            if (component.constructor === paper.GroupComponent) {
                                groupComponent = component;
                                component = groupComponent.components[0];
                            }
                            if (component instanceof componentClass &&
                                (groupComponent && groupComponent.components.length > 1 ||
                                    !this._isRequireComponent(component.constructor))) {
                                this._removeComponent(component, groupComponent);
                                result = true;
                            }
                        }
                    }
                }
                else {
                    var component = this._getComponent(componentClass);
                    if (component) {
                        var groupComponent = null;
                        if (component.constructor === paper.GroupComponent) {
                            groupComponent = component;
                            component = groupComponent.components[0];
                        }
                        if (groupComponent && groupComponent.components.length > 1 ||
                            !this._isRequireComponent(componentClass)) {
                            this._removeComponent(component, groupComponent);
                            result = true;
                        }
                    }
                }
            }
            return result;
        };
        Entity.prototype.removeAllComponents = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            var result = false;
            if (componentClass) {
                var globalEntity = paper.Application.sceneManager._globalEntity;
                if (componentClass.isSingleton && globalEntity && this !== globalEntity) {
                    return globalEntity.removeAllComponents(componentClass, isExtends);
                }
                if (isExtends) {
                    for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                        var component = _a[_i];
                        if (component) {
                            var groupComponent = null;
                            if (component.constructor === paper.GroupComponent) {
                                groupComponent = component;
                                component = groupComponent.components[0];
                            }
                            if (component instanceof componentClass &&
                                !this._isRequireComponent(component.constructor)) {
                                this._removeComponent(groupComponent || component, null);
                                result = true;
                            }
                        }
                    }
                }
                else {
                    var component = this._getComponent(componentClass);
                    if (component && !this._isRequireComponent(componentClass)) {
                        this._removeComponent(component, null);
                        result = true;
                    }
                }
            }
            else {
                for (var _b = 0, _c = this._components; _b < _c.length; _b++) {
                    var component = _c[_b];
                    if (component) {
                        this._removeComponent(component, null);
                        result = true;
                    }
                }
            }
            return result;
        };
        Entity.prototype.getOrAddComponent = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            return this.getComponent(componentClass, isExtends) || this.addComponent(componentClass);
        };
        Entity.prototype.getComponent = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (componentClass.isSingleton && this !== paper.Application.sceneManager._globalEntity) {
                return paper.Application.sceneManager._globalEntity.getComponent(componentClass, isExtends);
            }
            if (isExtends) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (component) {
                        if (component.constructor === paper.GroupComponent) {
                            if (component.components[0] instanceof componentClass) {
                                return component.components[0];
                            }
                        }
                        else if (component instanceof componentClass) {
                            return component;
                        }
                    }
                }
            }
            else {
                var componentIndex = componentClass.componentIndex;
                if (componentIndex > 0) {
                    var component = this._components[componentIndex];
                    if (component) {
                        if (component.constructor === paper.GroupComponent) {
                            return component.components[0];
                        }
                        return component;
                    }
                }
            }
            return null;
        };
        Entity.prototype.getRemovedComponent = function (componentClass) {
            var componentIndex = componentClass.componentIndex;
            var component = this._removedComponents[componentIndex];
            if (component) {
                return component;
            }
            return null;
        };
        Entity.prototype.getComponents = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (componentClass.isSingleton && this !== paper.Application.sceneManager._globalEntity) {
                return paper.Application.sceneManager._globalEntity.getComponents(componentClass, isExtends);
            }
            var components = [];
            if (isExtends) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (!component) {
                        continue;
                    }
                    if (component.constructor === paper.GroupComponent && component.components[0] instanceof componentClass) {
                        for (var _b = 0, _c = component.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            components.push(componentInGroup);
                        }
                    }
                    else if (component instanceof componentClass) {
                        components.push(component);
                    }
                }
            }
            else {
                var component = this._getComponent(componentClass);
                if (component) {
                    if (component.constructor === paper.GroupComponent) {
                        if (component.components[0] instanceof componentClass) {
                            for (var _d = 0, _e = component.components; _d < _e.length; _d++) {
                                var componentInGroup = _e[_d];
                                components.push(componentInGroup);
                            }
                        }
                    }
                    else if (component instanceof componentClass) {
                        components.push(component);
                    }
                }
            }
            return components;
        };
        Entity.prototype.hasComponents = function (componentClasses, componentEnabled) {
            var components = this._components;
            for (var i = 0, l = componentClasses.length; i < l; ++i) {
                var index = componentClasses[i].componentIndex;
                if (index < 0) {
                    return false;
                }
                var component = components[index];
                if (!component) {
                    return false;
                }
                if (componentEnabled) {
                    if (component.constructor === paper.GroupComponent) {
                        var flag = false;
                        for (var _i = 0, _a = component.components; _i < _a.length; _i++) {
                            var childComponent = _a[_i];
                            if (childComponent.isActiveAndEnabled) {
                                flag = true;
                                break;
                            }
                        }
                        if (!flag) {
                            return false;
                        }
                    }
                    else if (!component.isActiveAndEnabled) {
                        return false;
                    }
                }
            }
            return true;
        };
        Entity.prototype.hasAnyComponents = function (componentClasses, componentEnabled) {
            var components = this._components;
            for (var i = 0, l = componentClasses.length; i < l; ++i) {
                var index = componentClasses[i].componentIndex;
                if (index >= 0) {
                    var component = components[index];
                    if (component) {
                        if (componentEnabled) {
                            if (component.constructor === paper.GroupComponent) {
                                for (var _i = 0, _a = component.components; _i < _a.length; _i++) {
                                    var childComponent = _a[_i];
                                    if (childComponent.isActiveAndEnabled) {
                                        return true;
                                    }
                                }
                            }
                            else if (component.isActiveAndEnabled) {
                                return true;
                            }
                        }
                        else {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        Object.defineProperty(Entity.prototype, "isDestroyed", {
            get: function () {
                return this._isDestroyed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "dontDestroy", {
            get: function () {
                return this._scene === paper.Application.sceneManager.globalScene;
            },
            set: function (value) {
                var sceneManager = paper.Application.sceneManager;
                if (this.dontDestroy === value || this._isDestroyed || this === sceneManager._globalEntity) {
                    return;
                }
                this.scene = value ? sceneManager.globalScene : sceneManager.activeScene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "enabled", {
            get: function () {
                return this._enabled;
            },
            set: function (value) {
                if (this._enabled === value || this._isDestroyed || this === paper.Application.sceneManager._globalEntity) {
                    return;
                }
                this._enabled = value;
                this._setEnabled(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "components", {
            get: function () {
                var cachedComponents = this._cachedComponents;
                if (this._componentsDirty) {
                    var index = 0;
                    for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                        var component = _a[_i];
                        if (component) {
                            if (component.constructor === paper.GroupComponent) {
                                for (var _b = 0, _c = component.components; _b < _c.length; _b++) {
                                    var componentInGroup = _c[_b];
                                    cachedComponents[index++] = componentInGroup;
                                }
                            }
                            else {
                                cachedComponents[index++] = component;
                            }
                        }
                    }
                    if (cachedComponents.length !== index) {
                        cachedComponents.length = index;
                    }
                    this._componentsDirty = false;
                }
                return cachedComponents;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "scene", {
            get: function () {
                return this._scene;
            },
            set: function (value) {
                if (this._scene === value || this._isDestroyed || this === paper.Application.sceneManager._globalEntity) {
                    return;
                }
                this._setScene(value, true);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 当实体添加到场景时派发事件。
         */
        Entity.onEntityAddedToScene = new signals.Signal();
        /**
         * 当实体将要被销毁时派发事件。
         */
        Entity.onEntityDestroy = new signals.Signal();
        /**
         * 当实体被销毁时派发事件。
         */
        Entity.onEntityDestroyed = new signals.Signal();
        /**
         *
         */
        Entity.createDefaultEnabled = true;
        __decorate([
            paper.serializedField,
            paper.editor.property("TEXT" /* TEXT */)
        ], Entity.prototype, "name", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("LIST" /* LIST */, { listItems: paper.editor.getItemsFromEnum(paper.DefaultTags) }) // TODO
        ], Entity.prototype, "tag", void 0);
        __decorate([
            paper.serializedField
        ], Entity.prototype, "hideFlags", void 0);
        __decorate([
            paper.serializedField
        ], Entity.prototype, "extras", void 0);
        __decorate([
            paper.serializedField("_activeSelf")
        ], Entity.prototype, "_enabled", void 0);
        __decorate([
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], Entity.prototype, "enabled", null);
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore
        ], Entity.prototype, "components", null);
        return Entity;
    }(paper.BaseObject));
    paper.Entity = Entity;
    __reflect(Entity.prototype, "paper.Entity", ["paper.IEntity"]);
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 三角形。
     */
    var Triangle = (function (_super) {
        __extends(Triangle, _super);
        /**
         * 请使用 `egret3d.Triangle.create()` 创建实例。
         * @see egret3d.Triangle.create()
         */
        function Triangle() {
            var _this = _super.call(this) || this;
            /**
             * 点 A。
             */
            _this.a = egret3d.Vector3.create();
            /**
             * 点 B。
             */
            _this.b = egret3d.Vector3.create();
            /**
             * 点 C。
             */
            _this.c = egret3d.Vector3.create();
            return _this;
        }
        /**
         * 创建一个三角形实例。
         * -   a
         * -  /·\
         * - b - c
         * @param a 点 A。
         * @param b 点 B。
         * @param c 点 C。
         */
        Triangle.create = function (a, b, c) {
            if (a === void 0) { a = egret3d.Vector3.ZERO; }
            if (b === void 0) { b = egret3d.Vector3.ZERO; }
            if (c === void 0) { c = egret3d.Vector3.ZERO; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(a, b, c);
                instance._released = false;
                return instance;
            }
            return new Triangle().set(a, b, c);
        };
        /**
         * 通过三个点确定一个三角形，获取该三角形的法线。
         * -   a
         * -  /·\
         * - b - c
         * @param a 点 A。
         * @param b 点 B。
         * @param c 点 C。
         * @param out 法线结果。
         */
        Triangle.getNormal = function (a, b, c, out) {
            out.subtract(c, a);
            out.cross(egret3d.helpVector3A.subtract(b, a));
            var squaredLength = out.squaredLength;
            if (squaredLength > 0.0) {
                return out.multiplyScalar(1.0 / Math.sqrt(squaredLength));
            }
            return out.set(0.0, 0.0, 1.0);
        };
        Triangle.prototype.serialize = function () {
            return [
                this.a.x, this.a.y, this.a.z,
                this.b.x, this.b.y, this.b.z,
                this.c.x, this.c.y, this.c.z,
            ];
        };
        Triangle.prototype.deserialize = function (element) {
            return this.fromArray(element);
        };
        Triangle.prototype.copy = function (value) {
            return this.set(value.a, value.b, value.c);
        };
        Triangle.prototype.clone = function () {
            return Triangle.create(this.a, this.b, this.c);
        };
        Triangle.prototype.set = function (a, b, c) {
            if (a === void 0) { a = egret3d.Vector3.ZERO; }
            if (b === void 0) { b = egret3d.Vector3.ZERO; }
            if (c === void 0) { c = egret3d.Vector3.ZERO; }
            this.a.copy(a);
            this.b.copy(b);
            this.c.copy(c);
            return this;
        };
        Triangle.prototype.fromArray = function (array, offsetA, offsetB, offsetC) {
            if (offsetA === undefined) {
                offsetA = 0;
            }
            this.a.fromArray(array, offsetA);
            this.b.fromArray(array, offsetB !== undefined ? offsetB : offsetA + 3);
            this.c.fromArray(array, offsetC !== undefined ? offsetC : offsetA + 6);
        };
        /**
         * 获取该三角形的中心点。
         * @param out 输出。
         */
        Triangle.prototype.getCenter = function (out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return out.add(this.a, this.b).add(this.c).multiplyScalar(1.0 / 3.0);
        };
        /**
         * 获取该三角形的法线。
         * @param out 输出。
         */
        Triangle.prototype.getNormal = function (out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return Triangle.getNormal(this.a, this.b, this.c, out);
        };
        /**
         *
         * @param u
         * @param v
         * @param out
         */
        Triangle.prototype.getPointAt = function (u, v, out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            out.x = egret3d.math.lerp(this.a.x, this.c.x, u) + egret3d.math.lerp(0.0, this.b.x - this.a.x, v);
            out.y = egret3d.math.lerp(this.a.y, this.b.y, v) + egret3d.math.lerp(0.0, this.c.y - this.a.y, u);
            out.z = egret3d.math.lerp(this.a.z, this.c.z, u) + egret3d.math.lerp(0.0, this.b.z - this.a.z, v);
            return out;
        };
        /**
         * 获取一个点到该三角形的最近点。
         * @param point 一个点。
         * @param out 最近点。
         */
        Triangle.prototype.getClosestPointToPoint = function (point, out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            var vab = egret3d.helpVector3A;
            var vac = egret3d.helpVector3B;
            var vbc = egret3d.helpVector3C;
            var vap = egret3d.helpVector3D;
            var vbp = egret3d.helpVector3E;
            var vcp = egret3d.helpVector3F;
            var a = this.a, b = this.b, c = this.c;
            var v, w;
            // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
            // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
            // under the accompanying license; see chapter 5.1.5 for detailed explanation.
            // basically, we're distinguishing which of the voronoi regions of the triangle
            // the point lies in with the minimum amount of redundant computation.
            vab.subtract(b, a);
            vac.subtract(c, a);
            vap.subtract(point, a);
            var d1 = vab.dot(vap);
            var d2 = vac.dot(vap);
            if (d1 <= 0 && d2 <= 0) {
                // vertex region of A; barycentric coords (1, 0, 0)
                return out.copy(a);
            }
            vbp.subtract(point, b);
            var d3 = vab.dot(vbp);
            var d4 = vac.dot(vbp);
            if (d3 >= 0 && d4 <= d3) {
                // vertex region of B; barycentric coords (0, 1, 0)
                return out.copy(b);
            }
            var vc = d1 * d4 - d3 * d2;
            if (vc <= 0 && d1 >= 0 && d3 <= 0) {
                v = d1 / (d1 - d3);
                // edge region of AB; barycentric coords (1-v, v, 0)
                return out.multiplyScalar(v, vab).add(a);
            }
            vcp.subtract(point, c);
            var d5 = vab.dot(vcp);
            var d6 = vac.dot(vcp);
            if (d6 >= 0 && d5 <= d6) {
                // vertex region of C; barycentric coords (0, 0, 1)
                return out.copy(c);
            }
            var vb = d5 * d2 - d1 * d6;
            if (vb <= 0 && d2 >= 0 && d6 <= 0) {
                w = d2 / (d2 - d6);
                // edge region of AC; barycentric coords (1-w, 0, w)
                return out.multiplyScalar(w, vac).add(a);
            }
            var va = d3 * d6 - d5 * d4;
            if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) {
                vbc.subtract(c, b);
                w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
                // edge region of BC; barycentric coords (0, 1-w, w)
                return out.multiplyScalar(w, vbc).add(b); // edge region of BC
            }
            // face region
            var denom = 1.0 / (va + vb + vc);
            // u = va * denom
            v = vb * denom;
            w = vc * denom;
            return out.add(a, vac.multiplyScalar(w).add(vab.multiplyScalar(v)));
        };
        Triangle.prototype.raycast = function (ray, raycastInfo) {
            if (raycastInfo === void 0) { raycastInfo = null; }
            // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
            var edge1 = egret3d.helpVector3A;
            var edge2 = egret3d.helpVector3B;
            var diff = egret3d.helpVector3C;
            var normal = egret3d.helpVector3D;
            var rayDirection = ray.direction;
            var rayOrigin = ray.origin;
            var pA = this.a;
            var pB = this.b;
            var pC = this.c;
            edge1.subtract(pC, pA);
            edge2.subtract(pB, pA);
            normal.cross(edge1, edge2);
            // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
            // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
            //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
            //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
            //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
            var DdN = rayDirection.dot(normal);
            var sign = 1.0;
            if (DdN > 0.0) {
                if (!raycastInfo || raycastInfo.backfaceCulling)
                    return false;
            }
            else if (DdN < 0.0) {
                sign = -1.0;
                DdN = -DdN;
            }
            else {
                return false;
            }
            diff.subtract(rayOrigin, pA);
            var DdQxE2 = sign * rayDirection.dot(edge2.cross(diff, edge2));
            // b1 < 0, no intersection
            if (DdQxE2 < 0.0) {
                return false;
            }
            var DdE1xQ = sign * rayDirection.dot(edge1.cross(diff));
            // b2 < 0, no intersection
            if (DdE1xQ < 0.0) {
                return false;
            }
            // b1+b2 > 1, no intersection
            if (DdQxE2 + DdE1xQ > DdN) {
                return false;
            }
            // Line intersects triangle, check if ray does.
            var QdN = -sign * diff.dot(normal);
            // t < 0, no intersection
            if (QdN < 0.0) {
                return false;
            }
            if (raycastInfo) {
                DdN = 1.0 / DdN;
                raycastInfo.coord.x = DdQxE2 * DdN;
                raycastInfo.coord.y = DdE1xQ * DdN;
                ray.getPointAt(raycastInfo.distance = QdN * DdN, raycastInfo.position);
                if (raycastInfo.normal) {
                    raycastInfo.normal.copy(normal);
                }
            }
            return true;
        };
        Object.defineProperty(Triangle.prototype, "area", {
            /**
             * 获取该三角形的面积。
             * - 该值是实时计算的。
             */
            get: function () {
                egret3d.helpVector3A.subtract(this.c, this.a);
                egret3d.helpVector3B.subtract(this.b, this.a);
                return egret3d.helpVector3A.cross(egret3d.helpVector3B).length * 0.5;
            },
            enumerable: true,
            configurable: true
        });
        Triangle._instances = [];
        return Triangle;
    }(paper.BaseRelease));
    egret3d.Triangle = Triangle;
    __reflect(Triangle.prototype, "egret3d.Triangle", ["paper.ICCS", "paper.ISerializable", "egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var FilterMode;
    (function (FilterMode) {
        FilterMode[FilterMode["Point"] = 0] = "Point";
        FilterMode[FilterMode["Bilinear"] = 1] = "Bilinear";
        FilterMode[FilterMode["Trilinear"] = 2] = "Trilinear";
    })(FilterMode = egret3d.FilterMode || (egret3d.FilterMode = {}));
    /**
     * 基础纹理资源。
     * - 纹理资源的基类。
     */
    var BaseTexture = (function (_super) {
        __extends(BaseTexture, _super);
        function BaseTexture() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 3553 /* Texture2D */;
            _this._sourceDirty = true;
            _this._levels = 0;
            _this._gltfTexture = null;
            _this._image = null;
            _this._sampler = null;
            return _this;
        }
        BaseTexture._createConfig = function (createTextureParameters) {
            var config = this.createConfig();
            config.images = [{}];
            config.samplers = [{}];
            config.textures = [{ sampler: 0, source: 0, extensions: { paper: {} } }];
            //
            var gltfTexture = config.textures[0];
            var image = config.images[gltfTexture.source];
            var sampler = config.samplers[gltfTexture.sampler];
            var extension = gltfTexture.extensions.paper;
            //
            var _a = createTextureParameters, wrapS = _a.wrapS, wrapT = _a.wrapT, magFilter = _a.magFilter, minFilter = _a.minFilter, source = _a.source, width = _a.width, height = _a.height, premultiplyAlpha = _a.premultiplyAlpha, flipY = _a.flipY, anisotropy = _a.anisotropy, format = _a.format, type = _a.type, unpackAlignment = _a.unpackAlignment, encoding = _a.encoding, 
            //
            depth = _a.depth, layers = _a.layers, faces = _a.faces, levels = _a.levels, 
            //
            _b = _a.depthBuffer, 
            //
            depthBuffer = _b === void 0 ? true : _b, _c = _a.stencilBuffer, stencilBuffer = _c === void 0 ? false : _c;
            //
            sampler.wrapS = wrapS;
            sampler.wrapT = wrapT;
            sampler.magFilter = magFilter;
            sampler.minFilter = minFilter;
            extension.premultiplyAlpha = premultiplyAlpha;
            extension.flipY = flipY;
            extension.width = width; // TODO min size
            extension.height = height; // TODO min size
            extension.anisotropy = anisotropy;
            extension.format = format;
            extension.type = type;
            extension.unpackAlignment = unpackAlignment;
            extension.encoding = encoding;
            extension.depth = depth;
            extension.layers = layers;
            extension.faces = faces;
            extension.levels = levels;
            extension.depthBuffer = depthBuffer;
            extension.stencilBuffer = stencilBuffer;
            //
            return config;
        };
        BaseTexture.prototype._formatLevelsAndSampler = function () {
            var sampler = this._sampler;
            var levels = this._gltfTexture.extensions.paper.levels;
            if (!this.isPowerOfTwo) {
                if (levels !== undefined && levels !== 1) {
                    levels = this._gltfTexture.extensions.paper.levels = 1;
                }
                if (sampler.wrapS !== 33071 /* ClampToEdge */ || sampler.wrapT !== 33071 /* ClampToEdge */) {
                    // console.warn('Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to gltf.TextureWrap.CLAMP_TO_EDGE.');
                    sampler.wrapS = 33071 /* ClampToEdge */;
                    sampler.wrapT = 33071 /* ClampToEdge */;
                }
            }
            else {
                if (!sampler.wrapS) {
                    sampler.wrapS = 10497 /* Repeat */;
                }
                if (!sampler.wrapT) {
                    sampler.wrapT = 10497 /* Repeat */;
                }
            }
            if (!sampler.magFilter) {
                sampler.magFilter = 9728 /* Nearest */;
            }
            if (levels === undefined || levels === 1) {
                if (sampler.minFilter === 9987 /* LinearMipMapLinear */ || sampler.minFilter === 9986 /* NearestMipMapLinear */) {
                    sampler.minFilter = 9729 /* Linear */;
                }
                else if (!sampler.minFilter || sampler.minFilter === 9984 /* NearestMipmapNearest */ || sampler.minFilter === 9985 /* LinearMipmapNearest */) {
                    sampler.minFilter = 9728 /* Nearest */;
                }
            }
            else {
                if (sampler.minFilter === 9729 /* Linear */) {
                    sampler.minFilter = 9987 /* LinearMipMapLinear */;
                }
                else if (!sampler.minFilter || sampler.minFilter === 9728 /* Nearest */) {
                    sampler.minFilter = 9984 /* NearestMipmapNearest */;
                }
            }
        };
        /**
         * @internal
         */
        BaseTexture.prototype.initialize = function (name, config, buffers) {
            _super.prototype.initialize.call(this, name, config, buffers);
            var gltfTexture = this._gltfTexture = this.config.textures[0];
            this._image = this.config.images[gltfTexture.source];
            this._sampler = this.config.samplers[gltfTexture.sampler];
            //
            this._formatLevelsAndSampler();
        };
        /**
         * @internal
         */
        BaseTexture.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            this._gltfTexture = null;
            this._image = null;
            this._sampler = null;
            return true;
        };
        /**
         * @internal
         */
        BaseTexture.prototype.bindTexture = function (index) {
            return this;
        };
        /**
         *
         */
        BaseTexture.prototype.setLiner = function (value) {
            var sampler = this._sampler;
            var levels = this._gltfTexture.extensions.paper.levels;
            sampler.magFilter = value ? 9729 /* Linear */ : 9728 /* Nearest */;
            var filterMode = typeof (value) === "boolean" ? (value ? 1 /* Bilinear */ : 0 /* Point */) : value;
            if (levels === undefined || levels === 1) {
                sampler.minFilter = value ? 9729 /* Linear */ : 9728 /* Nearest */;
            }
            else {
                if (filterMode === 0 /* Point */) {
                    sampler.minFilter = 9984 /* NearestMipmapNearest */;
                }
                else if (filterMode === 1 /* Bilinear */) {
                    sampler.minFilter = 9985 /* LinearMipmapNearest */;
                }
                else if (filterMode === 2 /* Trilinear */) {
                    sampler.minFilter = 9987 /* LinearMipMapLinear */;
                }
            }
            this._formatLevelsAndSampler();
            return this;
        };
        /**
         *
         */
        BaseTexture.prototype.setRepeat = function (value) {
            var sampler = this._sampler;
            sampler.wrapS = sampler.wrapT = value ? 10497 /* Repeat */ : 33071 /* ClampToEdge */;
            this._formatLevelsAndSampler();
            return this;
        };
        /**
         *
         */
        BaseTexture.prototype.setMipmap = function (value) {
            this._gltfTexture.extensions.paper.levels = value ? 0 : 1;
            this._formatLevelsAndSampler();
            return this;
        };
        Object.defineProperty(BaseTexture.prototype, "isPowerOfTwo", {
            /**
             *
             */
            get: function () {
                return egret3d.math.isPowerOfTwo(this.width) && egret3d.math.isPowerOfTwo(this.height);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseTexture.prototype, "format", {
            /**
             *
             */
            get: function () {
                return this._gltfTexture.extensions.paper.format || 6408 /* RGBA */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseTexture.prototype, "levels", {
            /**
             *
             */
            get: function () {
                if (this._levels > 0) {
                    return this._levels;
                }
                var _a = this._gltfTexture.extensions.paper, levels = _a.levels, width = _a.width, height = _a.height;
                if (levels === 0) {
                    return this._levels = Math.log(Math.max(width, height)) * Math.LOG2E;
                }
                else if (!levels) {
                    return 1.0;
                }
                return levels;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseTexture.prototype, "width", {
            /**
             *
             */
            get: function () {
                return this._gltfTexture.extensions.paper.width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseTexture.prototype, "height", {
            /**
             *
             */
            get: function () {
                return this._gltfTexture.extensions.paper.height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseTexture.prototype, "sampler", {
            // /**
            //  * 
            //  */
            // public get memory(): uint {
            //     let k = 0;
            //     switch (this.format) {
            //         case gltf.TextureFormat.RGB:
            //         case gltf.TextureFormat.Luminance:
            //             k = 3;
            //             break;
            //         case gltf.TextureFormat.RGBA:
            //             k = 4;
            //             break;
            //     }
            //     if (this._gltfTexture.extensions.paper.mipmap) {
            //         k *= 2;
            //     }
            //     return this.width * this.height * k;
            // }
            /**
             *
             */
            get: function () {
                return this._sampler;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseTexture.prototype, "gltfTexture", {
            /**
             *
             */
            get: function () {
                return this._gltfTexture;
            },
            enumerable: true,
            configurable: true
        });
        return BaseTexture;
    }(egret3d.GLTFAsset));
    egret3d.BaseTexture = BaseTexture;
    __reflect(BaseTexture.prototype, "egret3d.BaseTexture");
    /**
     * 纹理资源。
     */
    var Texture = (function (_super) {
        __extends(Texture, _super);
        function Texture() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Texture.create = function (parametersOrName, config, buffers) {
            var name;
            var texture;
            var source; // TODO ?!
            if (typeof parametersOrName === "string") {
                name = parametersOrName;
            }
            else {
                config = this._createConfig(parametersOrName);
                name = parametersOrName.name || "";
                if (ArrayBuffer.isView(parametersOrName.source)) {
                    buffers = [parametersOrName.source];
                }
                source = parametersOrName.source;
            }
            var gltfTexture = config.textures[0];
            var image = config.images[gltfTexture.source];
            var extension = gltfTexture.extensions.paper;
            // const source = image.uri as gltf.ImageSource; // TODO ?!
            if (source) {
                if (ArrayBuffer.isView(source)) {
                    config.buffers = [];
                    config.buffers[0] = { byteLength: source.byteLength };
                    image.bufferView = 0;
                }
                else {
                    image.uri = source; // 兼容
                    extension.width = source.width;
                    extension.height = source.height;
                }
            }
            else if (image.uri) {
                var imageSource = image.uri;
                extension.width = imageSource.width;
                extension.height = imageSource.height;
            }
            // Retargeting.
            texture = new egret3d.Texture();
            texture.initialize(name, config, buffers || null);
            return texture;
        };
        /**
         *
         */
        Texture.createColorTexture = function (name, r, g, b) {
            var texture = Texture.create({
                name: name, source: new Uint8Array([r, g, b, 255, r, g, b, 255, r, g, b, 255, r, g, b, 255]), width: 2, height: 2,
                wrapS: 33071 /* ClampToEdge */, wrapT: 33071 /* ClampToEdge */,
                magFilter: 9729 /* Linear */, minFilter: 9729 /* Linear */
            });
            return texture;
        };
        /**
         * @internal
         */
        Texture.createGridTexture = function (name) {
            var width = 128;
            var height = 128;
            var source = new Uint8Array(width * height * 4);
            for (var y = 0; y < height; y++) {
                for (var x = 0; x < width; x++) {
                    var seek = (y * width + x) * 4;
                    var bool = ((x - width * 0.5) * (y - height * 0.5)) > 0;
                    source[seek] = source[seek + 1] = source[seek + 2] = bool ? 0 : 255;
                    source[seek + 3] = 255;
                }
            }
            var texture = Texture.create({
                name: name, source: source, width: width, height: height,
                wrapS: 10497 /* Repeat */, wrapT: 10497 /* Repeat */,
                magFilter: 9729 /* Linear */, minFilter: 9987 /* LinearMipMapLinear */,
                levels: 0,
                anisotropy: 4,
            });
            return texture;
        };
        /**
         *
         * @param source
         */
        Texture.prototype.uploadTexture = function (source) {
            this._sourceDirty = true;
            var config = this.config;
            var image = this._image;
            var extension = config.textures[0].extensions.paper;
            // const source = image.uri as gltf.ImageSource;
            if (source) {
                if (ArrayBuffer.isView(source)) {
                    config.buffers = [];
                    config.buffers[0] = { byteLength: source.byteLength };
                    image.bufferView = 0;
                }
                else {
                    image.uri = source; // 兼容
                    extension.width = source.width;
                    extension.height = source.height;
                }
            }
            else {
                image.uri = source;
                if (source) {
                    extension.width = source.width;
                    extension.height = source.height;
                }
            }
            return this;
        };
        return Texture;
    }(BaseTexture));
    egret3d.Texture = Texture;
    __reflect(Texture.prototype, "egret3d.Texture");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 基础渲染组件。
     */
    var BaseRenderer = (function (_super) {
        __extends(BaseRenderer, _super);
        function BaseRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 该组件是否开启视锥剔除。
             */
            _this.frustumCulled = true;
            /**
             * @internal
             */
            _this._localBoundingBoxDirty = true;
            _this._boundingSphereDirty = true;
            _this._receiveShadows = false;
            _this._castShadows = false;
            _this._boundingSphere = egret3d.Sphere.create();
            _this._localBoundingBox = egret3d.Box.create();
            _this._materials = [egret3d.DefaultMaterials.MESH_BASIC.retain()]; // TODO
            return _this;
        }
        BaseRenderer_1 = BaseRenderer;
        BaseRenderer.prototype._recalculateSphere = function () {
            var localBoundingBox = this.localBoundingBox; // Update localBoundingBox.
            var localToWorldMatrix = this.getBoundingTransform().localToWorldMatrix;
            this._boundingSphere.set(localBoundingBox.center, localBoundingBox.boundingSphereRadius);
            this._boundingSphere.center.applyMatrix(localToWorldMatrix);
            this._boundingSphere.radius *= localToWorldMatrix.maxScaleOnAxis;
        };
        BaseRenderer.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.getBoundingTransform().registerObserver(this);
        };
        BaseRenderer.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            for (var _i = 0, _a = this._materials; _i < _a.length; _i++) {
                var material = _a[_i];
                if (material) {
                    material.release();
                }
            }
            this._materials.length = 0;
        };
        /**
         * @private
         */
        BaseRenderer.prototype.onTransformChange = function () {
            this._boundingSphereDirty = true;
        };
        /**
         *
         */
        BaseRenderer.prototype.getBoundingTransform = function () {
            return this.gameObject.transform;
        };
        Object.defineProperty(BaseRenderer.prototype, "receiveShadows", {
            /**
             * 该组件是否接收投影。
             */
            get: function () {
                return this._receiveShadows;
            },
            set: function (value) {
                if (value === this._receiveShadows) {
                    return;
                }
                this._receiveShadows = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "castShadows", {
            /**
             * 该组件是否产生投影。
             */
            get: function () {
                return this._castShadows;
            },
            set: function (value) {
                if (value === this._castShadows) {
                    return;
                }
                this._castShadows = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "localBoundingBox", {
            /**
             * 该组件的本地包围盒。
             */
            get: function () {
                if (this._localBoundingBoxDirty) {
                    this.recalculateLocalBox();
                    this._localBoundingBoxDirty = false;
                }
                return this._localBoundingBox;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "boundingSphere", {
            /**
             * 基于该组件本地包围盒生成的世界包围球，用于摄像机视锥剔除。
             */
            get: function () {
                if (this._boundingSphereDirty) {
                    this._recalculateSphere();
                    this._boundingSphereDirty = false;
                }
                return this._boundingSphere;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "materials", {
            /**
             * 该组件的材质列表。
             */
            get: function () {
                return this._materials;
            },
            set: function (value) {
                var materials = this._materials;
                for (var _i = 0, materials_1 = materials; _i < materials_1.length; _i++) {
                    var material = materials_1[_i];
                    if (material) {
                        material.release();
                    }
                }
                if (value !== materials) {
                    materials.length = 0;
                    for (var _a = 0, value_1 = value; _a < value_1.length; _a++) {
                        var material = value_1[_a];
                        materials.push(material);
                    }
                }
                for (var _b = 0, materials_2 = materials; _b < materials_2.length; _b++) {
                    var material = materials_2[_b];
                    if (material) {
                        material.retain();
                    }
                }
                BaseRenderer_1.onMaterialsChanged.dispatch(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "material", {
            /**
             * 该组件材质列表中的第一个材质。
             */
            get: function () {
                var materials = this._materials;
                return materials.length > 0 ? materials[0] : null;
            },
            set: function (value) {
                var dirty = false;
                var materials = this._materials;
                var existingMaterial = null;
                if (materials.length > 0) {
                    existingMaterial = materials[0];
                    if (existingMaterial !== value) {
                        dirty = true;
                    }
                }
                else if (value) {
                    dirty = true;
                }
                if (dirty) {
                    if (existingMaterial) {
                        existingMaterial.release();
                    }
                    if (value) {
                        value.retain();
                    }
                    materials[0] = value;
                    BaseRenderer_1.onMaterialsChanged.dispatch(this);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "aabb", {
            /**
             * @deprecated
             */
            get: function () {
                return this.localBoundingBox;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 当渲染组件的材质列表改变时派发事件。
         */
        BaseRenderer.onMaterialsChanged = new signals.Signal();
        __decorate([
            paper.serializedField,
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], BaseRenderer.prototype, "frustumCulled", void 0);
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_receiveShadows", void 0);
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_castShadows", void 0);
        __decorate([
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], BaseRenderer.prototype, "receiveShadows", null);
        __decorate([
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], BaseRenderer.prototype, "castShadows", null);
        __decorate([
            paper.editor.property("MATERIAL_ARRAY" /* MATERIAL_ARRAY */),
            paper.serializedField("_materials")
        ], BaseRenderer.prototype, "materials", null);
        BaseRenderer = BaseRenderer_1 = __decorate([
            paper.abstract
        ], BaseRenderer);
        return BaseRenderer;
        var BaseRenderer_1;
    }(paper.BaseComponent));
    paper.BaseRenderer = BaseRenderer;
    __reflect(BaseRenderer.prototype, "paper.BaseRenderer", ["egret3d.IRaycast", "egret3d.ITransformObserver"]);
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 射线检测信息。
     */
    var RaycastInfo = (function (_super) {
        __extends(RaycastInfo, _super);
        function RaycastInfo() {
            var _this = _super.call(this) || this;
            /**
             *
             */
            _this.backfaceCulling = true;
            /**
             *
             */
            _this.modifyNormal = false;
            /**
             *
             */
            _this.subMeshIndex = -1;
            /**
             *
             */
            _this.triangleIndex = -1;
            /**
             * 交点到射线起始点的距离。
             * - 如果未相交则为 -1.0。
             */
            _this.distance = -1.0;
            /**
             * 相交的点。
             */
            _this.position = egret3d.Vector3.create();
            /**
             * 三角形或几何面相交的 UV 坐标。
             */
            _this.coord = egret3d.Vector2.create();
            /**
             * 相交的法线。
             * - 提供法线向量将计算法线。
             */
            _this.normal = null;
            /**
             *
             */
            _this.textureCoordA = null;
            /**
             *
             */
            _this.textureCoordB = null;
            /**
             * 相交的变换组件。（如果有的话）
             */
            _this.transform = null;
            /**
             * 相交的碰撞组件。（如果有的话）
             */
            _this.collider = null;
            /**
             * 相交的刚体组件。（如果有的话）
             */
            _this.rigidbody = null;
            return _this;
        }
        /**
         * 创建一个射线检测信息实例。
         */
        RaycastInfo.create = function () {
            if (this._instances.length > 0) {
                var instance = this._instances.pop();
                instance._released = false;
                return instance;
            }
            return new RaycastInfo();
        };
        RaycastInfo.prototype.onClear = function () {
            this.clear();
        };
        RaycastInfo.prototype.copy = function (value) {
            // Input ?
            this.subMeshIndex = value.subMeshIndex;
            this.triangleIndex = value.triangleIndex;
            this.distance = value.distance;
            this.position.copy(value.position);
            this.coord.copy(value.coord);
            if (this.normal && value.normal) {
                this.normal.copy(value.normal);
            }
            // this.textureCoordA = null;
            // this.textureCoordB = null;
            this.transform = value.transform;
            this.collider = value.collider;
            this.rigidbody = value.rigidbody;
            return this;
        };
        RaycastInfo.prototype.clear = function () {
            this.backfaceCulling = true;
            this.modifyNormal = false;
            this.subMeshIndex = -1;
            this.triangleIndex = -1;
            this.distance = -1.0;
            this.position.set(0.0, 0.0, 0.0);
            this.coord.set(0.0, 0.0);
            this.normal = null;
            this.textureCoordA = null;
            this.textureCoordB = null;
            this.transform = null;
            this.collider = null;
            this.rigidbody = null;
            return this;
        };
        RaycastInfo._instances = [];
        return RaycastInfo;
    }(paper.BaseRelease));
    egret3d.RaycastInfo = RaycastInfo;
    __reflect(RaycastInfo.prototype, "egret3d.RaycastInfo");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 基础预制体资源。
     * - 预制体资源和场景资源的基类。
     */
    var BasePrefabAsset = (function (_super) {
        __extends(BasePrefabAsset, _super);
        function BasePrefabAsset(config, name) {
            var _this = _super.call(this) || this;
            /**
             *
             */
            _this.config = null;
            _this.name = name;
            _this.config = config;
            return _this;
        }
        BasePrefabAsset.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            this.config = null;
            return true;
        };
        BasePrefabAsset.prototype.disposeAssets = function () {
            if (!this.config) {
                return;
            }
            for (var _i = 0, _a = this.config.assets; _i < _a.length; _i++) {
                var assetName = _a[_i];
                if (assetName.indexOf("builtin/") >= 0) {
                    continue;
                }
                var asset = paper.Asset.find(assetName);
                if (asset) {
                    asset.dispose();
                }
            }
        };
        return BasePrefabAsset;
    }(paper.Asset));
    paper.BasePrefabAsset = BasePrefabAsset;
    __reflect(BasePrefabAsset.prototype, "paper.BasePrefabAsset");
    /**
     * 预制体资源。
     */
    var Prefab = (function (_super) {
        __extends(Prefab, _super);
        function Prefab() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Prefab.create = function (name, xOrScene, y, z, scene) {
            var prefab = paper.Asset.find(name);
            if (prefab && prefab instanceof Prefab) {
                if (xOrScene !== undefined && xOrScene !== null) {
                    if (xOrScene instanceof paper.Scene) {
                        var gameObject = prefab.createInstance(xOrScene);
                        if (gameObject) {
                            gameObject.transform.setLocalPosition(0.0, 0.0, 0.0);
                        }
                        return gameObject;
                    }
                    else {
                        var gameObject = prefab.createInstance(scene || null);
                        if (gameObject) {
                            gameObject.transform.setLocalPosition(xOrScene, y, z);
                        }
                        return gameObject;
                    }
                }
                else {
                    var gameObject = prefab.createInstance();
                    if (gameObject) {
                        gameObject.transform.setLocalPosition(0.0, 0.0, 0.0);
                    }
                    return gameObject;
                }
            }
            else {
                console.warn("The prefab don't exists.", name);
            }
            return null;
        };
        /**
         * @deprecated
         */
        Prefab.prototype.createInstance = function (scene, keepUUID) {
            if (!this.config) {
                return null;
            }
            var isEditor = paper.Application.playerMode === 4 /* Editor */;
            var deserializer = new paper.Deserializer();
            var gameObject = deserializer.deserialize(this.config, keepUUID, isEditor, scene);
            if (gameObject && isEditor) {
                if (!gameObject.extras.prefab) {
                    gameObject.extras.prefab = this;
                }
            }
            return gameObject;
        };
        return Prefab;
    }(BasePrefabAsset));
    paper.Prefab = Prefab;
    __reflect(Prefab.prototype, "paper.Prefab");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    function _filterEmptyLine(string) {
        return string !== "";
    }
    /**
     * 全局渲染状态组件。
     */
    var RenderState = (function (_super) {
        __extends(RenderState, _super);
        function RenderState() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @internal
             */
            _this.onGammaInputChanged = new signals.Signal();
            _this.maxBoneCount = 24;
            _this.maxPrecision = "";
            _this.commonExtensions = "";
            _this.vertexExtensions = "";
            _this.fragmentExtensions = "";
            _this.commonDefines = "";
            _this.vertexDefines = "";
            _this.fragmentDefines = "";
            _this.clearColor = egret3d.Color.create();
            _this.viewport = egret3d.Rectangle.create();
            _this.defines = new egret3d.Defines();
            _this.defaultCustomShaderChunks = {
                custom_vertex: "",
                custom_begin_vertex: "",
                custom_end_vertex: "",
                custom_fragment: "",
                custom_begin_fragment: "",
                custom_end_fragment: "",
            };
            /**
             *
             */
            _this.caches = {
                useLightMap: false,
                castShadows: false,
                receiveShadows: false,
                cullingMask: 0 /* Nothing */,
                attributeCount: 0,
                boneCount: 0,
                egret2DOrderCount: 0,
                clockBuffer: new Float32Array(4),
                skyBoxTexture: null,
            };
            _this.renderTarget = null;
            _this.customShaderChunks = null;
            /**
             *
             */
            _this.render = null;
            /**
             *
             */
            _this.draw = null; //开发者一般不会手动调用,通常是后期渲染调用
            _this._logarithmicDepthBuffer = false;
            _this._gammaInput = true; //
            _this._gammaOutput = true; //
            _this._gammaFactor = 1.0;
            _this._toneMapping = 0 /* None */;
            // TODO move to caches
            _this._stateEnables = [3042 /* Blend */, 2884 /* CullFace */, 2929 /* DepthTest */];
            _this._cacheStateEnable = {};
            /**
             *
             */
            _this.toneMappingExposure = 1.0;
            /**
             *
             */
            _this.toneMappingWhitePoint = 1.0;
            return _this;
        }
        RenderState.prototype._getCommonExtensions = function () {
            var extensions = ""; // fragmentExtensions.
            if (this.standardDerivativesEnabled) {
                extensions += "#extension GL_OES_standard_derivatives : enable \n";
            }
            if (this.fragDepthEnabled) {
                extensions += "#extension GL_EXT_frag_depth : enable \n";
            }
            if (this.textureFloatEnabled) {
                extensions += "#extension GL_EXT_frag_depth : enable \n";
            }
            this.fragmentExtensions = extensions;
        };
        RenderState.prototype._getCommonDefines = function () {
            var defines = ""; // commonDefines.
            defines += "precision " + this.maxPrecision + " float; \n";
            defines += "precision " + this.maxPrecision + " int; \n";
            this.commonDefines = defines;
            defines = ""; // vertexDefines
            this.vertexDefines = defines;
            defines = ""; // fragmentDefines
            defines += egret3d.ShaderChunk.encodings_pars_fragment + " \n";
            this.fragmentDefines = defines;
        };
        RenderState.prototype._getEncodingComponents = function (encoding) {
            switch (encoding) {
                case 1 /* LinearEncoding */:
                    return ['Linear', '( value )'];
                case 2 /* sRGBEncoding */:
                    return ['sRGB', '( value )'];
                case 3 /* RGBEEncoding */:
                    return ['RGBE', '( value )'];
                case 4 /* RGBM7Encoding */:
                    return ['RGBM', '( value, 7.0 )'];
                case 5 /* RGBM16Encoding */:
                    return ['RGBM', '( value, 16.0 )'];
                case 6 /* RGBDEncoding */:
                    return ['RGBD', '( value, 256.0 )'];
                case 7 /* GammaEncoding */:
                    return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
                default:
                    throw new Error('unsupported encoding: ' + encoding);
            }
        };
        RenderState.prototype._getToneMappingFunction = function (toneMapping) {
            var toneMappingName = "";
            switch (toneMapping) {
                case 1 /* LinearToneMapping */:
                    toneMappingName = 'Linear';
                    break;
                case 2 /* ReinhardToneMapping */:
                    toneMappingName = 'Reinhard';
                    break;
                case 3 /* Uncharted2ToneMapping */:
                    toneMappingName = 'Uncharted2';
                    break;
                case 4 /* CineonToneMapping */:
                    toneMappingName = 'OptimizedCineon';
                    break;
                default:
                    throw new Error('Unsupported toneMapping: ' + toneMapping);
            }
            return "vec3 toneMapping( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); } \n";
        };
        RenderState.prototype._getTexelEncodingFunction = function (functionName, encoding) {
            var components = this._getEncodingComponents(encoding);
            return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
        };
        RenderState.prototype._getTexelDecodingFunction = function (functionName, encoding) {
            var finialEncoding = (this._gammaInput && encoding === 1 /* LinearEncoding */) ? 7 /* GammaEncoding */ : encoding;
            var components = this._getEncodingComponents(finialEncoding);
            return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
        };
        /**
         * @internal
         */
        RenderState.prototype._updateDrawDefines = function (renderer) {
            var useLightMap = false;
            var receiveShadows = false;
            var boneCount = 0;
            var defines = this.defines;
            var caches = this.caches;
            if (renderer) {
                useLightMap = renderer.constructor === egret3d.MeshRenderer && renderer.lightmapIndex >= 0;
                receiveShadows = caches.castShadows && renderer.receiveShadows;
                boneCount = renderer.constructor === egret3d.SkinnedMeshRenderer ? Math.min(this.maxBoneCount, renderer.boneCount) : 0;
            }
            if (caches.useLightMap !== useLightMap) {
                if (useLightMap) {
                    defines.addDefine("USE_LIGHTMAP" /* USE_LIGHTMAP */);
                }
                else {
                    defines.removeDefine("USE_LIGHTMAP" /* USE_LIGHTMAP */);
                }
                caches.useLightMap = useLightMap;
            }
            if (caches.boneCount !== boneCount) {
                if (boneCount > 0) {
                    defines.addDefine("USE_SKINNING" /* USE_SKINNING */);
                    if (this.textureFloatEnabled) {
                        defines.addDefine("BONE_TEXTURE" /* BONE_TEXTURE */);
                    }
                    else {
                        defines.addDefine("MAX_BONES" /* MAX_BONES */, boneCount);
                    }
                }
                else {
                    defines.removeDefine("USE_SKINNING" /* USE_SKINNING */);
                    if (this.textureFloatEnabled) {
                        defines.addDefine("BONE_TEXTURE" /* BONE_TEXTURE */);
                    }
                    else {
                        defines.removeDefine("MAX_BONES" /* MAX_BONES */);
                    }
                }
                caches.boneCount = boneCount;
            }
            if (caches.receiveShadows !== receiveShadows) {
                if (receiveShadows) {
                    defines.addDefine("USE_SHADOWMAP" /* USE_SHADOWMAP */);
                    defines.addDefine("SHADOWMAP_TYPE_PCF" /* SHADOWMAP_TYPE_PCF */);
                }
                else {
                    defines.removeDefine("USE_SHADOWMAP" /* USE_SHADOWMAP */);
                    defines.removeDefine("SHADOWMAP_TYPE_PCF" /* SHADOWMAP_TYPE_PCF */);
                }
                caches.receiveShadows = receiveShadows;
            }
        };
        /**
         * @internal
         */
        RenderState.prototype._updateTextureDefines = function (mapName, texture, defines) {
            if (defines === void 0) { defines = null; }
            defines = defines || this.defines;
            //
            var mapNameDefine = egret3d.ShaderTextureDefine[mapName]; //TODO
            if (mapNameDefine) {
                if (texture) {
                    defines.addDefine(mapNameDefine);
                    if (texture instanceof egret3d.RenderTexture) {
                        defines.addDefine("FLIP_V" /* FLIP_V */);
                    }
                    else {
                        defines.removeDefine("FLIP_V" /* FLIP_V */);
                    }
                }
                else {
                    defines.removeDefine(mapNameDefine);
                    defines.removeDefine("FLIP_V" /* FLIP_V */);
                }
            }
            //
            var decodingFunName = egret3d.TextureDecodingFunction[mapName]; // TODO
            if (decodingFunName) {
                if (texture) {
                    var decodingCode = this._getTexelDecodingFunction(decodingFunName, texture.gltfTexture.extensions.paper.encoding || 1 /* LinearEncoding */);
                    var define = defines.addDefine(decodingFunName, decodingCode, 2 /* DecodingFun */);
                    if (define) {
                        define.isCode = true;
                        define.type = 2 /* Fragment */;
                    }
                }
                else {
                    defines.removeDefine(decodingFunName, true);
                }
            }
            //
            if (mapName === "envMap" /* EnvMap */) {
                var nameA = "envMapA";
                var nameB = "envMapB";
                if (texture) {
                    var mapping = texture.gltfTexture.extensions.paper.mapping;
                    var typeDefine = "ENVMAP_TYPE_CUBE" /* ENVMAP_TYPE_CUBE */;
                    var blendDefine = "ENVMAP_BLENDING_MULTIPLY" /* ENVMAP_BLENDING_MULTIPLY */; // TODO
                    var define = void 0;
                    switch (mapping) {
                        case 1 /* Cube */:
                        default:
                            typeDefine = "ENVMAP_TYPE_CUBE" /* ENVMAP_TYPE_CUBE */;
                            break;
                        case 2 /* CubeUV */:
                            typeDefine = "ENVMAP_TYPE_CUBE_UV" /* ENVMAP_TYPE_CUBE_UV */;
                            break;
                        case 3 /* Equirectangular */:
                            typeDefine = "ENVMAP_TYPE_EQUIREC" /* ENVMAP_TYPE_EQUIREC */;
                            break;
                        case 4 /* Spherical */:
                            typeDefine = "ENVMAP_TYPE_SPHERE" /* ENVMAP_TYPE_SPHERE */;
                            break;
                    }
                    define = defines.addDefine(nameA, typeDefine);
                    if (define) {
                        define.type = 2 /* Fragment */;
                    }
                    define = defines.addDefine(nameB, blendDefine);
                    if (define) {
                        define.type = 2 /* Fragment */;
                    }
                }
                else {
                    defines.removeDefine(nameA, true);
                    defines.removeDefine(nameB, true);
                }
            }
        };
        /**
         * @internal
         */
        RenderState.prototype.getPrefixVertex = function (defines) {
            var prefixContext = [
                this.commonExtensions,
                this.vertexExtensions,
                this.commonDefines,
                this.vertexDefines,
                defines,
                egret3d.ShaderChunk.common_vert_def,
                "\n"
            ].filter(_filterEmptyLine).join("\n");
            return prefixContext;
        };
        /**
         * @internal
         */
        RenderState.prototype.getPrefixFragment = function (defines) {
            var prefixContext = [
                this.commonExtensions,
                this.fragmentExtensions,
                this.commonDefines,
                this.fragmentDefines,
                defines,
                egret3d.ShaderChunk.common_frag_def,
                "\n"
            ].filter(_filterEmptyLine).join("\n");
            return prefixContext;
        };
        RenderState.prototype.initialize = function (config) {
            _super.prototype.initialize.call(this);
            egret3d.renderState = this;
            //
            this.toneMapping = 1 /* LinearToneMapping */;
            this.gammaFactor = 2.0;
            this.gammaInput = config.gammaInput ? true : false;
            this.gammaOutput = false;
        };
        /**
         *
         */
        RenderState.prototype.updateRenderTarget = function (renderTarget) { };
        /**
         *
         */
        RenderState.prototype.updateViewport = function (viewport, renderTarget) { };
        /**
         *
         */
        RenderState.prototype.clearBuffer = function (bufferBit, clearColor) { };
        /**
         *
         */
        RenderState.prototype.copyFramebufferToTexture = function (screenPostion, target, level) {
            if (level === void 0) { level = 0; }
        };
        /**
         *
         */
        RenderState.prototype.clearState = function () {
            for (var key in this._cacheStateEnable) {
                delete this._cacheStateEnable[key];
            }
        };
        Object.defineProperty(RenderState.prototype, "logarithmicDepthBuffer", {
            /**
             *
             */
            get: function () {
                return this._logarithmicDepthBuffer;
            },
            set: function (value) {
                if (this._logarithmicDepthBuffer === value) {
                    return;
                }
                var _a = this, defines = _a.defines, fragDepthEnabled = _a.fragDepthEnabled;
                if (value) {
                    defines.addDefine("USE_LOGDEPTHBUF" /* USE_LOGDEPTHBUF */);
                    if (fragDepthEnabled) {
                        defines.addDefine("USE_LOGDEPTHBUF_EXT" /* USE_LOGDEPTHBUF_EXT */);
                    }
                    else {
                        defines.removeDefine("USE_LOGDEPTHBUF_EXT" /* USE_LOGDEPTHBUF_EXT */);
                    }
                }
                else {
                    defines.removeDefine("USE_LOGDEPTHBUF" /* USE_LOGDEPTHBUF */);
                    defines.removeDefine("USE_LOGDEPTHBUF_EXT" /* USE_LOGDEPTHBUF_EXT */);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderState.prototype, "gammaInput", {
            /**
             *
             */
            get: function () {
                return this._gammaInput;
            },
            set: function (value) {
                if (this._gammaInput === value) {
                    return;
                }
                this._gammaInput = value;
                this._updateTextureDefines("envMap" /* EnvMap */, this.caches.skyBoxTexture);
                this.onGammaInputChanged.dispatch();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderState.prototype, "gammaOutput", {
            /**
             *
             */
            get: function () {
                return this._gammaOutput;
            },
            set: function (value) {
                if (this._gammaOutput === value) {
                    return;
                }
                var define = this.defines.addDefine("Gamma", this._getTexelEncodingFunction("linearToOutputTexel", value ? 7 /* GammaEncoding */ : 1 /* LinearEncoding */), 3 /* EncodingFun */);
                if (define) {
                    define.isCode = true;
                    define.type = 2 /* Fragment */;
                }
                this._gammaOutput = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderState.prototype, "gammaFactor", {
            /**
             *
             */
            get: function () {
                return this._gammaFactor;
            },
            set: function (value) {
                if (value !== value || value < 1.0) {
                    value = 1.0;
                }
                if (this._gammaFactor === value) {
                    return;
                }
                var define = this.defines.addDefine("GAMMA_FACTOR" /* GAMMA_FACTOR */, value, 1 /* GammaFactor */);
                if (define) {
                    define.type = 2 /* Fragment */;
                }
                this._gammaFactor = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderState.prototype, "toneMapping", {
            /**
             *
             */
            get: function () {
                return this._toneMapping;
            },
            set: function (value) {
                if (this._toneMapping === value) {
                    return;
                }
                var defineName = "ToneMapping";
                var defines = this.defines;
                if (value === 0 /* None */) {
                    defines.removeDefine("TONE_MAPPING" /* TONE_MAPPING */);
                    defines.removeDefine(egret3d.ShaderChunk.tonemapping_pars_fragment);
                    defines.removeDefine(defineName);
                }
                else {
                    var define = defines.addDefine("TONE_MAPPING" /* TONE_MAPPING */);
                    if (define) {
                        define.type = 2 /* Fragment */;
                    }
                    define = defines.addDefine(egret3d.ShaderChunk.tonemapping_pars_fragment);
                    if (define) {
                        define.isCode = true;
                        define.type = 2 /* Fragment */;
                    }
                    define = defines.addDefine(defineName, this._getToneMappingFunction(value));
                    if (define) {
                        define.isCode = true;
                        define.type = 2 /* Fragment */;
                    }
                }
                this._toneMapping = value;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], RenderState.prototype, "logarithmicDepthBuffer", null);
        __decorate([
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], RenderState.prototype, "gammaInput", null);
        __decorate([
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], RenderState.prototype, "gammaOutput", null);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { step: 0.1 })
        ], RenderState.prototype, "gammaFactor", null);
        __decorate([
            paper.editor.property("LIST" /* LIST */, { listItems: paper.editor.getItemsFromEnum(egret3d.ToneMapping) }) // TODO
        ], RenderState.prototype, "toneMapping", null);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0, maximum: 10.0 })
        ], RenderState.prototype, "toneMappingExposure", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0, maximum: 10.0 })
        ], RenderState.prototype, "toneMappingWhitePoint", void 0);
        RenderState = __decorate([
            paper.singleton
        ], RenderState);
        return RenderState;
    }(paper.BaseComponent));
    egret3d.RenderState = RenderState;
    __reflect(RenderState.prototype, "egret3d.RenderState");
    /**
     * 全局渲染状态组件实例。
     */
    egret3d.renderState = null;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Vector4 = (function (_super) {
        __extends(Vector4, _super);
        /**
         * 请使用 `egret3d.Vector4.create(); egret3d.Quaternion.create()` 创建实例。
         * @see egret3d.Quaternion.create()
         * @see egret3d.Vector4.create()
         * @deprecated
         */
        function Vector4(x, y, z, w) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (w === void 0) { w = 1.0; }
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            _this.z = z;
            _this.w = w;
            return _this;
        }
        /**
         *
         */
        Vector4.create = function (x, y, z, w) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (w === void 0) { w = 1.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(x, y, z, w);
                instance._released = false;
                return instance;
            }
            return new Vector4().set(x, y, z, w);
        };
        Vector4.prototype.serialize = function () {
            return [this.x, this.y, this.z, this.w];
        };
        Vector4.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Vector4.prototype.copy = function (value) {
            return this.set(value.x, value.y, value.z, value.w);
        };
        Vector4.prototype.clone = function () {
            return Vector4.create(this.x, this.y, this.z, this.w);
        };
        Vector4.prototype.set = function (x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        };
        Vector4.prototype.clear = function () {
            this.x = 0.0;
            this.y = 0.0;
            this.z = 0.0;
            this.w = 1.0;
            return this;
        };
        Vector4.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this.x = value[offset];
            this.y = value[offset + 1];
            this.z = value[offset + 2];
            this.w = value[offset + 3];
            return this;
        };
        /**
         * 判断该向量是否和一个向量相等。
         * @param value 一个向量。
         * @param threshold 阈值。
         */
        Vector4.prototype.equal = function (value, threshold) {
            if (threshold === void 0) { threshold = 0.000001; }
            if (Math.abs(this.x - value.x) <= threshold &&
                Math.abs(this.y - value.y) <= threshold &&
                Math.abs(this.z - value.z) <= threshold &&
                Math.abs(this.w - value.w) <= threshold) {
                return true;
            }
            return false;
        };
        Vector4.prototype.normalize = function (input) {
            if (!input) {
                input = this;
            }
            var x = input.x, y = input.y, z = input.z, w = input.w;
            var l = Math.sqrt(x * x + y * y + z * z + w * w);
            if (l > 2.220446049250313e-16 /* EPSILON */) {
                l = 1.0 / l;
                this.x = x * l;
                this.y = y * l;
                this.z = z * l;
                this.w = w * l;
            }
            else {
                this.clear();
            }
            return this;
        };
        Vector4.prototype.inverse = function (input) {
            if (!input) {
                input = this;
            }
            this.x = input.x * -1;
            this.y = input.y * -1;
            this.z = input.z * -1;
            this.w = input.w;
            return this;
        };
        /**
         * 向量与标量相乘运算。
         * - `v.multiplyScalar(scalar)` 将该向量与标量相乘，相当于 v *= scalar。
         * - `v.multiplyScalar(scalar, input)` 将输入向量与标量相乘的结果写入该向量，相当于 v = input * scalar。
         * @param scalar 标量。
         * @param input 输入向量。
         */
        Vector4.prototype.multiplyScalar = function (scalar, input) {
            if (!input) {
                input = this;
            }
            this.x = scalar * input.x;
            this.y = scalar * input.y;
            this.z = scalar * input.z;
            this.w = scalar * input.w;
            return this;
        };
        /**
         * 将该向量与一个向量相点乘。
         * - v · vector
         * @param vector 一个向量。
         */
        Vector4.prototype.dot = function (vector) {
            return this.x * vector.x + this.y * vector.y + this.z * vector.z + this.w * vector.w;
        };
        Vector4.prototype.lerp = function (p1, p2, p3) {
            if (typeof p1 === "number") {
                if (!p3) {
                    p3 = p1;
                    p1 = this;
                }
                else {
                    var temp = p1;
                    p1 = p2;
                    p2 = p3;
                    p3 = temp;
                }
            }
            else if (typeof p2 === "number") {
                p3 = p2;
                p2 = p1;
                p1 = this;
            }
            this.x = p1.x + (p2.x - p1.x) * p3;
            this.y = p1.y + (p2.y - p1.y) * p3;
            this.z = p1.z + (p2.z - p1.z) * p3;
            this.w = p1.w + (p2.w - p1.w) * p3;
            return this;
        };
        /**
         * 将该向量转换为数组。
         * @param array 数组。
         * @param offset 数组偏移。
         */
        Vector4.prototype.toArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            if (!array) {
                array = [];
            }
            array[0 + offset] = this.x;
            array[1 + offset] = this.y;
            array[2 + offset] = this.z;
            array[3 + offset] = this.w;
            return array;
        };
        Object.defineProperty(Vector4.prototype, "length", {
            /**
             * 该向量的长度。
             * - 该值是实时计算的。
             */
            get: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector4.prototype, "squaredLength", {
            /**
             * 该向量的长度的平方。
             * - 该值是实时计算的。
             */
            get: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            },
            enumerable: true,
            configurable: true
        });
        Vector4._instances = [];
        return Vector4;
    }(paper.BaseRelease));
    egret3d.Vector4 = Vector4;
    __reflect(Vector4.prototype, "egret3d.Vector4", ["egret3d.IVector4", "egret3d.IVector3", "egret3d.IVector2", "paper.ICCS", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 4x4 矩阵。
     */
    var Matrix4 = (function (_super) {
        __extends(Matrix4, _super);
        /**
         * 请使用 `egret3d.Matrix4.create()` 创建实例。
         * @see egret3d.Matrix4.create()
         */
        function Matrix4() {
            var _this = _super.call(this) || this;
            /**
             * 该矩阵的数据。
             */
            _this.rawData = null;
            return _this;
        }
        /**
         * 创建一个矩阵。
         * @param arrayBuffer
         * @param byteOffset
         */
        Matrix4.create = function (arrayBuffer, byteOffset) {
            if (arrayBuffer === void 0) { arrayBuffer = null; }
            if (byteOffset === void 0) { byteOffset = 0; }
            var instance;
            if (this._instances.length > 0) {
                instance = this._instances.pop();
                instance._released = false;
                if (arrayBuffer === null) {
                    instance.identity();
                }
            }
            else {
                instance = new Matrix4();
                if (arrayBuffer === null) {
                    instance.rawData = new Float32Array(16);
                    instance.identity();
                }
            }
            if (arrayBuffer !== null) {
                instance.fromBuffer(arrayBuffer, byteOffset);
            }
            return instance;
        };
        Matrix4.prototype.serialize = function () {
            return this.rawData;
        };
        Matrix4.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Matrix4.prototype.copy = function (value) {
            return this.fromArray(value.rawData);
        };
        Matrix4.prototype.clone = function () {
            return Matrix4.create(this.rawData);
        };
        Matrix4.prototype.set = function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
            var rawData = this.rawData;
            rawData[0] = n11;
            rawData[4] = n12;
            rawData[8] = n13;
            rawData[12] = n14;
            rawData[1] = n21;
            rawData[5] = n22;
            rawData[9] = n23;
            rawData[13] = n24;
            rawData[2] = n31;
            rawData[6] = n32;
            rawData[10] = n33;
            rawData[14] = n34;
            rawData[3] = n41;
            rawData[7] = n42;
            rawData[11] = n43;
            rawData[15] = n44;
            return this;
        };
        /**
         * 将该矩阵转换为恒等矩阵。
         */
        Matrix4.prototype.identity = function () {
            var rawData = this.rawData;
            rawData[0] = 1.0;
            rawData[1] = rawData[2] = rawData[3] = 0.0;
            rawData[4] = rawData[6] = rawData[7] = 0.0;
            rawData[5] = 1.0;
            rawData[8] = rawData[9] = rawData[11] = 0.0;
            rawData[10] = 1.0;
            rawData[12] = rawData[13] = rawData[14] = 0.0;
            rawData[15] = 1.0;
            return this;
        };
        /**
         * 通过类数组中的数值设置该矩阵。
         * @param array 类数组。
         * @param offset 索引偏移。
         * - 默认 `0`。
         */
        Matrix4.prototype.fromArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            var rawData = this.rawData;
            if (offset > 0) {
                for (var i = 0; i < 16; ++i) {
                    rawData[i] = array[i + offset];
                }
            }
            else {
                for (var i = 0; i < 16; ++i) {
                    rawData[i] = array[i];
                }
            }
            return this;
        };
        /**
         *
         */
        Matrix4.prototype.fromBuffer = function (buffer, byteOffset) {
            if (byteOffset === void 0) { byteOffset = 0; }
            this.rawData = new Float32Array(buffer, byteOffset, 16);
            return this;
        };
        /**
         * 通过平移向量设置该矩阵。
         * @param translate 平移向量。
         * @param rotationAndScaleStays 是否保留该矩阵的旋转和数据。
         * - 默认 `false`。
         */
        Matrix4.prototype.fromTranslate = function (translate, rotationAndScaleStays) {
            if (rotationAndScaleStays === void 0) { rotationAndScaleStays = false; }
            if (!rotationAndScaleStays) {
                this.identity();
            }
            var rawData = this.rawData;
            rawData[12] = translate.x;
            rawData[13] = translate.y;
            rawData[14] = translate.z;
            return this;
        };
        /**
         * 通过四元数旋转设置该矩阵。
         * @param rotation 四元数旋转。
         * @param translateStays 是否保留该矩阵的平移数据。
         * - 默认 `false`。
         */
        Matrix4.prototype.fromRotation = function (rotation, translateStays) {
            if (translateStays === void 0) { translateStays = false; }
            return this.compose(translateStays ? _helpVector3A.fromArray(this.rawData, 12) : egret3d.Vector3.ZERO, rotation, egret3d.Vector3.ONE);
        };
        /**
         * 通过欧拉旋转设置该矩阵。
         * @param euler 欧拉旋转。
         * @param order 欧拉旋转顺序。
         * - 默认 `egret3d.EulerOrder.YXZ`。
         * @param translateStays 是否保留该矩阵的平移数据。
         * - 默认 `false`。
         */
        Matrix4.prototype.fromEuler = function (euler, order, translateStays) {
            // http://www.mathworks.com/matlabcentral/fileexchange/
            // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
            //	content/SpinCalc.m
            if (order === void 0) { order = 3 /* YXZ */; }
            if (translateStays === void 0) { translateStays = false; }
            var cos = Math.cos;
            var sin = Math.sin;
            var x = euler.x, y = euler.y, z = euler.z;
            var a = cos(x), b = sin(x);
            var c = cos(y), d = sin(y);
            var e = cos(z), f = sin(z);
            var rawData = this.rawData;
            switch (order) {
                case 1 /* XYZ */: {
                    var ae = a * e, af = a * f, be = b * e, bf = b * f;
                    rawData[0] = c * e;
                    rawData[4] = -c * f;
                    rawData[8] = d;
                    rawData[1] = af + be * d;
                    rawData[5] = ae - bf * d;
                    rawData[9] = -b * c;
                    rawData[2] = bf - ae * d;
                    rawData[6] = be + af * d;
                    rawData[10] = a * c;
                    break;
                }
                case 2 /* XZY */: {
                    var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                    rawData[0] = c * e;
                    rawData[4] = -f;
                    rawData[8] = d * e;
                    rawData[1] = ac * f + bd;
                    rawData[5] = a * e;
                    rawData[9] = ad * f - bc;
                    rawData[2] = bc * f - ad;
                    rawData[6] = b * e;
                    rawData[10] = bd * f + ac;
                    break;
                }
                case 3 /* YXZ */: {
                    var ce = c * e, cf = c * f, de = d * e, df = d * f;
                    rawData[0] = ce + df * b;
                    rawData[4] = de * b - cf;
                    rawData[8] = a * d;
                    rawData[1] = a * f;
                    rawData[5] = a * e;
                    rawData[9] = -b;
                    rawData[2] = cf * b - de;
                    rawData[6] = df + ce * b;
                    rawData[10] = a * c;
                    break;
                }
                case 4 /* YZX */: {
                    var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                    rawData[0] = c * e;
                    rawData[4] = bd - ac * f;
                    rawData[8] = bc * f + ad;
                    rawData[1] = f;
                    rawData[5] = a * e;
                    rawData[9] = -b * e;
                    rawData[2] = -d * e;
                    rawData[6] = ad * f + bc;
                    rawData[10] = ac - bd * f;
                    break;
                }
                case 5 /* ZXY */: {
                    var ce = c * e, cf = c * f, de = d * e, df = d * f;
                    rawData[0] = ce - df * b;
                    rawData[4] = -a * f;
                    rawData[8] = de + cf * b;
                    rawData[1] = cf + de * b;
                    rawData[5] = a * e;
                    rawData[9] = df - ce * b;
                    rawData[2] = -a * d;
                    rawData[6] = b;
                    rawData[10] = a * c;
                    break;
                }
                case 6 /* ZYX */: {
                    var ae = a * e, af = a * f, be = b * e, bf = b * f;
                    rawData[0] = c * e;
                    rawData[4] = be * d - af;
                    rawData[8] = ae * d + bf;
                    rawData[1] = c * f;
                    rawData[5] = bf * d + ae;
                    rawData[9] = af * d - be;
                    rawData[2] = -d;
                    rawData[6] = b * c;
                    rawData[10] = a * c;
                    break;
                }
            }
            // bottom row
            rawData[3] = rawData[7] = rawData[11] = 0.0;
            if (!translateStays) {
                // last column
                rawData[12] = rawData[13] = rawData[14] = 0.0;
                rawData[15] = 1.0;
            }
            return this;
        };
        /**
         * 通过缩放向量设置该矩阵。
         * @param scale 缩放向量。
         * @param translateStays 是否保留该矩阵的平移数据。
         * - 默认 `false`。
         */
        Matrix4.prototype.fromScale = function (scale, translateStays) {
            if (translateStays === void 0) { translateStays = false; }
            var helpVector3 = _helpVector3A;
            if (translateStays) {
                helpVector3.fromArray(this.rawData, 12);
            }
            this.identity();
            var rawData = this.rawData;
            rawData[0] = scale.x;
            rawData[5] = scale.y;
            rawData[10] = scale.z;
            if (translateStays) {
                rawData[12] = helpVector3.x;
                rawData[13] = helpVector3.y;
                rawData[14] = helpVector3.z;
            }
            return this;
        };
        /**
         * 通过绕 X 轴的旋转角度设置该矩阵。
         * @param angle 旋转角。
         * - 弧度制。
         */
        Matrix4.prototype.fromRotationX = function (angle) {
            var c = Math.cos(angle), s = Math.sin(angle);
            return this.set(1.0, 0.0, 0.0, 0.0, 0.0, c, -s, 0.0, 0.0, s, c, 0.0, 0.0, 0.0, 0.0, 1.0);
        };
        /**
         * 通过绕 Y 轴的旋转角度设置该矩阵。
         * @param angle 旋转角。
         * - 弧度制。
         */
        Matrix4.prototype.fromRotationY = function (angle) {
            var c = Math.cos(angle), s = Math.sin(angle);
            return this.set(c, 0.0, s, 0.0, 0.0, 1.0, 0.0, 0.0, -s, 0.0, c, 0.0, 0.0, 0.0, 0.0, 1.0);
        };
        /**
         * 通过绕 Z 轴的旋转角度设置该矩阵。
         * @param angle 旋转角。
         * - 弧度制。
         */
        Matrix4.prototype.fromRotationZ = function (angle) {
            var c = Math.cos(angle), s = Math.sin(angle);
            return this.set(c, -s, 0.0, 0.0, s, c, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
        };
        /**
         * 通过旋转轴设置该矩阵。
         * - 假设旋转轴已被归一化。
         * @param axis 旋转轴。
         * @param angle 旋转角。
         * - 弧度制。
         */
        Matrix4.prototype.fromAxis = function (axis, angle) {
            // Based on http://www.gamedev.net/reference/articles/article1199.asp
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var t = 1.0 - c;
            var x = axis.x, y = axis.y, z = axis.z;
            var tx = t * x, ty = t * y;
            return this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0.0, tx * y + s * z, ty * y + c, ty * z - s * x, 0.0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0.0, 0.0, 0.0, 0.0, 1.0);
        };
        Matrix4.prototype.perspectiveProjectMatrix = function (left, right, top, bottom, near, far) {
            var iDeltaX = 1.0 / (right - left);
            var iDeltaY = 1.0 / (top - bottom);
            var iDeltaZ = 1.0 / (near - far);
            var doubleNear = 2.0 * near;
            var rawData = this.rawData;
            rawData[0] = doubleNear * iDeltaX;
            rawData[1] = rawData[2] = rawData[3] = 0.0;
            rawData[4] = rawData[6] = rawData[7] = 0.0;
            rawData[5] = doubleNear * iDeltaY;
            rawData[8] = (right + left) * iDeltaX;
            rawData[9] = (top + bottom) * iDeltaY;
            rawData[10] = -(far + near) * iDeltaZ;
            rawData[11] = 1.0;
            rawData[12] = rawData[13] = rawData[15] = 0.0;
            rawData[14] = doubleNear * far * iDeltaZ;
            return this;
        };
        Matrix4.prototype.orthographicProjectMatrix = function (left, right, top, bottom, near, far) {
            var w = 1.0 / (right - left);
            var h = 1.0 / (top - bottom);
            var p = 1.0 / (near - far);
            var rawData = this.rawData;
            rawData[0] = 2.0 * w;
            rawData[1] = rawData[2] = rawData[3] = 0.0;
            rawData[4] = rawData[6] = rawData[7] = 0.0;
            rawData[5] = 2.0 * h;
            rawData[8] = rawData[9] = rawData[11] = 0.0;
            rawData[10] = -2.0 * p;
            rawData[12] = -(right + left) * w;
            rawData[13] = -(top + bottom) * h;
            rawData[14] = (far + near) * p;
            rawData[15] = 1.0;
            return this;
        };
        /**
         * 根据投影参数设置该矩阵。
         * @param offsetX 投影近平面水平偏移。
         * @param offsetY 投影远平面垂直偏移。
         * @param near 投影近平面。
         * @param far 投影远平面。
         * @param fov 投影视角。
         * - 透视投影时生效。
         * @param size 投影尺寸。
         * - 正交投影时生效。
         * @param opvalue 透视投影和正交投影的插值系数。
         * - `0.0` ~ `1.0`
         * - `0.0` 正交投影。
         * - `1.0` 透视投影。
         * @param asp 投影宽高比。
         * @param matchFactor 宽高适配的插值系数。
         * - `0.0` ~ `1.0`
         * - `0.0` 以宽适配。
         * - `1.0` 以高适配。
         */
        Matrix4.prototype.fromProjection = function (near, far, fov, size, opvalue, asp, matchFactor, viewport) {
            if (viewport === void 0) { viewport = null; }
            var orthographicMatrix = _helpMatrix;
            matchFactor = 1.0 - matchFactor;
            var offsetX = (viewport !== null ? viewport.x : 0.0) - 0.5;
            var offsetY = (viewport !== null ? viewport.y : 0.0) + 0.5;
            var scaleX = viewport !== null ? viewport.w : 1.0;
            var scaleY = viewport !== null ? viewport.h : 1.0;
            if (opvalue > 0.0) {
                var wh = 2.0 * near * Math.tan(fov * 0.5);
                var heightX = wh;
                var widthX = asp * heightX;
                var leftX = offsetX * widthX;
                var topX = offsetY * heightX;
                var widthY = wh;
                var heightY = widthY / asp;
                var leftY = offsetX * widthY;
                var topY = offsetY * heightY;
                var left = leftX + (leftY - leftX) * matchFactor;
                var top_1 = topX + (topY - topX) * matchFactor;
                var width = (widthX + (widthY - widthX) * matchFactor) * scaleX;
                var height = (heightX + (heightY - heightX) * matchFactor) * scaleY;
                this.perspectiveProjectMatrix(left, left + width, top_1, top_1 - height, near, far);
            }
            if (opvalue < 1.0) {
                var widthX = size * asp;
                var heightX = size;
                var leftX = offsetX * widthX;
                var topX = offsetY * heightX;
                var widthY = size;
                var heightY = size / asp;
                var leftY = offsetX * widthY;
                var topY = offsetY * heightY;
                var left = leftX + (leftY - leftX) * matchFactor;
                var top_2 = topX + (topY - topX) * matchFactor;
                var width = (widthX + (widthY - widthX) * matchFactor) * scaleX;
                var height = (heightX + (heightY - heightX) * matchFactor) * scaleY;
                orthographicMatrix.orthographicProjectMatrix(left, left + width, top_2, top_2 - height, near, far);
            }
            if (opvalue === 0.0) {
                this.copy(orthographicMatrix);
            }
            else if (opvalue === 1.0) {
                // this;
            }
            else {
                this.lerp(orthographicMatrix, this, Math.pow(opvalue, 8));
            }
            return this;
        };
        /**
         * 通过 X、Y、Z 轴设置该矩阵。
         * @param axisX X 轴。
         * @param axisY Y 轴。
         * @param axisZ Z 轴。
         */
        Matrix4.prototype.fromAxises = function (axisX, axisY, axisZ) {
            return this.set(axisX.x, axisY.x, axisZ.x, 0.0, axisX.y, axisY.y, axisZ.y, 0.0, axisX.z, axisY.z, axisZ.z, 0.0, 0.0, 0.0, 0.0, 1.0);
        };
        /**
         * 通过平移向量、四元数旋转、缩放向量设置该矩阵。
         * @param translation 平移向量。
         * @param rotation 四元数旋转。
         * @param scale 缩放向量。
         */
        Matrix4.prototype.compose = function (translation, rotation, scale) {
            var rX = rotation.x, rY = rotation.y, rZ = rotation.z, rW = rotation.w;
            var sX = scale.x, sY = scale.y, sZ = scale.z;
            var x2 = rX + rX, y2 = rY + rY, z2 = rZ + rZ;
            var xx = rX * x2, xy = rX * y2, xz = rX * z2;
            var yy = rY * y2, yz = rY * z2, zz = rZ * z2;
            var wx = rW * x2, wy = rW * y2, wz = rW * z2;
            var rawData = this.rawData;
            rawData[0] = (1.0 - (yy + zz)) * sX;
            rawData[1] = (xy + wz) * sX;
            rawData[2] = (xz - wy) * sX;
            rawData[4] = (xy - wz) * sY;
            rawData[5] = (1.0 - (xx + zz)) * sY;
            rawData[6] = (yz + wx) * sY;
            rawData[8] = (xz + wy) * sZ;
            rawData[9] = (yz - wx) * sZ;
            rawData[10] = (1.0 - (xx + yy)) * sZ;
            rawData[12] = translation.x;
            rawData[13] = translation.y;
            rawData[14] = translation.z;
            rawData[3] = rawData[7] = rawData[11] = 0.0, rawData[15] = 1.0;
            return this;
        };
        /**
         * 将该矩阵分解为平移向量、四元数旋转、缩放向量。
         * @param translation 平移向量。
         * @param rotation 四元数旋转。
         * @param scale 缩放向量。
         */
        Matrix4.prototype.decompose = function (translation, rotation, scale) {
            if (translation === void 0) { translation = null; }
            if (rotation === void 0) { rotation = null; }
            if (scale === void 0) { scale = null; }
            var rawData = this.rawData;
            if (translation !== null) {
                translation.x = rawData[12];
                translation.y = rawData[13];
                translation.z = rawData[14];
            }
            if (rotation !== null || scale !== null) {
                var helpVector3 = _helpVector3A;
                var sx = helpVector3.set(rawData[0], rawData[1], rawData[2]).length;
                var sy = helpVector3.set(rawData[4], rawData[5], rawData[6]).length;
                var sz = helpVector3.set(rawData[8], rawData[9], rawData[10]).length;
                // if determine is negative, we need to invert one scale
                if (this.determinant < 0.0)
                    sx = -sx;
                if (rotation !== null) {
                    // scale the rotation part
                    var helpMatrix = _helpMatrix;
                    var helpRawData = helpMatrix.rawData;
                    var invSX = 1.0 / sx;
                    var invSY = 1.0 / sy;
                    var invSZ = 1.0 / sz;
                    helpMatrix.copy(this);
                    helpRawData[0] *= invSX;
                    helpRawData[1] *= invSX;
                    helpRawData[2] *= invSX;
                    helpRawData[4] *= invSY;
                    helpRawData[5] *= invSY;
                    helpRawData[6] *= invSY;
                    helpRawData[8] *= invSZ;
                    helpRawData[9] *= invSZ;
                    helpRawData[10] *= invSZ;
                    rotation.fromMatrix(helpMatrix);
                }
                if (scale !== null) {
                    scale.x = sx;
                    scale.y = sy;
                    scale.z = sz;
                }
            }
            return this;
        };
        Matrix4.prototype.extractRotation = function (input) {
            if (input === void 0) { input = null; }
            if (input === null) {
                input = this;
            }
            var rawData = this.rawData;
            var inputRawData = input.rawData;
            var helpVector3 = _helpVector3A;
            var scaleX = 1.0 / helpVector3.fromMatrixColumn(input, 0).length;
            var scaleY = 1.0 / helpVector3.fromMatrixColumn(input, 1).length;
            var scaleZ = 1.0 / helpVector3.fromMatrixColumn(input, 2).length;
            rawData[0] = inputRawData[0] * scaleX;
            rawData[1] = inputRawData[1] * scaleX;
            rawData[2] = inputRawData[2] * scaleX;
            rawData[3] = 0.0;
            rawData[4] = inputRawData[4] * scaleY;
            rawData[5] = inputRawData[5] * scaleY;
            rawData[6] = inputRawData[6] * scaleY;
            rawData[7] = 0.0;
            rawData[8] = inputRawData[8] * scaleZ;
            rawData[9] = inputRawData[9] * scaleZ;
            rawData[10] = inputRawData[10] * scaleZ;
            rawData[11] = 0.0;
            rawData[12] = 0.0;
            rawData[13] = 0.0;
            rawData[14] = 0.0;
            rawData[15] = 1.0;
            return this;
        };
        Matrix4.prototype.transpose = function (input) {
            if (input === void 0) { input = null; }
            if (input === null) {
                input = this;
            }
            var rawData = this.rawData;
            var inputRawData = input.rawData;
            var temp = 0.0;
            temp = inputRawData[1];
            rawData[1] = inputRawData[4];
            rawData[4] = temp;
            temp = inputRawData[2];
            rawData[2] = inputRawData[8];
            rawData[8] = temp;
            temp = inputRawData[6];
            rawData[6] = inputRawData[9];
            rawData[9] = temp;
            temp = inputRawData[3];
            rawData[3] = inputRawData[12];
            rawData[12] = temp;
            temp = inputRawData[7];
            rawData[7] = inputRawData[13];
            rawData[13] = temp;
            temp = inputRawData[11];
            rawData[11] = inputRawData[14];
            rawData[14] = temp;
            return this;
        };
        Matrix4.prototype.inverse = function (input) {
            if (input === void 0) { input = null; }
            if (input === null) {
                input = this;
            }
            var rawData = this.rawData;
            var valueRawData = input.rawData;
            var n11 = valueRawData[0], n12 = valueRawData[4], n13 = valueRawData[8], n14 = valueRawData[12];
            var n21 = valueRawData[1], n22 = valueRawData[5], n23 = valueRawData[9], n24 = valueRawData[13];
            var n31 = valueRawData[2], n32 = valueRawData[6], n33 = valueRawData[10], n34 = valueRawData[14];
            var n41 = valueRawData[3], n42 = valueRawData[7], n43 = valueRawData[11], n44 = valueRawData[15];
            var n2332 = n23 * n32, n2432 = n24 * n32, n2233 = n22 * n33, n2433 = n24 * n33, n2234 = n22 * n34, n2334 = n23 * n34;
            var n2133 = n21 * n33, n2134 = n21 * n34, n2431 = n24 * n31, n2331 = n23 * n31, n2132 = n21 * n32, n2231 = n22 * n31;
            var t11 = n2334 * n42 - n2433 * n42 + n2432 * n43 - n2234 * n43 - n2332 * n44 + n2233 * n44;
            var t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
            var t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
            var t14 = n14 * n2332 - n13 * n2432 - n14 * n2233 + n12 * n2433 + n13 * n2234 - n12 * n2334;
            var determinant = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
            if (determinant === 0.0) {
                console.warn("Cannot invert matrix, determinant is 0.");
                return this.identity();
            }
            var detInv = 1.0 / determinant;
            rawData[0] = t11 * detInv;
            rawData[1] = (n2433 * n41 - n2334 * n41 - n2431 * n43 + n2134 * n43 + n2331 * n44 - n2133 * n44) * detInv;
            rawData[2] = (n2234 * n41 - n2432 * n41 + n2431 * n42 - n2134 * n42 - n2231 * n44 + n2132 * n44) * detInv;
            rawData[3] = (n2332 * n41 - n2233 * n41 - n2331 * n42 + n2133 * n42 + n2231 * n43 - n2132 * n43) * detInv;
            rawData[4] = t12 * detInv;
            rawData[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
            rawData[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
            rawData[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
            rawData[8] = t13 * detInv;
            rawData[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
            rawData[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
            rawData[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
            rawData[12] = t14 * detInv;
            rawData[13] = (n13 * n2431 - n14 * n2331 + n14 * n2133 - n11 * n2433 - n13 * n2134 + n11 * n2334) * detInv;
            rawData[14] = (n14 * n2231 - n12 * n2431 - n14 * n2132 + n11 * n2432 + n12 * n2134 - n11 * n2234) * detInv;
            rawData[15] = (n12 * n2331 - n13 * n2231 + n13 * n2132 - n11 * n2332 - n12 * n2133 + n11 * n2233) * detInv;
            return this;
        };
        Matrix4.prototype.multiplyScalar = function (scalar, input) {
            if (input === void 0) { input = null; }
            if (input === null) {
                input = this;
            }
            var rawData = this.rawData;
            var inputRawData = input.rawData;
            rawData[0] = inputRawData[0] * scalar;
            rawData[1] = inputRawData[1] * scalar;
            rawData[2] = inputRawData[2] * scalar;
            rawData[3] = inputRawData[3] * scalar;
            rawData[4] = inputRawData[4] * scalar;
            rawData[5] = inputRawData[5] * scalar;
            rawData[6] = inputRawData[6] * scalar;
            rawData[7] = inputRawData[7] * scalar;
            rawData[8] = inputRawData[8] * scalar;
            rawData[9] = inputRawData[9] * scalar;
            rawData[10] = inputRawData[10] * scalar;
            rawData[11] = inputRawData[11] * scalar;
            rawData[12] = inputRawData[12] * scalar;
            rawData[13] = inputRawData[13] * scalar;
            rawData[14] = inputRawData[14] * scalar;
            rawData[15] = inputRawData[15] * scalar;
            return this;
        };
        Matrix4.prototype.multiply = function (matrixA, matrixB) {
            if (matrixB === void 0) { matrixB = null; }
            if (matrixB === null) {
                matrixB = matrixA;
                matrixA = this;
            }
            var rawData = this.rawData;
            var rawDataA = matrixA.rawData;
            var rawDataB = matrixB.rawData;
            var a11 = rawDataA[0], a12 = rawDataA[4], a13 = rawDataA[8], a14 = rawDataA[12];
            var a21 = rawDataA[1], a22 = rawDataA[5], a23 = rawDataA[9], a24 = rawDataA[13];
            var a31 = rawDataA[2], a32 = rawDataA[6], a33 = rawDataA[10], a34 = rawDataA[14];
            var a41 = rawDataA[3], a42 = rawDataA[7], a43 = rawDataA[11], a44 = rawDataA[15];
            var b11 = rawDataB[0], b12 = rawDataB[4], b13 = rawDataB[8], b14 = rawDataB[12];
            var b21 = rawDataB[1], b22 = rawDataB[5], b23 = rawDataB[9], b24 = rawDataB[13];
            var b31 = rawDataB[2], b32 = rawDataB[6], b33 = rawDataB[10], b34 = rawDataB[14];
            var b41 = rawDataB[3], b42 = rawDataB[7], b43 = rawDataB[11], b44 = rawDataB[15];
            rawData[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
            rawData[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
            rawData[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
            rawData[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
            rawData[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
            rawData[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
            rawData[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
            rawData[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
            rawData[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
            rawData[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
            rawData[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
            rawData[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
            rawData[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
            rawData[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
            rawData[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
            rawData[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
            return this;
        };
        /**
         * 将一个矩阵与该矩阵相乘的结果写入该矩阵。
         * - v = matrix * v
         * @param matrix 一个矩阵。
         */
        Matrix4.prototype.premultiply = function (matrix) {
            return this.multiply(matrix, this);
        };
        Matrix4.prototype.lerp = function (p1, p2, p3) {
            if (p3 === void 0) { p3 = 0.0; }
            if (typeof p2 === "number") {
                p3 = p2;
                p2 = p1;
                p1 = this;
            }
            var rawData = this.rawData;
            if (p3 === 0.0) {
                for (var i = 0; i < 16; i++) {
                    rawData[i] = p1.rawData[i];
                }
                return this;
            }
            else if (p3 === 1.0) {
                for (var i = 0; i < 16; i++) {
                    rawData[i] = p2.rawData[i];
                }
                return this;
            }
            for (var i = 0; i < 16; i++) {
                var fV = p1.rawData[i];
                rawData[i] = fV + (p2.rawData[i] - fV) * p3;
            }
            return this;
        };
        /**
         * 设置该矩阵，使其 Z 轴正方向与起始点到目标点的方向相一致。
         * - 矩阵的缩放值将被覆盖。
         * @param from 起始点。
         * @param to 目标点。
         * @param up
         */
        Matrix4.prototype.lookAt = function (from, to, up) {
            this.lookRotation(_helpVector3C.subtract(to, from), up);
            return this;
        };
        /**
         * 设置该矩阵，使其 Z 轴正方向与目标方向相一致。
         * - 矩阵的缩放值将被覆盖。
         * @param vector 目标方向。
         * @param up
         */
        Matrix4.prototype.lookRotation = function (vector, up) {
            var z = _helpVector3C.normalize(vector);
            var x = _helpVector3A.cross(up, z).normalize(_helpVector3A, egret3d.Vector3.RIGHT);
            var y = _helpVector3B.cross(z, x);
            var rawData = this.rawData;
            rawData[0] = x.x;
            rawData[4] = y.x;
            rawData[8] = z.x;
            rawData[1] = x.y;
            rawData[5] = y.y;
            rawData[9] = z.y;
            rawData[2] = x.z;
            rawData[6] = y.z;
            rawData[10] = z.z;
            return this;
        };
        /**
         * 将该旋转矩阵转换为数组。
         * @param array 数组。
         * @param offset 索引偏移。
         * - 默认 `0`。
         */
        Matrix4.prototype.toArray = function (array, offset) {
            if (array === void 0) { array = null; }
            if (offset === void 0) { offset = 0; }
            if (array === null) {
                array = [];
            }
            var rawData = this.rawData;
            if (offset > 0) {
                for (var i = 0; i < 16; ++i) {
                    array[i + offset] = rawData[i];
                }
            }
            else {
                for (var i = 0; i < 16; ++i) {
                    array[i] = rawData[i];
                }
            }
            return array;
        };
        /**
         * 将该旋转矩阵转换为欧拉旋转。
         * @param euler 欧拉旋转。
         * - 弧度制。
         * @param order 欧拉旋转顺序。
         * - 默认 `egret3d.EulerOrder.YXZ`。
         */
        Matrix4.prototype.toEuler = function (euler, order) {
            if (euler === void 0) { euler = null; }
            if (order === void 0) { order = 3 /* YXZ */; }
            if (euler === null) {
                euler = egret3d.Vector3.create();
            }
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            var rawData = this.rawData;
            var m11 = rawData[0], m12 = rawData[4], m13 = rawData[8];
            var m21 = rawData[1], m22 = rawData[5], m23 = rawData[9];
            var m31 = rawData[2], m32 = rawData[6], m33 = rawData[10];
            switch (order) {
                case 1 /* XYZ */: {
                    euler.y = Math.asin(egret3d.math.clamp(m13, -1.0, 1.0));
                    if (Math.abs(m13) < 0.999999) {
                        euler.x = Math.atan2(-m23, m33);
                        euler.z = Math.atan2(-m12, m11);
                    }
                    else {
                        euler.x = Math.atan2(m32, m22);
                        euler.z = 0.0;
                    }
                    break;
                }
                case 2 /* XZY */: {
                    euler.z = Math.asin(-egret3d.math.clamp(m12, -1.0, 1.0));
                    if (Math.abs(m12) < 0.999999) {
                        euler.x = Math.atan2(m32, m22);
                        euler.y = Math.atan2(m13, m11);
                    }
                    else {
                        euler.x = Math.atan2(-m23, m33);
                        euler.y = 0.0;
                    }
                    break;
                }
                case 3 /* YXZ */: {
                    euler.x = Math.asin(-egret3d.math.clamp(m23, -1.0, 1.0));
                    if (Math.abs(m23) < 0.999999) {
                        euler.y = Math.atan2(m13, m33);
                        euler.z = Math.atan2(m21, m22);
                    }
                    else {
                        euler.y = Math.atan2(-m31, m11);
                        euler.z = 0.0;
                    }
                    break;
                }
                case 4 /* YZX */: {
                    euler.z = Math.asin(egret3d.math.clamp(m21, -1.0, 1.0));
                    if (Math.abs(m21) < 0.999999) {
                        euler.x = Math.atan2(-m23, m22);
                        euler.y = Math.atan2(-m31, m11);
                    }
                    else {
                        euler.x = 0.0;
                        euler.y = Math.atan2(m13, m33);
                    }
                    break;
                }
                case 5 /* ZXY */: {
                    euler.x = Math.asin(egret3d.math.clamp(m32, -1.0, 1.0));
                    if (Math.abs(m32) < 0.999999) {
                        euler.y = Math.atan2(-m31, m33);
                        euler.z = Math.atan2(-m12, m22);
                    }
                    else {
                        euler.y = 0.0;
                        euler.z = Math.atan2(m21, m11);
                    }
                    break;
                }
                case 6 /* ZYX */: {
                    euler.y = Math.asin(-egret3d.math.clamp(m31, -1.0, 1.0));
                    if (Math.abs(m31) < 0.999999) {
                        euler.x = Math.atan2(m32, m33);
                        euler.z = Math.atan2(m21, m11);
                    }
                    else {
                        euler.x = 0.0;
                        euler.z = Math.atan2(-m12, m22);
                    }
                    break;
                }
            }
            return euler;
        };
        Object.defineProperty(Matrix4.prototype, "determinant", {
            /**
             * 获取该矩阵的行列式。
             * - 该值是实时计算的。
             */
            get: function () {
                var rawData = this.rawData;
                var n11 = rawData[0], n12 = rawData[4], n13 = rawData[8], n14 = rawData[12];
                var n21 = rawData[1], n22 = rawData[5], n23 = rawData[9], n24 = rawData[13];
                var n31 = rawData[2], n32 = rawData[6], n33 = rawData[10], n34 = rawData[14];
                var n41 = rawData[3], n42 = rawData[7], n43 = rawData[11], n44 = rawData[15];
                //( based on https://github.com/mrdoob/three.js/blob/dev/src/math/Matrix4.js )
                var n2332 = n23 * n32, n2432 = n24 * n32, n2233 = n22 * n33, n2433 = n24 * n33, n2234 = n22 * n34, n2334 = n23 * n34;
                var n2133 = n21 * n33, n2134 = n21 * n34, n2431 = n24 * n31, n2331 = n23 * n31, n2132 = n21 * n32, n2231 = n22 * n31;
                return (n41 * (+n14 * n2332
                    - n13 * n2432
                    - n14 * n2233
                    + n12 * n2433
                    + n13 * n2234
                    - n12 * n2334) +
                    n42 * (+n11 * n2334
                        - n11 * n2433
                        + n14 * n2133
                        - n13 * n2134
                        + n13 * n2431
                        - n14 * n2331) +
                    n43 * (+n11 * n2432
                        - n11 * n2234
                        - n14 * n2132
                        + n12 * n2134
                        + n14 * n2231
                        - n12 * n2431) +
                    n44 * (-n13 * n2231
                        - n11 * n2332
                        + n11 * n2233
                        + n13 * n2132
                        - n12 * n2133
                        + n12 * n2331));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix4.prototype, "maxScaleOnAxis", {
            /**
             * 获取该矩阵的最大缩放值。
             * - 该值是实时计算的。
             */
            get: function () {
                var rawData = this.rawData;
                var scaleXSq = rawData[0] * rawData[0] + rawData[1] * rawData[1] + rawData[2] * rawData[2];
                var scaleYSq = rawData[4] * rawData[4] + rawData[5] * rawData[5] + rawData[6] * rawData[6];
                var scaleZSq = rawData[8] * rawData[8] + rawData[9] * rawData[9] + rawData[10] * rawData[10];
                return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
            },
            enumerable: true,
            configurable: true
        });
        Matrix4._instances = [];
        /**
         * 一个静态的恒等矩阵。
         * - 注意：请不要修改该值。
         */
        Matrix4.IDENTITY = Matrix4.create();
        return Matrix4;
    }(paper.BaseRelease));
    egret3d.Matrix4 = Matrix4;
    __reflect(Matrix4.prototype, "egret3d.Matrix4", ["paper.ICCS", "paper.ISerializable"]);
    var _helpVector3A = egret3d.Vector3.create();
    var _helpVector3B = egret3d.Vector3.create();
    var _helpVector3C = egret3d.Vector3.create();
    var _helpMatrix = Matrix4.create();
    /**
     * @internal
     */
    egret3d.helpMatrixA = Matrix4.create();
    /**
     * @internal
     */
    egret3d.helpMatrixB = Matrix4.create();
    /**
     * @internal
     */
    egret3d.helpMatrixC = Matrix4.create();
    /**
     * @internal
     */
    egret3d.helpMatrixD = Matrix4.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var Context = (function () {
        function Context(entityClass) {
            this._entities = [];
            this._componentsGroups = [];
            this._componentsGroupsB = [];
            this._groups = {};
            this._entityClass = entityClass;
            paper.Component.onComponentCreated.add(this._onComponentCreated, this);
            paper.Component.onComponentEnabled.add(this._onComponentEnabled, this);
            paper.Component.onComponentDisabled.add(this._onComponentDisabled, this);
            paper.Component.onComponentDestroyed.add(this._onComponentDestroyed, this);
        }
        /**
         *
         */
        Context.create = function (entityClass) {
            return new Context(entityClass);
        };
        Context.prototype._onComponentCreated = function (_a) {
            var entity = _a[0], component = _a[1];
            if (entity.constructor !== this._entityClass) {
                return;
            }
            var componentClass = component.constructor;
            var groups = this._componentsGroupsB[componentClass.componentIndex];
            if (groups) {
                for (var _i = 0, groups_1 = groups; _i < groups_1.length; _i++) {
                    var group = groups_1[_i];
                    group.handleEvent(entity, component, true);
                }
            }
        };
        Context.prototype._onComponentEnabled = function (_a) {
            var entity = _a[0], component = _a[1];
            if (entity.constructor !== this._entityClass) {
                return;
            }
            var componentClass = component.constructor;
            var groups = this._componentsGroups[componentClass.componentIndex];
            if (groups) {
                for (var _i = 0, groups_2 = groups; _i < groups_2.length; _i++) {
                    var group = groups_2[_i];
                    group.handleEvent(entity, component, true);
                }
            }
            if (componentClass.isBehaviour) {
                var groups_3 = this._componentsGroups[paper.Behaviour.componentIndex];
                for (var _b = 0, groups_4 = groups_3; _b < groups_4.length; _b++) {
                    var group = groups_4[_b];
                    group.handleEvent(entity, component, true);
                }
            }
        };
        Context.prototype._onComponentDisabled = function (_a) {
            var entity = _a[0], component = _a[1];
            if (entity.constructor !== this._entityClass) {
                return;
            }
            var componentClass = component.constructor;
            var groups = this._componentsGroups[componentClass.componentIndex];
            if (groups) {
                for (var _i = 0, groups_5 = groups; _i < groups_5.length; _i++) {
                    var group = groups_5[_i];
                    group.handleEvent(entity, component, false);
                }
            }
            if (componentClass.isBehaviour) {
                var groups_6 = this._componentsGroups[paper.Behaviour.componentIndex];
                for (var _b = 0, groups_7 = groups_6; _b < groups_7.length; _b++) {
                    var group = groups_7[_b];
                    group.handleEvent(entity, component, false);
                }
            }
        };
        Context.prototype._onComponentDestroyed = function (_a) {
            var entity = _a[0], component = _a[1];
            if (entity.constructor !== this._entityClass) {
                return;
            }
            var componentClass = component.constructor;
            var groups = this._componentsGroupsB[componentClass.componentIndex];
            if (groups) {
                for (var _i = 0, groups_8 = groups; _i < groups_8.length; _i++) {
                    var group = groups_8[_i];
                    group.handleEvent(entity, component, false);
                }
            }
        };
        Context.prototype.containsEntity = function (entity) {
            return this._entities.indexOf(entity) >= 0;
        };
        Context.prototype.getGroup = function (matcher) {
            var id = matcher.id;
            var groups = this._groups;
            if (id in groups) {
                matcher.release();
            }
            else {
                var componentsGroups = matcher.componentEnabledFilter ? this._componentsGroups : this._componentsGroupsB;
                var group = paper.Group.create(matcher);
                groups[id] = group;
                for (var _i = 0, _a = matcher.components; _i < _a.length; _i++) {
                    var componentClass = _a[_i];
                    var componentIndex = componentClass.componentIndex;
                    if (!componentsGroups[componentIndex]) {
                        componentsGroups[componentIndex] = [];
                    }
                    componentsGroups[componentIndex].push(group);
                }
            }
            return groups[id];
        };
        Object.defineProperty(Context.prototype, "entityCount", {
            get: function () {
                return this._entities.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Context.prototype, "entities", {
            get: function () {
                return this._entities;
            },
            enumerable: true,
            configurable: true
        });
        return Context;
    }());
    paper.Context = Context;
    __reflect(Context.prototype, "paper.Context");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 颜色。
     */
    var Color = (function (_super) {
        __extends(Color, _super);
        /**
         * 请使用 `egret3d.Color.create()` 创建实例。
         * @see egret3d.Color.create()
         */
        function Color() {
            var _this = _super.call(this) || this;
            _this.r = 1.0;
            _this.g = 1.0;
            _this.b = 1.0;
            _this.a = 1.0;
            return _this;
        }
        /**
         * 创建一个新的颜色对象实例
         * @param r 红色通道
         * @param g 绿色通道
         * @param b 蓝色通道
         * @param a 透明通道
         */
        Color.create = function (r, g, b, a) {
            if (r === void 0) { r = 1.0; }
            if (g === void 0) { g = 1.0; }
            if (b === void 0) { b = 1.0; }
            if (a === void 0) { a = 1.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(r, g, b, a);
                instance._released = false;
                return instance;
            }
            return new Color().set(r, g, b, a);
        };
        Color.prototype.serialize = function () {
            return [this.r, this.g, this.b, this.a];
        };
        Color.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Color.prototype.clone = function () {
            return Color.create(this.r, this.g, this.b, this.a);
        };
        Color.prototype.copy = function (value) {
            return this.set(value.r, value.g, value.b, value.a);
        };
        Color.prototype.set = function (r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            if (a !== undefined) {
                this.a = a;
            }
            return this;
        };
        Color.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this.r = value[0 + offset];
            this.g = value[1 + offset];
            this.b = value[2 + offset];
            this.a = value[3 + offset];
            return this;
        };
        Color.prototype.fromHex = function (hex) {
            this.r = (hex >> 16 & 255) / 255;
            this.g = (hex >> 8 & 255) / 255;
            this.b = (hex & 255) / 255;
            return this;
        };
        // public fromHSL(h: number, s: number, l: number): this {
        //     // h,s,l ranges are in 0.0 - 1.0
        //     h = _Math.euclideanModulo(h, 1);
        //     s = floatClamp(s, 0, 1);
        //     l = floatClamp(l, 0, 1);
        //     if (s === 0) {
        //         this.r = this.g = this.b = l;
        //     } else {
        //         var p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
        //         var q = (2 * l) - p;
        //         this.r = hue2rgb(q, p, h + 1 / 3);
        //         this.g = hue2rgb(q, p, h);
        //         this.b = hue2rgb(q, p, h - 1 / 3);
        //     }
        //     return this;
        // }
        Color.prototype.multiply = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
            }
            valueA = this;
            this.r = valueA.r * valueB.r;
            this.g = valueA.g * valueB.g;
            this.b = valueA.b * valueB.b;
            this.a = valueA.a * valueB.a;
            return this;
        };
        Color.prototype.scale = function (value, source) {
            if (!source) {
                source = this;
            }
            this.r = source.r * value;
            this.g = source.g * value;
            this.b = source.b * value;
            this.a = source.a * value;
            return this;
        };
        Color.prototype.lerp = function (t, valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.r = t * (valueB.r - valueA.r) + valueA.r;
            this.g = t * (valueB.g - valueA.g) + valueA.g;
            this.b = t * (valueB.b - valueA.b) + valueA.b;
            this.a = t * (valueB.a - valueA.a) + valueA.a;
            return this;
        };
        /**
         * 所有颜色通道均为零的颜色。
         * - 请注意不要修改该值。
         */
        Color.ZERO = new Color().set(0.0, 0.0, 0.0, 0.0);
        /**
         * 黑色。
         * - 请注意不要修改该值。
         */
        Color.BLACK = new Color().set(0.0, 0.0, 0.0, 1.0);
        /**
         * 灰色。
         * - 请注意不要修改该值。
         */
        Color.GRAY = new Color().set(0.5, 0.5, 0.5, 1.0);
        /**
         * 白色。
         * - 请注意不要修改该值。
         */
        Color.WHITE = new Color().set(1.0, 1.0, 1.0, 1.0);
        /**
         * 红色。
         * - 请注意不要修改该值。
         */
        Color.RED = new Color().set(1.0, 0.0, 0.0, 1.0);
        /**
         * 绿色。
         * - 请注意不要修改该值。
         */
        Color.GREEN = new Color().set(0.0, 1.0, 0.0, 1.0);
        /**
         * 蓝色。
         * - 请注意不要修改该值。
         */
        Color.BLUE = new Color().set(0.0, 0.0, 1.0, 1.0);
        /**
         * 黄色。
         * - 请注意不要修改该值。
         */
        Color.YELLOW = new Color().set(1.0, 1.0, 0.0, 1.0);
        /**
         * 靛蓝色。
         * - 请注意不要修改该值。
         */
        Color.INDIGO = new Color().set(0.0, 1.0, 1.0, 1.0);
        /**
         * 紫色。
         * - 请注意不要修改该值。
         */
        Color.PURPLE = new Color().set(1.0, 0.0, 1.0, 1.0);
        Color._instances = [];
        return Color;
    }(paper.BaseRelease));
    egret3d.Color = Color;
    __reflect(Color.prototype, "egret3d.Color", ["egret3d.IColor", "paper.ICCS", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 程序系统管理器。
     */
    var SystemManager = (function () {
        function SystemManager() {
            this._preSystems = [];
            this._systems = [];
            this._startSystems = [];
            this._reactiveSystems = [];
            this._frameSystems = [];
            this._frameCleanupSystems = [];
            this._tickSystems = [];
            this._tickCleanupSystems = [];
        }
        /**
         * 程序系统管理器单例。
         */
        SystemManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new SystemManager();
            }
            return this._instance;
        };
        SystemManager.prototype._getSystemInsertIndex = function (systems, order) {
            var index = -1;
            var systemCount = systems.length;
            if (systemCount > 0) {
                if (order < systems[0].order) {
                    return 0;
                }
                else if (order >= systems[systemCount - 1].order) {
                    return systemCount;
                }
            }
            for (var i = 0; i < systemCount - 1; ++i) {
                if (systems[i].order <= order && order < systems[i + 1].order) {
                    index = i + 1;
                    break;
                }
            }
            return index < 0 ? systems.length : index;
        };
        /**
         * @internal
         */
        SystemManager.prototype._startup = function () {
            var playerMode = paper.Application.playerMode;
            for (var _i = 0, _a = this._systems; _i < _a.length; _i++) {
                var system = _a[_i];
                if (system.constructor.executeMode & playerMode) {
                    if (system._executeEnabled && !system.enabled) {
                        system.enabled = true;
                    }
                }
                else if (system.enabled) {
                    system.enabled = false;
                    system._executeEnabled = true;
                }
                if (system._lastEnabled === system.enabled || !system.enabled) {
                    continue;
                }
                system.onEnable && system.onEnable();
                if (true) {
                    console.debug(egret.getQualifiedClassName(system), "enabled.");
                }
                if (system.onEntityAdded) {
                    for (var _b = 0, _c = system.groups; _b < _c.length; _b++) {
                        var group = _c[_b];
                        for (var _d = 0, _e = group.entities; _d < _e.length; _d++) {
                            var entity = _e[_d];
                            system.onEntityAdded(entity, group);
                        }
                    }
                }
            }
            for (var _f = 0, _g = this._startSystems; _f < _g.length; _f++) {
                var system = _g[_f];
                if (!system.enabled) {
                    continue;
                }
                if (system.onStart) {
                    system.onStart();
                    system.onStart = undefined;
                }
            }
        };
        SystemManager.prototype._reactive = function (system) {
            for (var _i = 0, _a = system.collectors; _i < _a.length; _i++) {
                var collector = _a[_i];
                if (system.onComponentRemoved) {
                    for (var _b = 0, _c = collector.removedComponentes; _b < _c.length; _b++) {
                        var component = _c[_b];
                        if (component) {
                            system.onComponentRemoved(component, collector.group);
                        }
                    }
                }
                if (system.onEntityRemoved) {
                    for (var _d = 0, _e = collector.removedEntities; _d < _e.length; _d++) {
                        var entity = _e[_d];
                        if (entity) {
                            system.onEntityRemoved(entity, collector.group);
                        }
                    }
                }
                if (system.onEntityAdded) {
                    for (var _f = 0, _g = collector.addedEntities; _f < _g.length; _f++) {
                        var entity = _g[_f];
                        if (entity) {
                            system.onEntityAdded(entity, collector.group);
                        }
                    }
                }
                if (system.onComponentAdded) {
                    for (var _h = 0, _j = collector.addedComponentes; _h < _j.length; _h++) {
                        var component = _j[_h];
                        if (component) {
                            system.onComponentAdded(component, collector.group);
                        }
                    }
                }
                collector.clear();
            }
        };
        /**
         * @internal
         */
        SystemManager.prototype._execute = function (tickCount, frameCount) {
            var reactiveSystems = this._reactiveSystems;
            var startTime = 0;
            for (var i = 0; i < tickCount; ++i) {
                for (var _i = 0, _a = this._systems; _i < _a.length; _i++) {
                    var system = _a[_i];
                    if (!system.enabled) {
                        continue;
                    }
                    if (true) {
                        system.deltaTime = 0;
                        startTime = paper.clock.timestamp();
                    }
                    if (i === 0 && reactiveSystems.indexOf(system) >= 0) {
                        this._reactive(system);
                    }
                    system.onTick && system.onTick(paper.clock.lastTickDelta);
                    if (true) {
                        system.deltaTime += paper.clock.timestamp() - startTime;
                    }
                }
            }
            if (frameCount) {
                for (var _b = 0, _c = this._systems; _b < _c.length; _b++) {
                    var system = _c[_b];
                    if (!system.enabled) {
                        continue;
                    }
                    if (true) {
                        startTime = paper.clock.timestamp();
                    }
                    if (reactiveSystems.indexOf(system) >= 0) {
                        this._reactive(system);
                    }
                    system.onFrame && system.onFrame(paper.clock.lastFrameDelta);
                    if (true) {
                        system.deltaTime += paper.clock.timestamp() - startTime;
                    }
                }
            }
        };
        /**
         * @internal
         */
        SystemManager.prototype._cleanup = function (frameCount) {
            var startTime = 0;
            var i = 0;
            if (frameCount) {
                i = this._frameCleanupSystems.length;
                while (i--) {
                    var system = this._frameCleanupSystems[i];
                    if (!system.enabled) {
                        continue;
                    }
                    if (true) {
                        startTime = paper.clock.timestamp();
                    }
                    system.onFrameCleanup(paper.clock.lastFrameDelta);
                    if (true) {
                        system.deltaTime += paper.clock.timestamp() - startTime;
                    }
                }
            }
            i = this._tickCleanupSystems.length;
            while (i--) {
                var system = this._tickCleanupSystems[i];
                if (!system.enabled) {
                    continue;
                }
                if (true) {
                    startTime = paper.clock.timestamp();
                }
                system.onTickCleanup(paper.clock.lastFrameDelta);
                if (true) {
                    system.deltaTime += paper.clock.timestamp() - startTime;
                }
            }
        };
        /**
         * @internal
         */
        SystemManager.prototype._teardown = function () {
            for (var _i = 0, _a = this._systems; _i < _a.length; _i++) {
                var system = _a[_i];
                if (system._lastEnabled === system.enabled) {
                    continue;
                }
                system._lastEnabled = system.enabled;
                if (system.enabled) {
                    continue;
                }
                if (system.onEntityRemoved) {
                    for (var _b = 0, _c = system.groups; _b < _c.length; _b++) {
                        var group = _c[_b];
                        for (var _d = 0, _e = group.entities; _d < _e.length; _d++) {
                            var entity = _e[_d];
                            system.onEntityRemoved(entity, group);
                        }
                    }
                }
                system.onDisable && system.onDisable();
                if (true) {
                    console.debug(egret.getQualifiedClassName(system), "disabled.");
                }
            }
        };
        /**
         *
         */
        SystemManager.prototype.preRegisterSystems = function () {
            var preSystems = this._preSystems;
            preSystems.sort(function (a, b) { return a[2] - b[2]; });
            for (var _i = 0, preSystems_1 = preSystems; _i < preSystems_1.length; _i++) {
                var pair = preSystems_1[_i];
                this.register.apply(this, pair);
            }
            preSystems.length = 0;
        };
        /**
         * 在程序启动之前预注册一个指定的系统。
         */
        SystemManager.prototype.preRegister = function (systemClass, context, order, config) {
            if (order === void 0) { order = 4000 /* Update */; }
            if (this._systems.length > 0) {
                this.register(systemClass, context, order, config);
                return this;
            }
            this._preSystems.push([systemClass, context, order, config]);
            return this;
        };
        /**
         * 为程序注册一个指定的系统。
         */
        SystemManager.prototype.register = function (systemClass, context, order, config) {
            if (order === void 0) { order = 4000 /* Update */; }
            var system = this.getSystem(systemClass);
            if (system) {
                console.warn("The system has been registered.", egret.getQualifiedClassName(systemClass));
                return system;
            }
            system = paper.BaseSystem.create(systemClass, context, order);
            this._systems.splice(this._getSystemInsertIndex(this._systems, order), 0, system);
            if (system.onStart) {
                this._startSystems.splice(this._getSystemInsertIndex(this._startSystems, order), 0, system);
            }
            if (system.onEntityAdded || system.onComponentAdded || system.onComponentRemoved || system.onEntityRemoved) {
                this._reactiveSystems.splice(this._getSystemInsertIndex(this._reactiveSystems, order), 0, system);
            }
            if (system.onTick) {
                this._tickSystems.splice(this._getSystemInsertIndex(this._tickSystems, order), 0, system);
            }
            if (system.onTickCleanup) {
                this._tickCleanupSystems.splice(this._getSystemInsertIndex(this._tickCleanupSystems, order), 0, system);
            }
            if (system.onFrame) {
                this._frameSystems.splice(this._getSystemInsertIndex(this._frameSystems, order), 0, system);
            }
            if (system.onFrameCleanup) {
                this._frameCleanupSystems.splice(this._getSystemInsertIndex(this._frameCleanupSystems, order), 0, system);
            }
            system.initialize(config);
            return system;
        };
        /**
         * 从程序已注册的全部系统中获取一个指定的系统。
         */
        SystemManager.prototype.getSystem = function (systemClass) {
            for (var _i = 0, _a = this._systems; _i < _a.length; _i++) {
                var system = _a[_i];
                if (system && system.constructor === systemClass) {
                    return system;
                }
            }
            return null;
        };
        Object.defineProperty(SystemManager.prototype, "systems", {
            /**
             * 程序已注册的全部系统。
             */
            get: function () {
                return this._systems;
            },
            enumerable: true,
            configurable: true
        });
        SystemManager._instance = null;
        return SystemManager;
    }());
    paper.SystemManager = SystemManager;
    __reflect(SystemManager.prototype, "paper.SystemManager");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 程序场景管理器。
     */
    var SceneManager = (function () {
        function SceneManager() {
            this._scenes = [];
            /**
             * @internal
             */
            this._globalEntity = null;
            this._globalScene = null;
            this._editorScene = null;
            paper.Scene.onSceneCreated.add(this._addScene, this);
            paper.Scene.onSceneDestroyed.add(this._removeScene, this);
        }
        /**
         * 场景管理器单例。
         */
        SceneManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new SceneManager();
            }
            return this._instance;
        };
        SceneManager.prototype._addScene = function (_a) {
            var scene = _a[0], isActive = _a[1];
            var scenes = this._scenes;
            if (scenes.indexOf(scene) < 0) {
                if (isActive) {
                    scenes.unshift(scene);
                }
                else {
                    scenes.push(scene);
                }
            }
            else if (true) {
                console.error("Add scene error.");
            }
        };
        SceneManager.prototype._removeScene = function (scene) {
            var scenes = this._scenes;
            var index = scenes.indexOf(scene);
            if (index >= 0) {
                scenes.splice(index, 1);
            }
            else if (true) {
                console.error("Remove scene error.");
            }
        };
        /**
         * 创建一个空场景。
         * @param name 该场景的名称。
         * @param isActive 是否将该场景设置为激活场景。
         * - 默认 `true`。
         */
        SceneManager.prototype.createEmptyScene = function (name, isActive) {
            if (isActive === void 0) { isActive = true; }
            return paper.Scene.createEmpty(name, isActive);
        };
        /**
         * 通过指定的场景资源创建一个场景。
         * @param resourceName 该场景的资源名称。
         */
        SceneManager.prototype.createScene = function (resourceName, combineStaticObjects) {
            if (combineStaticObjects === void 0) { combineStaticObjects = true; }
            return paper.Scene.create(resourceName, combineStaticObjects);
        };
        /**
         * 卸载程序中的全部场景。
         * - 不包含全局场景。
         */
        SceneManager.prototype.destroyAllScene = function (excludes) {
            var scenes = this._scenes;
            var i = scenes.length;
            while (i--) {
                var scene = scenes[i];
                if (excludes && excludes.indexOf(scene) >= 0) {
                    continue;
                }
                if (scene === this._globalScene || scene === this._editorScene) {
                    continue;
                }
                scene.destroy();
            }
        };
        /**
         * 从程序已创建的全部场景中获取指定名称的场景。
         */
        SceneManager.prototype.getScene = function (name) {
            for (var _i = 0, _a = this._scenes; _i < _a.length; _i++) {
                var scene = _a[_i];
                if (scene.name === name) {
                    return scene;
                }
            }
            return null;
        };
        Object.defineProperty(SceneManager.prototype, "scenes", {
            /**
             * 程序已创建的全部动态场景。
             */
            get: function () {
                return this._scenes;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "globalEntity", {
            /**
             *
             */
            get: function () {
                if (!this._globalEntity) {
                    this._globalEntity = paper.GameObject.create("Global" /* Global */, "Global" /* Global */, this.globalScene);
                    this._globalEntity.dontDestroy = true;
                }
                return this._globalEntity;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "globalScene", {
            /**
             * 全局场景。
             * - 全局场景无法被销毁。
             */
            get: function () {
                if (!this._globalScene) {
                    this._globalScene = this.createEmptyScene("Global" /* Global */, false);
                    this._scenes.pop(); // Remove global scene from scenes.
                }
                return this._globalScene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "editorScene", {
            /**
             * 全局编辑器场景。
             * - 全局编辑器场景无法被销毁。
             */
            get: function () {
                if (!this._editorScene) {
                    this._editorScene = this.createEmptyScene("Editor" /* Editor */, false);
                    this._scenes.pop(); // Remove editor scene from scenes.
                }
                return this._editorScene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "activeScene", {
            /**
             * 当前激活的场景。
             */
            get: function () {
                var scenes = this._scenes;
                if (scenes.length === 0) {
                    this.createEmptyScene("NoName" /* NoName */);
                }
                return scenes[0];
            },
            set: function (value) {
                var scenes = this._scenes;
                if (scenes.length <= 1 ||
                    scenes[0] === value ||
                    this._globalScene === value ||
                    this._editorScene === value // Cannot active editor scene.
                ) {
                    return;
                }
                var index = scenes.indexOf(value);
                if (index >= 0) {
                    scenes.splice(index, 1);
                    scenes.unshift(value);
                }
                else if (true) {
                    console.error("Active scene error.");
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        SceneManager.prototype.loadScene = function (resourceName, combineStaticObjects) {
            if (combineStaticObjects === void 0) { combineStaticObjects = true; }
            return paper.Scene.create(resourceName, combineStaticObjects);
        };
        /**
         * @deprecated
         */
        SceneManager.prototype.unloadScene = function (scene) {
            scene.destroy();
        };
        /**
         * @deprecated
         */
        SceneManager.prototype.unloadAllScene = function (excludes) {
            this.destroyAllScene(excludes);
        };
        /**
         * @deprecated
         */
        SceneManager.prototype.getActiveScene = function () {
            return this.activeScene;
        };
        SceneManager._instance = null;
        return SceneManager;
    }());
    paper.SceneManager = SceneManager;
    __reflect(SceneManager.prototype, "paper.SceneManager");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 矩形。
     */
    var Rectangle = (function (_super) {
        __extends(Rectangle, _super);
        function Rectangle(x, y, w, h) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (w === void 0) { w = 0.0; }
            if (h === void 0) { h = 0.0; }
            var _this = _super.call(this) || this;
            _this.x = x;
            _this.y = y;
            _this.w = w;
            _this.h = h;
            return _this;
        }
        /**
         * 创建一个矩形。
         * @param x 水平坐标。
         * @param y 垂直坐标。
         * @param w 宽。
         * @param h 高。
         */
        Rectangle.create = function (x, y, w, h) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (w === void 0) { w = 0.0; }
            if (h === void 0) { h = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(x, y, w, h);
                instance._released = false;
                return instance;
            }
            return new Rectangle().set(x, y, w, h);
        };
        Rectangle.prototype.copy = function (value) {
            return this.set(value.x, value.y, value.w, value.h);
        };
        Rectangle.prototype.clone = function () {
            return Rectangle.create(this.x, this.y, this.w, this.h);
        };
        Rectangle.prototype.set = function (x, y, w, h) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
            return this;
        };
        Rectangle.prototype.serialize = function () {
            return [this.x, this.y, this.w, this.h];
        };
        Rectangle.prototype.deserialize = function (element) {
            this.x = element[0];
            this.y = element[1];
            this.w = element[2];
            this.h = element[3];
            return this;
        };
        Rectangle.prototype.multiplyScalar = function (scalar, input) {
            if (!input) {
                input = this;
            }
            this.x = scalar * input.x;
            this.y = scalar * input.y;
            this.w = scalar * input.w;
            this.h = scalar * input.h;
            return this;
        };
        Rectangle.prototype.contains = function (pointOrRect) {
            var minX = this.x;
            var minY = this.y;
            var maxX = this.x + this.w;
            var maxY = this.y + this.h;
            if (pointOrRect instanceof Rectangle) {
                var vMinX = pointOrRect.x;
                var vMinY = pointOrRect.y;
                var vMaxX = pointOrRect.x + pointOrRect.w;
                var vMaxY = pointOrRect.y + pointOrRect.h;
                return minX <= vMinX && vMaxX <= maxX &&
                    minY <= vMinY && vMaxY <= maxY;
            }
            return (pointOrRect.x > minX) && (pointOrRect.x < maxX) &&
                (pointOrRect.y > minY) && (pointOrRect.y < maxY);
        };
        Rectangle._instances = [];
        return Rectangle;
    }(paper.BaseRelease));
    egret3d.Rectangle = Rectangle;
    __reflect(Rectangle.prototype, "egret3d.Rectangle", ["egret3d.IRectangle", "egret3d.IVector2", "egret3d.ISize", "paper.ICCS", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 基础变换组件。
     * - 实现实体之间的父子关系。
     */
    var BaseTransform = (function (_super) {
        __extends(BaseTransform, _super);
        function BaseTransform() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._globalEnabled = false;
            _this._globalEnabledDirty = true;
            _this._children = [];
            _this._parent = null;
            return _this;
        }
        BaseTransform_1 = BaseTransform;
        /**
         * @internal
         */
        BaseTransform.prototype._destroy = function () {
            this.destroyChildren();
            if (this._parent) {
                this._parent._removeChild(this);
            }
            _super.prototype._destroy.call(this);
        };
        /**
         * @internal
         */
        BaseTransform.prototype._addChild = function (child) {
            var children = this._children;
            if (children.indexOf(child) < 0) {
                children.push(child);
                child.entity.scene._rootEntitiesDirty = true;
                child._parent = this;
                return true;
            }
            return false;
        };
        /**
         * @internal
         */
        BaseTransform.prototype._removeChild = function (child) {
            var children = this._children;
            var index = children.indexOf(child);
            if (index >= 0) {
                children.splice(index, 1);
                child.entity.scene._rootEntitiesDirty = true;
                child._parent = null;
                return true;
            }
            return false;
        };
        BaseTransform.prototype.dispatchEnabledEvent = function (enabled) {
            this._globalEnabledDirty = true;
            for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child.entity.enabled) {
                    for (var _b = 0, _c = child.entity.components; _b < _c.length; _b++) {
                        var component = _c[_b];
                        if (component.enabled) {
                            component.dispatchEnabledEvent(enabled);
                        }
                    }
                }
            }
            _super.prototype.dispatchEnabledEvent.call(this, enabled);
        };
        /**
         * 更改该组件的父级变换组件。
         * @param parent 父级变换组件。
         * @param worldTransformStays 是否保留当前世界空间变换。
         */
        BaseTransform.prototype.setParent = function (parent, worldTransformStays) {
            if (worldTransformStays === void 0) { worldTransformStays = false; }
            if (this === parent || (parent && this.contains(parent))) {
                console.error("Set the parent error.");
                return this;
            }
            if (parent && this.entity.scene !== parent.entity.scene) {
                console.error("Cannot change the parent to a different scene.");
                return this;
            }
            if (this.entity === paper.Application.sceneManager._globalEntity) {
                return this;
            }
            var prevParent = this._parent;
            if (prevParent === parent) {
                return this;
            }
            this._onChangeParent(true, worldTransformStays);
            var prevEnabled = this.isActiveAndEnabled;
            if (prevParent) {
                prevParent._removeChild(this);
            }
            if (parent) {
                parent._addChild(this);
            }
            this._globalEnabledDirty = true;
            var currentEnabled = this.isActiveAndEnabled;
            if (prevEnabled !== currentEnabled) {
                this.dispatchEnabledEvent(currentEnabled);
            }
            this._onChangeParent(false, worldTransformStays);
            BaseTransform_1.onTransformParentChanged.dispatch([this, prevParent, parent]);
            return this;
        };
        /**
         * 销毁该组件所有子（孙）级变换组件和其实体。
         */
        BaseTransform.prototype.destroyChildren = function () {
            var children = this._children;
            var i = children.length;
            while (i--) {
                children[i].entity.destroy();
            }
            children.length > 0 && (children.length = 0);
        };
        /**
         *
         */
        BaseTransform.prototype.getChildren = function (out, depth) {
            if (out === void 0) { out = []; }
            if (depth === void 0) { depth = 0; }
            for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (Array.isArray(out)) {
                    out.push(child);
                }
                else {
                    var childName = child.entity.name;
                    if (childName in out) {
                        var transformOrTransforms = out[childName];
                        if (Array.isArray(transformOrTransforms)) {
                            transformOrTransforms.push(child);
                        }
                        else {
                            out[childName] = [transformOrTransforms, child];
                        }
                    }
                    else {
                        out[childName] = child;
                    }
                }
                if (depth !== 1) {
                    child.getChildren(out, depth > 0 ? depth - 1 : 0);
                }
            }
            return out;
        };
        /**
         *
         */
        BaseTransform.prototype.getChildIndex = function (value) {
            if (value._parent === this) {
                return this._children.indexOf(value);
            }
            return -1;
        };
        /**
         *
         */
        BaseTransform.prototype.setChildIndex = function (value, index) {
            if (value._parent === this) {
                var children = this._children;
                var prevIndex = children.indexOf(value);
                if (prevIndex !== index) {
                    children.splice(prevIndex, 1);
                    children.splice(index, 0, value);
                    return true;
                }
            }
            return false;
        };
        /**
         *
         */
        BaseTransform.prototype.getChildAt = function (index) {
            var children = this._children;
            return 0 <= index && index < children.length ? children[index] : null;
        };
        /**
         * 通过指定的名称或路径获取该组件的子（孙）级变换组件。
         * @param nameOrPath 名称或路径。
         */
        BaseTransform.prototype.find = function (nameOrPath) {
            var names = nameOrPath.split("/");
            var ancestor = this;
            for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
                var name_1 = names_1[_i];
                if (!name_1) {
                    return ancestor;
                }
                var prevAncestor = ancestor;
                for (var _a = 0, _b = ancestor._children; _a < _b.length; _a++) {
                    var child = _b[_a];
                    if (child.entity.name === name_1) {
                        ancestor = child;
                        break;
                    }
                }
                if (prevAncestor === ancestor) {
                    return null;
                }
            }
            return ancestor;
        };
        /**
         * 该组件是否包含某个子（孙）级变换组件。
         */
        BaseTransform.prototype.contains = function (child) {
            if (child === this) {
                return false;
            }
            var ancestor = child;
            while (ancestor !== this && ancestor) {
                ancestor = ancestor._parent;
            }
            return ancestor === this;
        };
        Object.defineProperty(BaseTransform.prototype, "isActiveAndEnabled", {
            /**
             *
             */
            get: function () {
                if (this._globalEnabledDirty) {
                    var parent_1 = this._parent;
                    if (!parent_1 || parent_1.isActiveAndEnabled) {
                        this._globalEnabled = this._enabled && this.entity.enabled;
                    }
                    else {
                        this._globalEnabled = false;
                    }
                    this._globalEnabledDirty = false;
                }
                return this._globalEnabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseTransform.prototype, "childCount", {
            /**
             * 该组件的全部子级变换组件总数。（不包含孙级）
             */
            get: function () {
                return this._children.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseTransform.prototype, "children", {
            /**
             * 该组件实体的全部子级变换组件。（不包含孙级）
             */
            get: function () {
                return this._children;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseTransform.prototype, "parent", {
            /**
             * 该组件实体的父级变换组件。
             */
            get: function () {
                return this._parent;
            },
            set: function (value) {
                this.setParent(value, false);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 当变换组件的父级改变时派发事件。
         */
        BaseTransform.onTransformParentChanged = new signals.Signal();
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore
        ], BaseTransform.prototype, "children", null);
        BaseTransform = BaseTransform_1 = __decorate([
            paper.abstract
        ], BaseTransform);
        return BaseTransform;
        var BaseTransform_1;
    }(paper.BaseComponent));
    paper.BaseTransform = BaseTransform;
    __reflect(BaseTransform.prototype, "paper.BaseTransform");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var _points = [
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
    ];
    /**
     * 几何立方体。
     */
    var Box = (function (_super) {
        __extends(Box, _super);
        /**
         * 请使用 `egret3d.AABB.create()` 创建实例。
         * @see egret3d.AABB.create()
         */
        function Box() {
            var _this = _super.call(this) || this;
            _this._dirtyRadius = true;
            _this._dirtyCenter = true;
            _this._dirtySize = true;
            _this._boundingSphereRadius = 0.0;
            _this._minimum = egret3d.Vector3.create(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            _this._maximum = egret3d.Vector3.create(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            _this._center = egret3d.Vector3.create();
            _this._size = egret3d.Vector3.create();
            _this._center.onUpdateTarget = _this;
            _this._center.onUpdate = _this._updateValue;
            _this._size.onUpdateTarget = _this;
            _this._size.onUpdate = _this._updateValue;
            return _this;
        }
        /**
         * 创建一个几何立方体。
         * @param minimum 最小点。
         * @param maximum 最大点。
         */
        Box.create = function (minimum, maximum) {
            if (minimum === void 0) { minimum = null; }
            if (maximum === void 0) { maximum = null; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(minimum, maximum);
                instance._released = false;
                return instance;
            }
            return new Box().set(minimum, maximum);
        };
        Box.prototype._updateValue = function (value) {
            if (value === this._center) {
                this.center = this._center;
            }
            else if (value === this._size) {
                this.size = this._size;
            }
        };
        Box.prototype.serialize = function () {
            return [this._minimum.x, this._minimum.y, this._minimum.z, this._maximum.x, this._maximum.y, this._maximum.z];
        };
        Box.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Box.prototype.clone = function () {
            return Box.create(this.minimum, this.maximum);
        };
        Box.prototype.copy = function (value) {
            return this.set(value.minimum, value.maximum);
        };
        Box.prototype.clear = function () {
            this._minimum.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            this._maximum.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
            this._dirtySize = true;
            return this;
        };
        Box.prototype.set = function (minimum, maximum) {
            if (minimum === void 0) { minimum = null; }
            if (maximum === void 0) { maximum = null; }
            if (minimum && minimum !== this._minimum) {
                this._minimum.copy(minimum);
            }
            if (maximum && maximum !== this._maximum) {
                this._maximum.copy(maximum);
            }
            this._dirtyCenter = true;
            this._dirtyRadius = true;
            this._dirtySize = true;
            return this;
        };
        Box.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this._minimum.fromArray(value, offset);
            this._maximum.fromArray(value, offset + 3);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
            this._dirtySize = true;
            return this;
        };
        /**
         * 设置该立方体，使得全部点都在立方体内。
         * @param points 全部点。
         */
        Box.prototype.fromPoints = function (points) {
            this.clear();
            for (var _i = 0, _a = points; _i < _a.length; _i++) {
                var point = _a[_i];
                this.add(point);
            }
            return this;
        };
        Box.prototype.applyMatrix = function (matrix, input) {
            if (!input) {
                input = this;
            }
            // transform of empty box is an empty box.
            if (input.isEmpty) {
                if (input !== this) {
                    this.copy(input);
                }
                return this;
            }
            var min = input.minimum;
            var max = input.maximum;
            // NOTE: I am using a binary pattern to specify all 2^3 combinations below
            _points[0].set(min.x, min.y, min.z).applyMatrix(matrix); // 000
            _points[1].set(min.x, min.y, max.z).applyMatrix(matrix); // 001
            _points[2].set(min.x, max.y, min.z).applyMatrix(matrix); // 010
            _points[3].set(min.x, max.y, max.z).applyMatrix(matrix); // 011
            _points[4].set(max.x, min.y, min.z).applyMatrix(matrix); // 100
            _points[5].set(max.x, min.y, max.z).applyMatrix(matrix); // 101
            _points[6].set(max.x, max.y, min.z).applyMatrix(matrix); // 110
            _points[7].set(max.x, max.y, max.z).applyMatrix(matrix); // 111
            this.fromPoints(_points);
            return this;
        };
        Box.prototype.add = function (pointOrBox, input) {
            if (!input) {
                input = this;
            }
            var min = input.minimum;
            var max = input.maximum;
            if (pointOrBox instanceof Box) {
                this._minimum.min(pointOrBox._minimum, min);
                this._maximum.max(pointOrBox._maximum, max);
            }
            else {
                this._minimum.min(pointOrBox, min);
                this._maximum.max(pointOrBox, max);
            }
            this._dirtyRadius = true;
            this._dirtyCenter = true;
            this._dirtySize = true;
            return this;
        };
        Box.prototype.expand = function (scalarOrVector, input) {
            if (this.isEmpty) {
                return this;
            }
            if (!input) {
                input = this;
            }
            var min = input.minimum;
            var max = input.maximum;
            if (typeof scalarOrVector === "number") {
                this._minimum.addScalar(-scalarOrVector, min);
                this._maximum.addScalar(scalarOrVector, max);
            }
            else {
                this._minimum.subtract(scalarOrVector, min);
                this._maximum.add(scalarOrVector, max);
            }
            this._dirtyRadius = true;
            this._dirtyCenter = true;
            this._dirtySize = true;
            return this;
        };
        Box.prototype.translate = function (scalarOrVector, input) {
            if (this.isEmpty) {
                return this;
            }
            if (!input) {
                input = this;
            }
            var min = input.minimum;
            var max = input.maximum;
            if (typeof scalarOrVector === "number") {
                this._minimum.addScalar(scalarOrVector, min);
                this._maximum.addScalar(scalarOrVector, max);
            }
            else {
                this._minimum.add(scalarOrVector, min);
                this._maximum.add(scalarOrVector, max);
            }
            this._dirtyRadius = true;
            this._dirtyCenter = true;
            this._dirtySize = true;
            return this;
        };
        /**
         * 获取一个点到该立方体的最近点。（如果该点在立方体内部，则最近点就是该点）
         * @param point 一个点。
         * @param out 最近点。
         */
        Box.prototype.getClosestPointToPoint = function (point, out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            if (this.isEmpty) {
                return out.copy(egret3d.Vector3.ZERO);
            }
            return out.clamp(this._minimum, this._maximum, point);
        };
        /**
         * 获取一个点到该立方体的最近距离。
         * @param point 一个点。
         */
        Box.prototype.getDistance = function (point) {
            if (this.isEmpty) {
                return egret3d.helpVector3A.copy(egret3d.Vector3.ZERO).subtract(point).length;
            }
            return egret3d.helpVector3A.clamp(this._minimum, this._maximum, point).subtract(point).length;
        };
        /**
         * 该立方体是否包含指定的点或立方体。
         */
        Box.prototype.contains = function (pointOrBox) {
            if (this.isEmpty) {
                return false;
            }
            var min = this._minimum;
            var max = this._maximum;
            if (pointOrBox instanceof Box) {
                var vMin = pointOrBox.minimum;
                var vMax = pointOrBox.maximum;
                return min.x <= vMin.x && vMax.x <= max.x &&
                    min.y <= vMin.y && vMax.y <= max.y &&
                    min.z <= vMin.z && vMax.z <= max.z;
            }
            return (pointOrBox.x > min.x) && (pointOrBox.x < max.x) &&
                (pointOrBox.y > min.y) && (pointOrBox.y < max.y) &&
                (pointOrBox.z > min.z) && (pointOrBox.z < max.z);
        };
        Box.prototype.raycast = function (ray, raycastInfo) {
            if (raycastInfo === void 0) { raycastInfo = null; }
            if (this.isEmpty) {
                return false;
            }
            var tmin, tmax, tymin, tymax, tzmin, tzmax;
            var hitDirection = 0;
            var origin = ray.origin;
            var direction = ray.direction;
            var minimum = this.minimum, maximum = this.maximum;
            var invdirx = 1.0 / direction.x, invdiry = 1.0 / direction.y, invdirz = 1.0 / direction.z;
            if (invdirx >= 0.0) {
                tmin = (minimum.x - origin.x) * invdirx;
                tmax = (maximum.x - origin.x) * invdirx;
            }
            else {
                tmin = (maximum.x - origin.x) * invdirx;
                tmax = (minimum.x - origin.x) * invdirx;
            }
            if (invdiry >= 0.0) {
                tymin = (minimum.y - origin.y) * invdiry;
                tymax = (maximum.y - origin.y) * invdiry;
            }
            else {
                tymin = (maximum.y - origin.y) * invdiry;
                tymax = (minimum.y - origin.y) * invdiry;
            }
            if ((tmin > tymax) || (tymin > tmax))
                return false;
            // These lines also handle the case where tmin or tmax is NaN
            // (result of 0 * Infinity). x !== x returns true if x is NaN
            if (tymin > tmin || tmin !== tmin) {
                tmin = tymin;
                hitDirection = 1;
            }
            if (tymax < tmax || tmax !== tmax)
                tmax = tymax;
            if (invdirz >= 0.0) {
                tzmin = (minimum.z - origin.z) * invdirz;
                tzmax = (maximum.z - origin.z) * invdirz;
            }
            else {
                tzmin = (maximum.z - origin.z) * invdirz;
                tzmax = (minimum.z - origin.z) * invdirz;
            }
            if ((tmin > tzmax) || (tzmin > tmax))
                return false;
            if (tzmin > tmin || tmin !== tmin) {
                tmin = tzmin;
                hitDirection = 2;
            }
            if (tzmax < tmax || tmax !== tmax)
                tmax = tzmax;
            // return point closest to the ray (positive side)
            if (tmax < 0.0)
                return false;
            if (tmin <= 0.0)
                return false;
            if (raycastInfo) {
                var normal = raycastInfo.normal;
                ray.getPointAt(raycastInfo.distance = tmin >= 0.0 ? tmin : tmax, raycastInfo.position);
                if (normal) {
                    switch (hitDirection) {
                        case 0:
                            normal.set(invdirx > 0.0 ? -1.0 : 1.0, 0.0, 0.0);
                            break;
                        case 1:
                            normal.set(0.0, invdiry > 0.0 ? -1.0 : 1.0, 0.0);
                            break;
                        case 2:
                            normal.set(0.0, 0.0, invdirz > 0.0 ? -1.0 : 1.0);
                            break;
                    }
                }
            }
            return true;
        };
        /**
         *
         * @param sphere
         */
        Box.prototype.intersectsSphere = function (sphere) {
            if (this.isEmpty) {
                return false;
            }
            // Find the point on the AABB closest to the sphere center.
            var closestPoint = egret3d.helpVector3A.copy(sphere.center).clamp(this.minimum, this.maximum);
            // If that point is inside the sphere, the AABB and sphere intersect.
            return closestPoint.getSquaredDistance(sphere.center) <= (sphere.radius * sphere.radius);
        };
        Object.defineProperty(Box.prototype, "isEmpty", {
            /**
             * 该立方体是否为空。
             */
            get: function () {
                // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
                return (this._maximum.x < this._minimum.x) || (this._maximum.y < this._minimum.y) || (this._maximum.z < this._minimum.z);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Box.prototype, "boundingSphereRadius", {
            /**
             * 该立方体的包围球半径。
             */
            get: function () {
                if (this._dirtyRadius) {
                    if (this.isEmpty) {
                        this._boundingSphereRadius = 0.0;
                    }
                    else {
                        egret3d.helpVector3A.subtract(this._maximum, this._minimum).multiplyScalar(0.5);
                        this._boundingSphereRadius = egret3d.helpVector3A.length;
                    }
                    this._dirtyRadius = false;
                }
                return this._boundingSphereRadius;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Box.prototype, "minimum", {
            /**
             * 该立方体的最小点。
             */
            get: function () {
                return this._minimum;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Box.prototype, "maximum", {
            /**
             * 该立方体的最大点。
             */
            get: function () {
                return this._maximum;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Box.prototype, "size", {
            /**
             * 该立方体的尺寸。
             */
            get: function () {
                if (this._dirtySize) {
                    if (this.isEmpty) {
                        this._size.copy(egret3d.Vector3.ZERO);
                    }
                    else {
                        this._size.subtract(this._maximum, this._minimum);
                    }
                    this._dirtySize = false;
                }
                return this._size;
            },
            set: function (value) {
                if (this.isEmpty) {
                    return;
                }
                var center = this.center;
                var size = this._size.copy(value);
                //
                var halfSize = egret3d.helpVector3A.copy(size).multiplyScalar(0.5);
                this._minimum.copy(center).subtract(halfSize);
                this._maximum.copy(center).add(halfSize);
                this._dirtyRadius = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Box.prototype, "center", {
            /**
             * 该立方体的中心点。
             */
            get: function () {
                if (this._dirtyCenter) {
                    if (this.isEmpty) {
                        this._center.copy(egret3d.Vector3.ZERO);
                    }
                    else {
                        this._center.add(this._maximum, this._minimum).multiplyScalar(0.5);
                    }
                    this._dirtyCenter = false;
                }
                return this._center;
            },
            set: function (value) {
                if (this.isEmpty) {
                    return;
                }
                var size = this.size;
                var center = this._center.copy(value);
                //
                var halfSize = egret3d.helpVector3A.copy(size).multiplyScalar(0.5);
                this._minimum.copy(center).subtract(halfSize);
                this._maximum.copy(center).add(halfSize);
            },
            enumerable: true,
            configurable: true
        });
        Box.ONE = new Box().set(egret3d.Vector3.MINUS_ONE.clone().multiplyScalar(0.5), egret3d.Vector3.ONE.clone().multiplyScalar(0.5));
        Box._instances = [];
        __decorate([
            paper.editor.property("VECTOR3" /* VECTOR3 */, { minimum: 0.0 })
        ], Box.prototype, "size", null);
        __decorate([
            paper.editor.property("VECTOR3" /* VECTOR3 */)
        ], Box.prototype, "center", null);
        return Box;
    }(paper.BaseRelease));
    egret3d.Box = Box;
    __reflect(Box.prototype, "egret3d.Box", ["paper.ICCS", "paper.ISerializable", "egret3d.IRaycast"]);
    /**
     * @internal
     */
    egret3d.helpBoxA = Box.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 基础系统。
     * - 全部系统的基类。
     * - 生命周期的顺序如下：
     * - onAwake();
     * - onEnable();
     * - onStart();
     * - onComponentRemoved();
     * - onEntityRemoved();
     * - onEntityAdded();
     * - onComponentAdded();
     * - onTick();
     * - onFrame();
     * - onFrameCleanup();
     * - onTickCleanup();
     * - onDisable();
     * - onDestroy();
     */
    var BaseSystem = (function () {
        /**
         * 禁止实例化系统。
         * @protected
         */
        function BaseSystem(context, order) {
            if (order === void 0) { order = -1; }
            this.enabled = true;
            this.order = -1;
            this.deltaTime = 0;
            this.groups = [];
            this.collectors = [];
            /**
             * @internal
             */
            this._lastEnabled = false;
            /**
             * @internal
             */
            this._executeEnabled = false;
            this._context = null; // 兼容 interests 2.0 移除。
            /**
             * @deprecated
             */
            this.clock = paper.clock;
            this.order = order;
            this._context = context;
            var matchers = this.getMatchers();
            var listeners = this.getListeners();
            if (matchers) {
                for (var _i = 0, matchers_1 = matchers; _i < matchers_1.length; _i++) {
                    var matcher = matchers_1[_i];
                    this._addGroupAndCollector(matcher);
                }
            }
            if (listeners) {
                for (var _a = 0, listeners_1 = listeners; _a < listeners_1.length; _a++) {
                    var config = listeners_1[_a];
                    config.type.add(config.listener, this);
                }
            }
            if (!this.onEntityAdded && this.onAddGameObject) {
                this.onEntityAdded = this.onAddGameObject;
            }
            if (!this.onEntityRemoved && this.onRemoveGameObject) {
                this.onEntityRemoved = this.onRemoveGameObject;
            }
        }
        /**
         * @internal
         */
        BaseSystem.create = function (systemClass, context, order) {
            return new systemClass(context, order);
        };
        BaseSystem.prototype._addGroupAndCollector = function (matcher) {
            var group = this._context.getGroup(matcher);
            this.groups.push(group);
            this.collectors.push(paper.Collector.create(group));
        };
        /**
         * @internal
         */
        BaseSystem.prototype.initialize = function (config) {
            this.onAwake && this.onAwake(config);
        };
        /**
         * @internal
         */
        BaseSystem.prototype.uninitialize = function () {
        };
        /**
         * 获取该系统需要响应的组件匹配器。
         */
        BaseSystem.prototype.getMatchers = function () {
            return null;
        };
        /**
         *
         */
        BaseSystem.prototype.getListeners = function () {
            return null;
        };
        Object.defineProperty(BaseSystem.prototype, "interests", {
            /**
             * @deprecated
             */
            get: function () {
                return [];
            },
            set: function (value) {
                if (value.length > 0) {
                    var interests = void 0;
                    if (Array.isArray(value[0])) {
                        interests = value;
                    }
                    else {
                        interests = [value];
                    }
                    for (var _i = 0, interests_1 = interests; _i < interests_1.length; _i++) {
                        var interest = interests_1[_i];
                        var allOf = [];
                        var anyOf = [];
                        var noneOf = [];
                        var extraOf = [];
                        for (var _a = 0, interest_1 = interest; _a < interest_1.length; _a++) {
                            var config = interest_1[_a];
                            var isNoneOf = (config.type !== undefined) && (config.type & 2 /* Exculde */) !== 0;
                            var isExtraOf = (config.type !== undefined) && (config.type & 4 /* Unessential */) !== 0;
                            if (Array.isArray(config.componentClass)) {
                                for (var _b = 0, _c = config.componentClass; _b < _c.length; _b++) {
                                    var componentClass = _c[_b];
                                    if (isNoneOf) {
                                        noneOf.push(componentClass);
                                    }
                                    else if (isExtraOf) {
                                        extraOf.push(componentClass);
                                    }
                                    else {
                                        anyOf.push(componentClass);
                                    }
                                }
                            }
                            else if (isNoneOf) {
                                noneOf.push(config.componentClass);
                            }
                            else if (isExtraOf) {
                                extraOf.push(config.componentClass);
                            }
                            else {
                                allOf.push(config.componentClass);
                            }
                            if (config.listeners) {
                                for (var _d = 0, _e = config.listeners; _d < _e.length; _d++) {
                                    var listenerConfig = _e[_d];
                                    listenerConfig.type.add(listenerConfig.listener, this);
                                }
                            }
                        }
                        var matcher = paper.Matcher.create.apply(paper.Matcher, allOf);
                        matcher.anyOf.apply(matcher, anyOf).noneOf.apply(matcher, noneOf).extraOf.apply(matcher, extraOf);
                        this._addGroupAndCollector(matcher);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该系统允许运行的模式。
         * - 默认可以在所有模式运行。
         * - 通过系统装饰器 `@paper.executeMode()` 来修改该值。
         */
        BaseSystem.executeMode = 1 /* Player */ | 2 /* DebugPlayer */ | 4 /* Editor */;
        return BaseSystem;
    }());
    paper.BaseSystem = BaseSystem;
    __reflect(BaseSystem.prototype, "paper.BaseSystem", ["paper.ISystem"]);
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var _mat3Array = [
        1.0, 0.0, 0.0,
        0.0, 1.0, 0.0,
        0.0, 0.0, 1.0
    ];
    /**
     * 3×3 矩阵。
     */
    var Matrix3 = (function (_super) {
        __extends(Matrix3, _super);
        /**
         * 请使用 `egret3d.Matrix3.create()` 创建实例。
         * @see egret3d.Matrix3.create()
         */
        function Matrix3(rawData, offsetOrByteOffset) {
            if (offsetOrByteOffset === void 0) { offsetOrByteOffset = 0; }
            var _this = _super.call(this) || this;
            /**
             * 矩阵原始数据。
             * @readonly
             */
            _this.rawData = null;
            if (rawData && rawData instanceof ArrayBuffer) {
                _this.fromBuffer(rawData, offsetOrByteOffset);
            }
            else {
                _this.rawData = new Float32Array(9);
                _this.fromArray(rawData || _mat3Array);
            }
            return _this;
            // TODO
            // this.rawData = new Float32Array([
            //     1.0, 0.0, 0.0,
            //     0.0, 1.0, 0.0,
            //     0.0, 0.0, 1.0,
            // ]);
            // }
        }
        /**
         * 创建一个矩阵。
         * @param rawData
         * @param offsetOrByteOffset
         */
        Matrix3.create = function (rawData, offsetOrByteOffset) {
            if (offsetOrByteOffset === void 0) { offsetOrByteOffset = 0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().identity();
                instance._released = false;
                if (rawData) {
                    if (rawData instanceof ArrayBuffer) {
                        instance.fromBuffer(rawData, offsetOrByteOffset);
                    }
                    else {
                        instance.fromArray(rawData, offsetOrByteOffset);
                    }
                }
                else {
                    instance.identity();
                }
                return instance;
            }
            return new Matrix3(rawData, offsetOrByteOffset);
        };
        Matrix3.prototype.serialize = function () {
            return this.rawData;
        };
        Matrix3.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Matrix3.prototype.copy = function (value) {
            this.fromArray(value.rawData);
            return this;
        };
        Matrix3.prototype.clone = function () {
            var value = new Matrix3();
            value.copy(this);
            return value;
        };
        Matrix3.prototype.set = function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
            var rawData = this.rawData;
            rawData[0] = n11;
            rawData[1] = n21;
            rawData[2] = n31;
            rawData[3] = n12;
            rawData[4] = n22;
            rawData[5] = n32;
            rawData[6] = n13;
            rawData[7] = n23;
            rawData[8] = n33;
            return this;
        };
        Matrix3.prototype.identity = function () {
            var rawData = this.rawData;
            rawData[0] = 1.0;
            rawData[1] = 0.0;
            rawData[2] = 0.0;
            rawData[3] = 0.0;
            rawData[4] = 1.0;
            rawData[5] = 0.0;
            rawData[6] = 0.0;
            rawData[7] = 0.0;
            rawData[8] = 1.0;
            return this;
        };
        Matrix3.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            for (var i = 0; i < 9; ++i) {
                this.rawData[i] = value[i + offset];
            }
            return this;
        };
        Matrix3.prototype.fromBuffer = function (value, byteOffset) {
            if (byteOffset === void 0) { byteOffset = 0; }
            this.rawData = new Float32Array(value, byteOffset, 9);
            return this;
        };
        Matrix3.prototype.fromScale = function (vector) {
            var rawData = this.rawData;
            rawData[0] = vector.x;
            rawData[1] = 0.0;
            rawData[2] = 0.0;
            rawData[3] = 0.0;
            rawData[4] = vector.y;
            rawData[5] = 0.0;
            rawData[6] = 0.0;
            rawData[7] = 0.0;
            rawData[8] = vector.z;
            return this;
        };
        /**
         * 通过 UV 变换设置该矩阵。
         * @param offsetX 水平偏移。
         * @param offsetY 垂直偏移。
         * @param repeatX 水平重复。
         * @param repeatY 垂直重复。
         * @param rotation 旋转。（弧度制）
         * @param pivotX 水平中心。
         * @param pivotY 垂直中心。
         */
        Matrix3.prototype.fromUVTransform = function (offsetX, offsetY, repeatX, repeatY, rotation, pivotX, pivotY) {
            if (rotation === void 0) { rotation = 0.0; }
            if (pivotX === void 0) { pivotX = 0.0; }
            if (pivotY === void 0) { pivotY = 0.0; }
            var cos = Math.cos(rotation);
            var sin = Math.sin(rotation);
            return this.set(repeatX * cos, repeatX * sin, -repeatX * (cos * pivotX + sin * pivotY) + pivotX + offsetX, -repeatY * sin, repeatY * cos, -repeatY * (-sin * pivotX + cos * pivotY) + pivotY + offsetY, 0.0, 0.0, 1.0);
        };
        Matrix3.prototype.fromMatrix4 = function (value) {
            var rawData = value.rawData;
            this.set(rawData[0], rawData[4], rawData[8], rawData[1], rawData[5], rawData[9], rawData[2], rawData[6], rawData[10]);
            return this;
        };
        Matrix3.prototype.inverse = function (input) {
            if (!input) {
                input = this;
            }
            var me = input.rawData, te = this.rawData, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
            if (det === 0) {
                // TODO
                // var msg = "can't invert matrix, determinant is 0";
                // console.warn(msg);
                return this.identity();
            }
            var detInv = 1 / det;
            te[0] = t11 * detInv;
            te[1] = (n31 * n23 - n33 * n21) * detInv;
            te[2] = (n32 * n21 - n31 * n22) * detInv;
            te[3] = t12 * detInv;
            te[4] = (n33 * n11 - n31 * n13) * detInv;
            te[5] = (n31 * n12 - n32 * n11) * detInv;
            te[6] = t13 * detInv;
            te[7] = (n21 * n13 - n23 * n11) * detInv;
            te[8] = (n22 * n11 - n21 * n12) * detInv;
            return this;
        };
        Matrix3.prototype.getNormalMatrix = function (matrix4) {
            return this.fromMatrix4(matrix4).inverse().transpose();
        };
        Matrix3.prototype.transpose = function () {
            var temp = 0.0;
            var rawData = this.rawData;
            temp = rawData[1];
            rawData[1] = rawData[3];
            rawData[3] = temp;
            temp = rawData[2];
            rawData[2] = rawData[6];
            rawData[6] = temp;
            temp = rawData[5];
            rawData[5] = rawData[7];
            rawData[7] = temp;
            return this;
        };
        Matrix3.prototype.multiply = function (matrixA, matrixB) {
            if (!matrixB) {
                matrixB = matrixA;
                matrixA = this;
            }
            var rawDataA = matrixA.rawData;
            var rawDataB = matrixB.rawData;
            var rawData = this.rawData;
            var a11 = rawDataA[0], a12 = rawDataA[3], a13 = rawDataA[6];
            var a21 = rawDataA[1], a22 = rawDataA[4], a23 = rawDataA[7];
            var a31 = rawDataA[2], a32 = rawDataA[5], a33 = rawDataA[8];
            var b11 = rawDataB[0], b12 = rawDataB[3], b13 = rawDataB[6];
            var b21 = rawDataB[1], b22 = rawDataB[4], b23 = rawDataB[7];
            var b31 = rawDataB[2], b32 = rawDataB[5], b33 = rawDataB[8];
            rawData[0] = a11 * b11 + a12 * b21 + a13 * b31;
            rawData[3] = a11 * b12 + a12 * b22 + a13 * b32;
            rawData[6] = a11 * b13 + a12 * b23 + a13 * b33;
            rawData[1] = a21 * b11 + a22 * b21 + a23 * b31;
            rawData[4] = a21 * b12 + a22 * b22 + a23 * b32;
            rawData[7] = a21 * b13 + a22 * b23 + a23 * b33;
            rawData[2] = a31 * b11 + a32 * b21 + a33 * b31;
            rawData[5] = a31 * b12 + a32 * b22 + a33 * b32;
            rawData[8] = a31 * b13 + a32 * b23 + a33 * b33;
            return this;
        };
        /**
         * 将一个矩阵与该矩阵相乘的结果写入该矩阵。
         * - v = matrix * v
         * @param matrix 一个矩阵。
         */
        Matrix3.prototype.premultiply = function (matrix) {
            return this.multiply(matrix, this);
        };
        /**
         * 将该旋转矩阵转换为数组。
         * @param array 数组。
         * @param offset 数组偏移。
         */
        Matrix3.prototype.toArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            if (!array) {
                array = [];
            }
            for (var i = 0; i < 9; ++i) {
                array[i + offset] = this.rawData[i];
            }
            return array;
        };
        Object.defineProperty(Matrix3.prototype, "determinant", {
            get: function () {
                var rawData = this.rawData;
                var a = rawData[0], b = rawData[1], c = rawData[2], d = rawData[3], e = rawData[4], f = rawData[5], g = rawData[6], h = rawData[7], i = rawData[8];
                return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
            },
            enumerable: true,
            configurable: true
        });
        Matrix3.IDENTITY = new Matrix3();
        Matrix3._instances = [];
        return Matrix3;
    }(paper.BaseRelease));
    egret3d.Matrix3 = Matrix3;
    __reflect(Matrix3.prototype, "egret3d.Matrix3", ["paper.ICCS", "paper.ISerializable"]);
    /**
     * @@interanl
     */
    egret3d.helpMatrix3A = Matrix3.create();
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var math;
    (function (math) {
        /**
         *
         */
        function euclideanModulo(n, m) {
            return ((n % m) + m) % m;
        }
        math.euclideanModulo = euclideanModulo;
        /**
         *
         */
        function clamp(v, min, max) {
            if (min === void 0) { min = 0.0; }
            if (max === void 0) { max = 1.0; }
            if (v < min) {
                return min;
            }
            else if (v > max) {
                return max;
            }
            else {
                return v;
            }
        }
        math.clamp = clamp;
        /**
         *
         */
        function lerp(from, to, t) {
            return from + (to - from) * t;
        }
        math.lerp = lerp;
        function randFloat(low, high) {
            return low + Math.random() * (high - low);
        }
        math.randFloat = randFloat;
        function randFloatSpread(range) {
            return range * (0.5 - Math.random());
        }
        math.randFloatSpread = randFloatSpread;
        function isPowerOfTwo(value) {
            return (value & (value - 1)) === 0 && value !== 0;
        }
        math.isPowerOfTwo = isPowerOfTwo;
        function ceilPowerOfTwo(value) {
            return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
        }
        math.ceilPowerOfTwo = ceilPowerOfTwo;
        function floorPowerOfTwo(value) {
            return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
        }
        math.floorPowerOfTwo = floorPowerOfTwo;
        function frustumIntersectsSphere(frustum, sphere) {
            var planes = frustum.planes;
            var center = sphere.center;
            var negRadius = -sphere.radius;
            for (var _i = 0, planes_1 = planes; _i < planes_1.length; _i++) {
                var plane = planes_1[_i];
                var distance = plane.getDistance(center);
                if (distance < negRadius) {
                    return false;
                }
            }
            return true;
        }
        math.frustumIntersectsSphere = frustumIntersectsSphere;
    })(math = egret3d.math || (egret3d.math = {}));
    /**
     * 内联的数字常数枚举。
     */
    var Const;
    (function (Const) {
        Const[Const["PI"] = 3.141592653589793] = "PI";
        Const[Const["PI_HALF"] = 1.5707963267948966] = "PI_HALF";
        Const[Const["PI_QUARTER"] = 0.7853981633974483] = "PI_QUARTER";
        Const[Const["PI_DOUBLE"] = 6.283185307179586] = "PI_DOUBLE";
        /**
         * 弧度制到角度制相乘的系数。
         */
        Const[Const["RAD_DEG"] = 57.29577951308232] = "RAD_DEG";
        /**
         * 角度制到弧度制相乘的系数。
         */
        Const[Const["DEG_RAD"] = 0.017453292519943295] = "DEG_RAD";
        /**
         * 大于零的最小正值。
         * - https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON
         */
        Const[Const["EPSILON"] = 2.220446049250313e-16] = "EPSILON";
        /**
         * The square root of 2.
         */
        Const[Const["SQRT_2"] = 1.4142135623731] = "SQRT_2";
        /**
         * The square root of 0.5, or, equivalently, one divided by the square root of 2.
         */
        Const[Const["SQRT1_2"] = 0.70710678118655] = "SQRT1_2";
    })(Const = egret3d.Const || (egret3d.Const = {}));
    function sign(value) {
        if (value === 0 || value !== value) {
            return value;
        }
        return value > 0 ? 1 : -1;
    }
    egret3d.sign = sign;
    // export function triangleIntersectsPlane() {
    // }
    function satForAxes(axes) {
        var v0 = egret3d.helpVector3A;
        var v1 = egret3d.helpVector3B;
        var v2 = egret3d.helpVector3C;
        var extents = egret3d.helpVector3H;
        var testAxis = egret3d.helpVector3A;
        for (var i = 0, l = axes.length - 3; i <= l; i += 3) {
            testAxis.fromArray(axes, i);
            // project the aabb onto the seperating axis
            var r = extents.x * Math.abs(testAxis.x) + extents.y * Math.abs(testAxis.y) + extents.z * Math.abs(testAxis.z);
            // project all 3 vertices of the triangle onto the seperating axis
            var p0 = v0.dot(testAxis);
            var p1 = v1.dot(testAxis);
            var p2 = v2.dot(testAxis);
            // actual test, basically see if either of the most extreme of the triangle points intersects r
            if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
                // points of the projected triangle are outside the projected half-length of the aabb
                // the axis is seperating and we can exit
                return false;
            }
        }
        return true;
    }
    function triangleIntersectsAABB(triangle, box) {
        if (box.isEmpty) {
            return false;
        }
        var v0 = egret3d.helpVector3A;
        var v1 = egret3d.helpVector3B;
        var v2 = egret3d.helpVector3C;
        // triangle edge vectors
        var f0 = egret3d.helpVector3D;
        var f1 = egret3d.helpVector3E;
        var f2 = egret3d.helpVector3F;
        var center = egret3d.helpVector3G;
        var extents = egret3d.helpVector3H;
        // compute box center and extents
        extents.subtract(box.maximum, box.center);
        // translate triangle to aabb origin
        v0.subtract(triangle.a, center);
        v1.subtract(triangle.b, center);
        v2.subtract(triangle.c, center);
        // compute edge vectors for triangle
        f0.subtract(v1, v0);
        f1.subtract(v2, v1);
        f2.subtract(v0, v2);
        // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
        // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
        // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
        var axes = [
            0, -f0.z, f0.y, 0, -f1.z, f1.y, 0, -f2.z, f2.y,
            f0.z, 0, -f0.x, f1.z, 0, -f1.x, f2.z, 0, -f2.x,
            -f0.y, f0.x, 0, -f1.y, f1.x, 0, -f2.y, f2.x, 0
        ];
        if (!satForAxes(axes)) {
            return false;
        }
        // test 3 face normals from the aabb
        axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (!satForAxes(axes)) {
            return false;
        }
        // finally testing the face normal of the triangle
        // use already existing triangle edge vectors here
        egret3d.helpVector3A.cross(f0, f1);
        axes = [egret3d.helpVector3A.x, egret3d.helpVector3A.y, egret3d.helpVector3A.z];
        return satForAxes(axes);
    }
    egret3d.triangleIntersectsAABB = triangleIntersectsAABB;
    function planeIntersectsAABB(plane, box) {
        if (box.isEmpty) {
            return false;
        }
        // We compute the minimum and maximum dot product values. If those values
        // are on the same side (back or front) of the plane, then there is no intersection.
        var vMin;
        var vMax;
        var min = box.minimum;
        var max = box.maximum;
        if (plane.normal.x > 0.0) {
            vMin = plane.normal.x * min.x;
            vMax = plane.normal.x * max.x;
        }
        else {
            vMin = plane.normal.x * max.x;
            vMax = plane.normal.x * min.x;
        }
        if (plane.normal.y > 0.0) {
            vMin += plane.normal.y * min.y;
            vMax += plane.normal.y * max.y;
        }
        else {
            vMin += plane.normal.y * max.y;
            vMax += plane.normal.y * min.y;
        }
        if (plane.normal.z > 0.0) {
            vMin += plane.normal.z * min.z;
            vMax += plane.normal.z * max.z;
        }
        else {
            vMin += plane.normal.z * max.z;
            vMax += plane.normal.z * min.z;
        }
        return vMin <= plane.constant && vMax >= plane.constant;
    }
    egret3d.planeIntersectsAABB = planeIntersectsAABB;
    function planeIntersectsSphere(plane, sphere) {
        return Math.abs(plane.getDistance(sphere.center)) <= sphere.radius;
    }
    egret3d.planeIntersectsSphere = planeIntersectsSphere;
    function aabbIntersectsSphere(box, sphere) {
        if (box.isEmpty) {
            return false;
        }
        // Find the point on the AABB closest to the sphere center.
        egret3d.helpVector3A.copy(sphere.center).clamp(box.minimum, box.maximum);
        // If that point is inside the sphere, the AABB and sphere intersect.
        return egret3d.helpVector3A.getSquaredDistance(sphere.center) <= (sphere.radius * sphere.radius);
    }
    egret3d.aabbIntersectsSphere = aabbIntersectsSphere;
    function aabbIntersectsAABB(valueA, valueB) {
        if (valueA.isEmpty || valueB.isEmpty) {
            return false;
        }
        var minA = valueA.minimum;
        var maxA = valueA.maximum;
        var minB = valueB.minimum;
        var maxB = valueB.maximum;
        // using 6 splitting planes to rule out intersections.
        return maxA.x < minB.x || minA.x > maxB.x ||
            maxA.y < minB.y || minA.y > maxB.y ||
            maxA.z < minB.z || minA.z > maxB.z ? false : true;
    }
    egret3d.aabbIntersectsAABB = aabbIntersectsAABB;
    function sphereIntersectsSphere(valueA, valueB) {
        var radiusSum = valueA.radius + valueB.radius;
        return valueA.center.getSquaredDistance(valueB.center) <= (radiusSum * radiusSum);
    }
    egret3d.sphereIntersectsSphere = sphereIntersectsSphere;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @beta 这是一个试验性质的 API，有可能会被删除或修改。
     */
    var CameraPostprocessing = (function (_super) {
        __extends(CameraPostprocessing, _super);
        function CameraPostprocessing() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CameraPostprocessing.prototype.blit = function (src, material, dest, bufferMask) {
            if (material === void 0) { material = null; }
            if (dest === void 0) { dest = null; }
            if (bufferMask === void 0) { bufferMask = null; }
            if (!material) {
                material = egret3d.DefaultMaterials.COPY;
                material.setTexture(src);
            }
            var camerasAndLights = egret3d.cameraAndLightCollecter;
            var saveCamera = camerasAndLights.currentCamera; // TODO
            //
            var camera = egret3d.cameraAndLightCollecter.postprocessingCamera;
            egret3d.renderState.updateRenderTarget(dest);
            egret3d.renderState.updateViewport(camera.viewport, dest);
            egret3d.renderState.clearBuffer(bufferMask || saveCamera.bufferMask, saveCamera.backgroundColor);
            //
            camerasAndLights.currentCamera = camera; // TODO
            egret3d.renderState.draw(egret3d.drawCallCollecter.postprocessing, material);
            camerasAndLights.currentCamera = saveCamera; // TODO
        };
        CameraPostprocessing = __decorate([
            paper.abstract
        ], CameraPostprocessing);
        return CameraPostprocessing;
    }(paper.BaseComponent));
    egret3d.CameraPostprocessing = CameraPostprocessing;
    __reflect(CameraPostprocessing.prototype, "egret3d.CameraPostprocessing");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 灯光组件。
     */
    var BaseLight = (function (_super) {
        __extends(BaseLight, _super);
        function BaseLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * TODO
             */
            _this.cullingMask = 1 /* Default */;
            /**
             * 该灯光的强度。
             */
            _this.intensity = 1.0;
            /**
             * 该灯光的颜色。
             */
            _this.color = egret3d.Color.create(1.0, 1.0, 1.0, 1.0);
            /**
             * 该灯光是否投射阴影。
             */
            _this.castShadows = false;
            /**
             *
             */
            _this.shadow = egret3d.LightShadow.create(_this);
            return _this;
        }
        BaseLight.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            this.shadow._renderTarget.dispose();
        };
        __decorate([
            paper.serializedField
        ], BaseLight.prototype, "cullingMask", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], BaseLight.prototype, "intensity", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("COLOR" /* COLOR */)
        ], BaseLight.prototype, "color", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], BaseLight.prototype, "castShadows", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("NESTED" /* NESTED */)
        ], BaseLight.prototype, "shadow", void 0);
        BaseLight = __decorate([
            paper.abstract
        ], BaseLight);
        return BaseLight;
    }(paper.BaseComponent));
    egret3d.BaseLight = BaseLight;
    __reflect(BaseLight.prototype, "egret3d.BaseLight");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 场景资源。
     */
    var RawScene = (function (_super) {
        __extends(RawScene, _super);
        function RawScene() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @deprecated
         */
        RawScene.prototype.createInstance = function (keepUUID) {
            if (keepUUID === void 0) { keepUUID = false; }
            if (!this.config) {
                return null;
            }
            var isEditor = paper.Application.playerMode === 4 /* Editor */;
            var deserializer = new paper.Deserializer();
            var scene = deserializer.deserialize(this.config, keepUUID);
            if (scene && isEditor) {
            }
            return scene;
        };
        Object.defineProperty(RawScene.prototype, "sceneName", {
            get: function () {
                return this.config.objects[0].name;
            },
            enumerable: true,
            configurable: true
        });
        return RawScene;
    }(paper.BasePrefabAsset));
    paper.RawScene = RawScene;
    __reflect(RawScene.prototype, "paper.RawScene");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 网格渲染组件。
     * - 用于渲染网格筛选组件提供的网格资源。
     */
    var MeshRenderer = (function (_super) {
        __extends(MeshRenderer, _super);
        function MeshRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._lightmapIndex = -1;
            /**
             * 如果该属性合并到 UV2 中，会破坏网格共享，共享的网格无法拥有不同的 lightmap UV。
             */
            _this._lightmapScaleOffset = egret3d.Vector4.create();
            return _this;
        }
        /**
         * @private
         */
        MeshRenderer.prototype.recalculateLocalBox = function () {
            var meshFilter = this.entity.getComponent(egret3d.MeshFilter);
            this._localBoundingBox.clear();
            if (meshFilter && meshFilter.mesh && !meshFilter.mesh.isDisposed) {
                var vertices = meshFilter.mesh.getVertices();
                var position = egret3d.helpVector3A;
                for (var i = 0, l = vertices.length; i < l; i += 3) {
                    position.set(vertices[i], vertices[i + 1], vertices[i + 2]);
                    this._localBoundingBox.add(position);
                }
            }
        };
        /**
         * 实时获取网格资源的指定三角形顶点位置。
         * @param triangleIndex 三角形索引。
         * @param out
         */
        MeshRenderer.prototype.getTriangle = function (triangleIndex, out) {
            if (!out) {
                out = egret3d.Triangle.create();
            }
            var transform = this.entity.getComponent(egret3d.Transform);
            var meshFilter = this.entity.getComponent(egret3d.MeshFilter);
            if (transform && meshFilter && meshFilter.mesh && !meshFilter.mesh.isDisposed) {
                var localToWorldMatrix = transform.localToWorldMatrix;
                meshFilter.mesh.getTriangle(triangleIndex, out);
                out.a.applyMatrix(localToWorldMatrix);
                out.b.applyMatrix(localToWorldMatrix);
                out.c.applyMatrix(localToWorldMatrix);
            }
            return out;
        };
        MeshRenderer.prototype.raycast = function (ray, raycastInfo) {
            if (raycastInfo === void 0) { raycastInfo = null; }
            var transform = this.entity.getComponent(egret3d.Transform);
            var meshFilter = this.entity.getComponent(egret3d.MeshFilter);
            if (transform && meshFilter && meshFilter.enabled && meshFilter.mesh && !meshFilter.mesh.isDisposed) {
                var worldToLocalMatrix = transform.worldToLocalMatrix;
                var localRay = egret3d.helpRay.applyMatrix(worldToLocalMatrix, ray);
                var localBoundingBox = this.localBoundingBox;
                if (localBoundingBox.raycast(localRay) && meshFilter.mesh.raycast(localRay, raycastInfo)) {
                    if (raycastInfo) {
                        var localToWorldMatrix = transform.localToWorldMatrix;
                        raycastInfo.distance = ray.origin.getDistance(raycastInfo.position.applyMatrix(localToWorldMatrix));
                        raycastInfo.transform = transform;
                        var normal = raycastInfo.normal;
                        if (normal) {
                            // normal.applyDirection(localToWorldMatrix);
                            normal.applyMatrix3(egret3d.helpMatrix3A.fromMatrix4(worldToLocalMatrix).transpose()).normalize();
                        }
                    }
                    return true;
                }
            }
            return false;
        };
        Object.defineProperty(MeshRenderer.prototype, "lightmapIndex", {
            /**
             * 该组件的光照图索引。
             */
            get: function () {
                return this._lightmapIndex;
            },
            set: function (value) {
                if (value === this._lightmapIndex) {
                    return;
                }
                this._lightmapIndex = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MeshRenderer.prototype, "lightmapScaleOffset", {
            /**
             * TODO
             */
            get: function () {
                return this._lightmapScaleOffset;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], MeshRenderer.prototype, "_lightmapScaleOffset", void 0);
        __decorate([
            paper.editor.property("INT" /* INT */, { minimum: -1 }),
            paper.serializedField("_lightmapIndex")
        ], MeshRenderer.prototype, "lightmapIndex", null);
        return MeshRenderer;
    }(paper.BaseRenderer));
    egret3d.MeshRenderer = MeshRenderer;
    __reflect(MeshRenderer.prototype, "egret3d.MeshRenderer");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 四元数。
     */
    var Quaternion = (function (_super) {
        __extends(Quaternion, _super);
        function Quaternion() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * 创建一个四元数。
         */
        Quaternion.create = function (x, y, z, w) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (w === void 0) { w = 1.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(x, y, z, w);
                instance._released = false;
                return instance;
            }
            return new Quaternion().set(x, y, z, w);
        };
        Quaternion.prototype.clone = function () {
            return Quaternion.create(this.x, this.y, this.z, this.w);
        };
        /**
         * 通过旋转矩阵设置该四元数。
         * - 旋转矩阵不应包含缩放值。
         * @param rotateMatrix 旋转矩阵。
         */
        Quaternion.prototype.fromMatrix = function (rotateMatrix) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            var rawData = rotateMatrix.rawData;
            var m11 = rawData[0], m12 = rawData[4], m13 = rawData[8];
            var m21 = rawData[1], m22 = rawData[5], m23 = rawData[9];
            var m31 = rawData[2], m32 = rawData[6], m33 = rawData[10];
            var trace = m11 + m22 + m33;
            var s = 0.0;
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                this.w = 0.25 / s;
                this.x = (m32 - m23) * s;
                this.y = (m13 - m31) * s;
                this.z = (m21 - m12) * s;
            }
            else if (m11 > m22 && m11 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                this.w = (m32 - m23) / s;
                this.x = 0.25 * s;
                this.y = (m12 + m21) / s;
                this.z = (m13 + m31) / s;
            }
            else if (m22 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                this.w = (m13 - m31) / s;
                this.x = (m12 + m21) / s;
                this.y = 0.25 * s;
                this.z = (m23 + m32) / s;
            }
            else {
                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                this.w = (m21 - m12) / s;
                this.x = (m13 + m31) / s;
                this.y = (m23 + m32) / s;
                this.z = 0.25 * s;
            }
            return this;
        };
        Quaternion.prototype.fromEuler = function (eulerOrX, orderOrY, eulerZ, order) {
            var x, y, z;
            if (eulerOrX.hasOwnProperty("x")) {
                x = eulerOrX.x;
                y = eulerOrX.y;
                z = eulerOrX.z;
                order = orderOrY || 3 /* YXZ */;
            }
            else {
                x = eulerOrX;
                y = orderOrY;
                z = eulerZ;
                order = order || 3 /* YXZ */;
            }
            // http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
            var cos = Math.cos;
            var sin = Math.sin;
            var c1 = cos(x * 0.5);
            var c2 = cos(y * 0.5);
            var c3 = cos(z * 0.5);
            var s1 = sin(x * 0.5);
            var s2 = sin(y * 0.5);
            var s3 = sin(z * 0.5);
            switch (order) {
                case 1 /* XYZ */:
                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;
                    break;
                case 2 /* XZY */:
                    this.x = s1 * c2 * c3 - c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 + s1 * s2 * s3;
                    break;
                case 3 /* YXZ */:
                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 - s1 * s2 * c3;
                    this.w = c1 * c2 * c3 + s1 * s2 * s3;
                    break;
                case 4 /* YZX */:
                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 + s1 * c2 * s3;
                    this.z = c1 * c2 * s3 - s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;
                    break;
                case 5 /* ZXY */:
                    this.x = s1 * c2 * c3 - c1 * s2 * s3;
                    this.y = c1 * s2 * c3 + s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;
                    break;
                case 6 /* ZYX */:
                    this.x = s1 * c2 * c3 - c1 * s2 * s3;
                    this.y = c1 * s2 * c3 + s1 * c2 * s3;
                    this.z = c1 * c2 * s3 - s1 * s2 * c3;
                    this.w = c1 * c2 * c3 + s1 * s2 * s3;
                    break;
            }
            return this;
        };
        /**
         * 通过旋转轴设置该四元数。
         * - 假设旋转轴已被归一化。
         * @param axis 旋转轴。
         * @param angle 旋转角。（弧度制）
         */
        Quaternion.prototype.fromAxis = function (axis, angle) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
            var halfAngle = angle * 0.5, s = Math.sin(halfAngle);
            this.x = axis.x * s;
            this.y = axis.y * s;
            this.z = axis.z * s;
            this.w = Math.cos(halfAngle);
            return this;
        };
        /**
         * 通过自起始方向到目标方向的旋转值设置该四元数。
         * - 假设方向向量已被归一化。
         * @param from 起始方向。
         * @param to 目标方向。
         */
        Quaternion.prototype.fromVectors = function (from, to) {
            var r = from.dot(to) + 1.0;
            var v1 = egret3d.helpVector3A;
            if (r < 2.220446049250313e-16 /* EPSILON */) {
                r = 0.0;
                if (Math.abs(from.x) > Math.abs(from.z)) {
                    v1.set(-from.y, from.x, 0.0);
                }
                else {
                    v1.set(0.0, -from.z, from.y);
                }
            }
            else {
                v1.cross(from, to);
            }
            this.x = v1.x;
            this.y = v1.y;
            this.z = v1.z;
            this.w = r;
            return this.normalize();
        };
        /**
         * 将该四元数转换为恒等四元数。
         */
        Quaternion.prototype.identity = function () {
            this.x = this.y = this.z = 0.0;
            this.w = 1.0;
            return this;
        };
        Quaternion.prototype.multiply = function (quaternionA, quaternionB) {
            if (!quaternionB) {
                quaternionB = quaternionA;
                quaternionA = this;
            }
            // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
            var ax = quaternionA.x, ay = quaternionA.y, az = quaternionA.z, aw = quaternionA.w;
            var bx = quaternionB.x, by = quaternionB.y, bz = quaternionB.z, bw = quaternionB.w;
            this.x = ax * bw + aw * bx + ay * bz - az * by;
            this.y = ay * bw + aw * by + az * bx - ax * bz;
            this.z = az * bw + aw * bz + ax * by - ay * bx;
            this.w = aw * bw - ax * bx - ay * by - az * bz;
            return this;
        };
        /**
         * 将一个四元数与该四元数相乘的结果写入该四元数。
         * - v = quaternion * v
         * @param quaternion 一个四元数。
         */
        Quaternion.prototype.premultiply = function (quaternion) {
            return this.multiply(quaternion, this);
        };
        Quaternion.prototype.lerp = function (p1, p2, p3) {
            if (typeof p1 === "number") {
                if (!p3) {
                    p3 = p1;
                    p1 = this;
                }
                else {
                    var temp = p1;
                    p1 = p2;
                    p2 = p3;
                    p3 = temp;
                }
            }
            else if (typeof p2 === "number") {
                p3 = p2;
                p2 = p1;
                p1 = this;
            }
            var fX = p1.x, fY = p1.y, fZ = p1.z, fW = p1.w;
            var tX = p2.x, tY = p2.y, tZ = p2.z, tW = p2.w;
            if (fX * tX + fY * tY + fZ * tZ + fW * tW < 0.0) {
                this.x = fX + (-tX - fX) * p3;
                this.y = fY + (-tY - fY) * p3;
                this.z = fZ + (-tZ - fZ) * p3;
                this.w = fW + (-tW - fW) * p3;
            }
            else {
                this.x = fX + (tX - fX) * p3;
                this.y = fY + (tY - fY) * p3;
                this.z = fZ + (tZ - fZ) * p3;
                this.w = fW + (tW - fW) * p3;
            }
            return this.normalize();
        };
        Quaternion.prototype.slerp = function (p1, p2, p3) {
            if (typeof p1 === "number") {
                if (!p3) {
                    p3 = p1;
                    p1 = this;
                }
                else {
                    var temp = p1;
                    p1 = p2;
                    p2 = p3;
                    p3 = temp;
                }
            }
            else if (typeof p2 === "number") {
                p3 = p2;
                p2 = p1;
                p1 = this;
            }
            if (p1 === 0.0)
                return this.copy(p2);
            if (p1 === 1.0)
                return this.copy(p3);
            // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
            var fX = p1.x, fY = p1.y, fZ = p1.z, fW = p1.w;
            var tX = p2.x, tY = p2.y, tZ = p2.z, tW = p2.w;
            var cosHalfTheta = fW * tW + fX * tX + fY * tY + fZ * tZ;
            if (cosHalfTheta < 0.0) {
                this.w = -tW;
                this.x = -tX;
                this.y = -tY;
                this.z = -tZ;
                cosHalfTheta = -cosHalfTheta;
            }
            else {
                this.w = tW;
                this.x = tX;
                this.y = tY;
                this.z = tZ;
            }
            if (cosHalfTheta >= 1.0) {
                this.w = fW;
                this.x = fX;
                this.y = fY;
                this.z = fZ;
                return this;
            }
            var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
            if (sqrSinHalfTheta < 2.220446049250313e-16 /* EPSILON */) {
                return this.lerp(p1, this);
            }
            var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
            var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
            var ratioA = Math.sin((1.0 - p3) * halfTheta) / sinHalfTheta, ratioB = Math.sin(p3 * halfTheta) / sinHalfTheta;
            this.w = fW * ratioA + this.w * ratioB;
            this.x = fX * ratioA + this.x * ratioB;
            this.y = fY * ratioA + this.y * ratioB;
            this.z = fZ * ratioA + this.z * ratioB;
            return this;
        };
        /**
         * 设置该四元数，使其与起始点到目标点的方向相一致。
         * @param from 起始点。
         * @param to 目标点。
         * @param up
         */
        Quaternion.prototype.lookAt = function (from, to, up) {
            return this.fromMatrix(egret3d.helpMatrixA.lookAt(from, to, up));
        };
        /**
         * 设置该四元数，使其与目标方向相一致。
         * @param vector 目标方向。
         * @param up
         */
        Quaternion.prototype.lookRotation = function (vector, up) {
            return this.fromMatrix(egret3d.helpMatrixA.lookRotation(vector, up));
        };
        /**
         * 获取该四元数和一个四元数的夹角。（弧度制）
         */
        Quaternion.prototype.getAngle = function (value) {
            return 2.0 * Math.acos(Math.abs(egret3d.math.clamp(this.dot(value), -1.0, 1.0)));
        };
        /**
         * 将该四元数转换为欧拉旋转。（弧度制）
         * @param out 欧拉旋转。
         * @param order 欧拉旋转顺序。
         */
        Quaternion.prototype.toEuler = function (out, order) {
            if (order === void 0) { order = 3 /* YXZ */; }
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return _helpMatrix.fromRotation(this).toEuler(out, order);
        };
        /**
         * 恒等四元数。
         */
        Quaternion.IDENTITY = new Quaternion();
        Quaternion._instances = [];
        return Quaternion;
    }(egret3d.Vector4));
    egret3d.Quaternion = Quaternion;
    __reflect(Quaternion.prototype, "egret3d.Quaternion");
    var _helpMatrix = egret3d.Matrix4.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    1 /* Default */; // egret build bug.
    /**
     * 游戏实体。
     */
    var GameObject = (function (_super) {
        __extends(GameObject, _super);
        function GameObject() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 是否是静态模式。
             */
            _this.isStatic = false;
            /**
             * 层级。
             * - 用于各种层遮罩。
             */
            _this.layer = 1 /* Default */;
            /**
             * 该实体的变换组件。
             */
            _this.transform = null;
            /**
             * 渲染组件。
             */
            _this.renderer = null;
            /**
             * @internal
             */
            _this._beforeRenderBehaviorCount = 0;
            return _this;
        }
        /**
         * 创建游戏实体，并添加到当前场景中。
         */
        GameObject.create = function (name, tag, scene) {
            if (name === void 0) { name = "NoName" /* NoName */; }
            if (tag === void 0) { tag = "Untagged" /* Untagged */; }
            if (scene === void 0) { scene = null; }
            var gameObect = new GameObject();
            gameObect._isDestroyed = false;
            gameObect._enabled = paper.Entity.createDefaultEnabled;
            gameObect.name = name;
            gameObect.tag = tag;
            gameObect._setScene(scene || paper.Application.sceneManager.activeScene, true);
            gameObect.addComponent(egret3d.Transform); //
            return gameObect;
        };
        GameObject.prototype._destroy = function () {
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (component && component !== this.transform) {
                    this._removeComponent(component, null);
                }
            }
            this._removeComponent(this.transform, null); // Remove transform at last.
        };
        GameObject.prototype._setScene = function (value, dispatchEvent) {
            if (this.transform && this.transform.parent && this.transform.parent.entity.scene !== value) {
                this.transform.parent = null;
            }
            _super.prototype._setScene.call(this, value, false);
            if (this.transform) {
                for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    child.entity._setScene(value, false);
                }
            }
            if (dispatchEvent) {
                _super.prototype._setScene.call(this, null, true);
                if (this.transform) {
                    for (var _b = 0, _c = this.transform.children; _b < _c.length; _b++) {
                        var child = _c[_b];
                        child.entity._setScene(null, true);
                    }
                }
            }
        };
        GameObject.prototype._setEnabled = function (value) {
            var transformParent = this.transform ? this.transform.parent : null;
            if (!transformParent || transformParent.isActiveAndEnabled) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (!component) {
                        continue;
                    }
                    if (component.constructor === paper.GroupComponent) {
                        for (var _b = 0, _c = component.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            if (componentInGroup.enabled) {
                                componentInGroup.dispatchEnabledEvent(value);
                            }
                        }
                    }
                    else if (component.enabled) {
                        component.dispatchEnabledEvent(value);
                    }
                }
            }
        };
        GameObject.prototype._addComponent = function (component, config) {
            if (component instanceof paper.BaseTransform) {
                this.transform = component;
            }
            else if (component instanceof paper.BaseRenderer) {
                this.renderer = component;
            }
            else if (component.constructor.isBehaviour) {
                if (component.onBeforeRender) {
                    this._beforeRenderBehaviorCount++;
                }
            }
            _super.prototype._addComponent.call(this, component, config);
        };
        /**
         * @internal
         */
        GameObject.prototype._removeComponent = function (component, groupComponent) {
            _super.prototype._removeComponent.call(this, component, groupComponent);
            if (component === this.transform) {
                this.transform = null;
            }
            else if (component === this.renderer) {
                this.renderer = null;
            }
            else if (component.constructor.isBehaviour) {
                if (component.onBeforeRender) {
                    this._beforeRenderBehaviorCount--;
                }
            }
        };
        GameObject.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            this.isStatic = false;
            this.hideFlags = 0 /* None */;
            this.layer = 1 /* Default */;
            this.tag = "";
            this._beforeRenderBehaviorCount = 0;
        };
        /**
         * 获取一个自己或父级中指定的组件实例。
         * - 仅查找处于激活状态的父级实体。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试获取全部派生自此组件的实例。
         */
        GameObject.prototype.getComponentInParent = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (this._isDestroyed) {
                return null;
            }
            var component = this.getComponent(componentClass, isExtends);
            if (!component) {
                var parent_2 = this.transform.parent;
                while (!component && parent_2 && parent_2.enabled && parent_2.entity.enabled) {
                    component = parent_2.gameObject.getComponentInParent(componentClass, isExtends);
                    parent_2 = parent_2.parent;
                }
            }
            return component;
        };
        /**
         * 获取一个自己或子（孙）级中指定的组件实例。
         * - 仅查找处于激活状态的子（孙）级实体。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试获取全部派生自此组件的实例。
         */
        GameObject.prototype.getComponentInChildren = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (this._isDestroyed) {
                return null;
            }
            var component = this.getComponent(componentClass, isExtends);
            if (!component && this.transform.enabled) {
                for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    if (child.enabled && child.entity.enabled) {
                        component = child.gameObject.getComponentInChildren(componentClass, isExtends);
                        if (component) {
                            break;
                        }
                    }
                }
            }
            return component;
        };
        /**
         * 获取全部自己和子（孙）级中指定的组件实例。
         * @param componentClass 组件类。
         * @param isExtends 是否尝试获取全部派生自此组件的实例。
         * @param includeInactive 是否尝试查找处于未激活状态的子（孙）级实体。（默认 `false`）
         */
        GameObject.prototype.getComponentsInChildren = function (componentClass, isExtends, includeInactive, components) {
            if (isExtends === void 0) { isExtends = false; }
            if (includeInactive === void 0) { includeInactive = false; }
            if (components === void 0) { components = null; }
            components = components || [];
            if (this._isDestroyed) {
                return components;
            }
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (!component) {
                    continue;
                }
                if (component.constructor === paper.GroupComponent) {
                    var groupComponent = component;
                    if (isExtends ?
                        groupComponent.components[0] instanceof componentClass :
                        groupComponent.components[0].constructor === componentClass) {
                        for (var _b = 0, _c = groupComponent.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            components.push(componentInGroup);
                        }
                    }
                }
                else if (isExtends ? component instanceof componentClass : component.constructor === componentClass) {
                    components.push(component);
                }
            }
            if (this.transform.enabled) {
                for (var _d = 0, _e = this.transform.children; _d < _e.length; _d++) {
                    var child = _e[_d];
                    if (includeInactive || (child.enabled && child.entity.enabled)) {
                        child.gameObject.getComponentsInChildren(componentClass, isExtends, includeInactive, components);
                    }
                }
            }
            return components;
        };
        /**
         * 向该实体已激活的全部 Behaviour 组件发送消息。
         * @param methodName
         * @param parameter
         */
        GameObject.prototype.sendMessage = function (methodName, parameter, requireReceiver) {
            if (requireReceiver === void 0) { requireReceiver = true; }
            if (this._isDestroyed) {
                return this;
            }
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (component && component.constructor.isBehaviour && component.enabled) {
                    if (methodName in component) {
                        component[methodName](parameter);
                    }
                    else if (requireReceiver && true) {
                        console.warn(this.name, egret.getQualifiedClassName(component), methodName); // TODO
                    }
                }
            }
            return this;
        };
        /**
         * 向该实体和其父级的 Behaviour 组件发送消息。
         * @param methodName
         * @param parameter
         */
        GameObject.prototype.sendMessageUpwards = function (methodName, parameter, requireReceiver) {
            if (requireReceiver === void 0) { requireReceiver = true; }
            if (this._isDestroyed) {
                return this;
            }
            this.sendMessage(methodName, parameter, requireReceiver);
            //
            var parent = this.transform.parent;
            if (parent && parent.enabled) {
                parent.gameObject.sendMessageUpwards(methodName, parameter, requireReceiver);
            }
            return this;
        };
        /**
         * 向该实体和的其子（孙）级的 Behaviour 组件发送消息。
         * @param methodName
         * @param parameter
         */
        GameObject.prototype.broadcastMessage = function (methodName, parameter, requireReceiver) {
            if (requireReceiver === void 0) { requireReceiver = true; }
            if (this._isDestroyed) {
                return this;
            }
            this.sendMessage(methodName, parameter, requireReceiver);
            for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child.enabled) {
                    child.gameObject.broadcastMessage(methodName, parameter, requireReceiver);
                }
            }
            return this;
        };
        Object.defineProperty(GameObject.prototype, "activeSelf", {
            /**
             * 该实体自身的激活状态。
             */
            get: function () {
                return this._enabled;
            },
            set: function (value) {
                this.enabled = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "activeInHierarchy", {
            /**
             * 该实体在场景中的激活状态。
             */
            get: function () {
                var transformParent = this.transform ? this.transform.parent : null;
                return this._enabled && (!transformParent || transformParent.isActiveAndEnabled);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "path", {
            /**
             * 该实体的路径。
             */
            get: function () {
                var path = this.name;
                if (this.transform) {
                    var transformParent = this.transform.parent;
                    while (transformParent) {
                        path = transformParent.entity.name + "/" + path;
                        transformParent = transformParent.parent;
                    }
                    return this._scene.name + "/" + path;
                }
                return path;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "parent", {
            /**
             * 该实体的父级实体。
             */
            get: function () {
                return (this.transform && this.transform.parent) ? this.transform.parent.gameObject : null;
            },
            set: function (value) {
                if (this.transform) {
                    this.transform.parent = value ? value.transform : null;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         * @see paper.Scene#find()
         */
        GameObject.find = function (name, scene) {
            if (scene === void 0) { scene = null; }
            return (scene || paper.Application.sceneManager.activeScene).find(name);
        };
        Object.defineProperty(GameObject, "globalGameObject", {
            /**
             * @deprecated
             */
            get: function () {
                return paper.Application.sceneManager.globalEntity;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "globalGameObject", {
            /**
             * @deprecated
             */
            get: function () {
                return paper.Application.sceneManager.globalEntity;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField,
            paper.editor.property("CHECKBOX" /* CHECKBOX */)
        ], GameObject.prototype, "isStatic", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("LIST" /* LIST */, { listItems: paper.editor.getItemsFromEnum(paper.Layer) }) // TODO
        ], GameObject.prototype, "layer", void 0);
        return GameObject;
    }(paper.Entity));
    paper.GameObject = GameObject;
    __reflect(GameObject.prototype, "paper.GameObject");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * Shader 资源。
     */
    var Shader = (function (_super) {
        __extends(Shader, _super);
        function Shader() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.customs = null;
            return _this;
        }
        Shader.create = function (name, shaderOrConfig) {
            var config;
            var shader;
            var parent = null;
            if (shaderOrConfig instanceof Shader) {
                // TODO
                var KHR_techniques_webgl = shaderOrConfig.config.extensions.KHR_techniques_webgl;
                var technique = KHR_techniques_webgl.techniques[0];
                var uniforms = {};
                parent = shaderOrConfig;
                for (var k in technique.uniforms) {
                    uniforms[k] = technique.uniforms[k];
                }
                config = {
                    extensions: {
                        KHR_techniques_webgl: {
                            shaders: KHR_techniques_webgl.shaders,
                            techniques: [{
                                    attributes: technique.attributes,
                                    uniforms: uniforms,
                                }]
                        }
                    }
                };
            }
            else {
                config = shaderOrConfig;
            }
            // Retargeting.
            shader = new egret3d.Shader();
            shader.initialize(name, config, null, parent);
            return shader;
        };
        /**
         * @private
         */
        Shader.createDefaultStates = function () {
            var states = {
                enable: [2929 /* DepthTest */, 2884 /* CullFace */],
                functions: {
                    depthFunc: [515 /* Lequal */],
                    depthMask: [true],
                    frontFace: [2305 /* CCW */],
                    cullFace: [1029 /* Back */],
                },
            };
            return states;
        };
        /**
         * @private
         */
        Shader.copyStates = function (source, target) {
            var sourceEnable = source.enable, sourceFunctions = source.functions;
            var enable = target.enable, functions = target.functions;
            if (enable) {
                enable.length = 0;
            }
            if (functions) {
                for (var k in functions) {
                    delete functions[k];
                }
            }
            if (sourceEnable) {
                if (!enable) {
                    enable = target.enable = [];
                }
                for (var _i = 0, sourceEnable_1 = sourceEnable; _i < sourceEnable_1.length; _i++) {
                    var value = sourceEnable_1[_i];
                    enable.push(value);
                }
            }
            if (sourceFunctions) {
                if (!functions) {
                    functions = target.functions = {};
                }
                for (var k in sourceFunctions) {
                    var sourceFunction = sourceFunctions[k];
                    functions[k] = Array.isArray(sourceFunction) ? sourceFunction.concat() : sourceFunction;
                }
            }
        };
        Shader.prototype.initialize = function (name, config, buffers, parent) {
            _super.prototype.initialize.call(this, name, config, null);
            if (parent) {
                // this.customs = parent.customs; TODO
                this._renderQueue = parent._renderQueue;
                this._defines = parent._defines ? parent._defines.concat() : undefined;
                this._states = parent._states; // TODO
            }
        };
        /**
         * @private
         */
        Shader.prototype.addDefine = function (defineString, value) {
            if (value !== undefined) {
                if (typeof value === "number") {
                    defineString += " " + value;
                }
                else {
                    this.customs = {};
                    var customs = this.customs;
                    for (var k in value) {
                        customs[k] = value[k];
                    }
                }
            }
            var defines = this._defines = this._defines || [];
            if (defines.indexOf(defineString) < 0) {
                defines.push(defineString);
            }
            return this;
        };
        /**
         * @private
         */
        Shader.prototype.addUniform = function (name, type, value) {
            var uniforms = this.config.extensions.KHR_techniques_webgl.techniques[0].uniforms;
            uniforms[name] = {
                type: type,
                value: value,
            };
            return this;
        };
        return Shader;
    }(egret3d.GLTFAsset));
    egret3d.Shader = Shader;
    __reflect(Shader.prototype, "egret3d.Shader");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 实体组。
     * - 根据匹配器收集指定特征的实体。
     */
    var Group = (function () {
        function Group(matcher) {
            /**
             * 标记改组是否为行为收集组，仅为兼容 Behaviour 生命周期。
             * @internal
             */
            this.isBehaviour = false;
            this._entitiesDirty = false;
            this._behavioursDirty = false;
            this._entityCount = 0;
            this._matcher = null;
            this._entities = [];
            this._behaviours = [];
            this._singleEntity = null;
            if (matcher.extraOfComponents.length === 1 && matcher.extraOfComponents[0] === paper.Behaviour) {
                this.isBehaviour = true;
            }
            this._matcher = matcher;
            for (var _i = 0, _a = paper.Application.sceneManager.scenes; _i < _a.length; _i++) {
                var scene = _a[_i];
                for (var _b = 0, _c = scene.entities; _b < _c.length; _b++) {
                    var entity = _c[_b];
                    this.handleEvent(entity, null, true); // TODO context._entityClass
                    // TODO extra component
                }
            }
        }
        /**
         * @internal
         */
        Group.create = function (matcher) {
            return new Group(matcher);
        };
        /**
         * 该组是否包含指定实体。
         * @param entity
         */
        Group.prototype.containsEntity = function (entity) {
            return this._entities.indexOf(entity) >= 0;
        };
        /**
         * @int
         * @param entity
         * @param component
         * @param isAdd
         */
        Group.prototype.handleEvent = function (entity, component, isAdd) {
            if (this.isBehaviour) {
                var componentClass = component.constructor;
                if (componentClass.isBehaviour) {
                    var behaviours = this._behaviours;
                    var index = behaviours.indexOf(component);
                    if (isAdd) {
                        if (index < 0) {
                            behaviours[behaviours.length] = component;
                            Group.onComponentEnabled.dispatch([this, component]);
                        }
                    }
                    else if (index >= 0) {
                        behaviours[index] = null;
                        this._behavioursDirty = true;
                        Group.onComponentDisabled.dispatch([this, component]);
                    }
                }
            }
            else {
                var matcher = this._matcher;
                var entities = this._entities;
                var index = entities.indexOf(entity);
                var componentClass = component ? component.constructor : null;
                switch (matcher.matches(entity, componentClass, isAdd, index >= 0)) {
                    case -2:
                        Group.onComponentDisabled.dispatch([this, component]);
                        break;
                    case -1:
                        entities[index] = null;
                        this._entitiesDirty = true;
                        this._entityCount--;
                        this._singleEntity = null;
                        Group.onEntityRemoved.dispatch([this, entity]);
                        break;
                    case 0:
                        break;
                    case 1:
                        entities[entities.length] = entity;
                        this._entityCount++;
                        this._singleEntity = entity;
                        Group.onEntityAdded.dispatch([this, entity]);
                        break;
                    case 2:
                        Group.onComponentEnabled.dispatch([this, component]);
                        break;
                }
            }
        };
        Object.defineProperty(Group.prototype, "entityCount", {
            /**
             * 该组匹配的实体总数。
             */
            get: function () {
                return this._entities.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "entities", {
            /**
             * 该组匹配的所有实体。
             */
            get: function () {
                var entities = this._entities;
                if (this._entitiesDirty) {
                    paper.utility.filterArray(entities, null);
                    this._entitiesDirty = false;
                }
                return entities;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "behaviours", {
            /**
             * 该组匹配的所有行为组件。
             * @internal
             */
            get: function () {
                var behaviours = this._behaviours;
                if (this._behavioursDirty) {
                    paper.utility.filterArray(behaviours, null);
                    this._behavioursDirty = false;
                }
                return this._behaviours;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "matcher", {
            /**
             * 该组的匹配器。
             */
            get: function () {
                return this._matcher;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "singleEntity", {
            /**
             * 该组匹配的单例实体。
             */
            get: function () {
                var entityCount = this._entityCount;
                if (this._entitiesDirty) {
                    paper.utility.filterArray(this._entities, null);
                    this._entitiesDirty = false;
                }
                if (entityCount === 0) {
                    return null;
                }
                else if (entityCount > 1) {
                    throw new Error();
                }
                return this._singleEntity;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        Group.prototype.hasGameObject = function (entity) {
            return this._entities.indexOf(entity) >= 0;
        };
        Object.defineProperty(Group.prototype, "gameObjects", {
            /**
             * @deprecated
             */
            get: function () {
                return this.entities;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 当实体添加到组时派发事件。
         */
        Group.onEntityAdded = new signals.Signal();
        /**
         * 当实体从组中移除时派发事件。
         */
        Group.onEntityRemoved = new signals.Signal();
        /**
         * 当组中实体添加非必要组件时派发事件。
         */
        Group.onComponentEnabled = new signals.Signal();
        /**
         * 当组中实体移除非必要组件时派发事件。
         */
        Group.onComponentDisabled = new signals.Signal();
        return Group;
    }());
    paper.Group = Group;
    __reflect(Group.prototype, "paper.Group");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 渲染纹理。
     */
    var RenderTexture = (function (_super) {
        __extends(RenderTexture, _super);
        function RenderTexture() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._bufferDirty = true;
            return _this;
        }
        RenderTexture.create = function (parametersOrName, config) {
            var name;
            var renderTexture;
            if (typeof parametersOrName === "string") {
                name = parametersOrName;
            }
            else {
                config = this._createConfig(parametersOrName);
                name = parametersOrName.name || "";
            }
            // Retargeting.
            renderTexture = new egret3d.RenderTexture();
            renderTexture.initialize(name, config, null);
            return renderTexture;
        };
        /**
         *
         * @param index
         */
        RenderTexture.prototype.activateTexture = function (index) {
            return this;
        };
        /**
         *
         * @param source
         */
        RenderTexture.prototype.uploadTexture = function (width, height) {
            width = Math.min(width, egret3d.renderState.maxTextureSize);
            height = Math.min(height, egret3d.renderState.maxTextureSize);
            this._sourceDirty = true;
            this._bufferDirty = true;
            this._levels = 0;
            this._gltfTexture.extensions.paper.width = width;
            this._gltfTexture.extensions.paper.height = height;
            return this;
        };
        RenderTexture.prototype.generateMipmap = function () { return false; };
        return RenderTexture;
    }(egret3d.BaseTexture));
    egret3d.RenderTexture = RenderTexture;
    __reflect(RenderTexture.prototype, "egret3d.RenderTexture");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpTriangleA = egret3d.Triangle.create();
    var _helpTriangleB = egret3d.Triangle.create();
    var _helpRaycastInfo = egret3d.RaycastInfo.create();
    var _attributeNames = [
        "POSITION" /* POSITION */,
        "NORMAL" /* NORMAL */,
        "TEXCOORD_0" /* TEXCOORD_0 */,
    ];
    /**
     * 网格资源。
     */
    var Mesh = (function (_super) {
        __extends(Mesh, _super);
        function Mesh() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._drawMode = 35044 /* Static */;
            _this._vertexCount = 0;
            _this._wireframeIndex = -1;
            _this._attributeNames = [];
            _this._attributeTypes = {};
            _this._glTFMesh = null;
            _this._inverseBindMatrices = null;
            _this._boneIndices = null;
            return _this;
        }
        Mesh.create = function (vertexCountOrName, indexCountOrConfig, attributeNamesOrBuffers, attributeTypes) {
            var name;
            var config;
            var buffers;
            var mesh;
            var indexCount = 0;
            //
            if (typeof vertexCountOrName === "number") {
                indexCount = indexCountOrConfig;
                //
                name = "";
                config = this._createConfig(vertexCountOrName, indexCount, attributeNamesOrBuffers || _attributeNames, attributeTypes || null);
                buffers = [new Uint32Array(config.bufferViews[0].byteLength / Uint32Array.BYTES_PER_ELEMENT)];
            }
            else {
                name = vertexCountOrName;
                config = indexCountOrConfig;
                buffers = attributeNamesOrBuffers;
            }
            // Retargeting.
            mesh = new egret3d.Mesh();
            mesh.initialize(name, config, buffers, attributeTypes || null);
            //
            if (indexCount > 0) {
                mesh.addSubMesh(indexCount, 0);
            }
            return mesh;
        };
        Mesh._createConfig = function (vertexCount, indexCount, attributeNames, attributeTypes) {
            var config = this.createConfig();
            config.buffers = [{ byteLength: 0 }];
            config.bufferViews = [{ buffer: 0, byteOffset: 0, byteLength: 0, target: 34962 /* ArrayBuffer */ }]; // VBO
            config.accessors = [];
            config.meshes = [{
                    primitives: [{ attributes: {} }],
                    extensions: { paper: {} },
                }];
            //
            var buffer = config.buffers[0];
            var vertexBufferView = config.bufferViews[0];
            var accessors = config.accessors;
            var attributes = config.meshes[0].primitives[0].attributes;
            //
            for (var _i = 0, attributeNames_1 = attributeNames; _i < attributeNames_1.length; _i++) {
                var attributeName = attributeNames_1[_i];
                var attributeType = this._getMeshAttributeType(attributeName, attributeTypes);
                var byteOffset = vertexBufferView.byteLength;
                vertexBufferView.byteLength += vertexCount * egret3d.GLTFAsset.getAccessorTypeCount(attributeType) * Float32Array.BYTES_PER_ELEMENT;
                attributes[attributeName] = accessors.length;
                accessors.push({
                    bufferView: 0,
                    byteOffset: byteOffset,
                    count: vertexCount,
                    normalized: attributeName === "NORMAL" /* NORMAL */ || attributeName === "TANGENT" /* TANGENT */,
                    componentType: 5126 /* Float */,
                    type: attributeType,
                });
            }
            buffer.byteLength = vertexBufferView.byteLength;
            //
            if (indexCount === 0) {
                config.meshes[0].primitives[0].material = 0;
            }
            return config;
        };
        Mesh._getMeshAttributeType = function (attributeName, customAttributeTypes) {
            if (customAttributeTypes && attributeName in customAttributeTypes) {
                return customAttributeTypes[attributeName];
            }
            switch (attributeName) {
                case "POSITION" /* POSITION */:
                case "NORMAL" /* NORMAL */:
                    return "VEC3" /* VEC3 */;
                case "TEXCOORD_0" /* TEXCOORD_0 */:
                case "TEXCOORD_1" /* TEXCOORD_1 */:
                    return "VEC2" /* VEC2 */;
                case "TANGENT" /* TANGENT */:
                case "COLOR_0" /* COLOR_0 */:
                case "COLOR_1" /* COLOR_1 */:
                case "JOINTS_0" /* JOINTS_0 */:
                case "WEIGHTS_0" /* WEIGHTS_0 */:
                    return "VEC4" /* VEC4 */;
                default:
                    throw new Error();
            }
        };
        Mesh.prototype.initialize = function (name, config, buffers, attributeTypes) {
            _super.prototype.initialize.call(this, name, config, buffers);
            var glTFMesh = this._glTFMesh = this.config.meshes[0];
            this._vertexCount = this.getAccessor(glTFMesh.primitives[0].attributes.POSITION || 0).count;
            for (var k in glTFMesh.primitives[0].attributes) {
                this._attributeNames.push(k);
            }
            if (attributeTypes) {
                for (var k in attributeTypes) {
                    this._attributeTypes[k] = attributeTypes[k];
                }
            }
            this.updateAccessorTypeCount();
        };
        Mesh.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            for (var k in this._attributeTypes) {
                delete this._attributeTypes[k];
            }
            this._drawMode = 35044 /* Static */;
            this._attributeNames.length = 0;
            // this._customAttributeTypes;
            this._glTFMesh = null;
            this._inverseBindMatrices = null;
            this._boneIndices = null;
            return true;
        };
        /**
         * 克隆该网格。
         */
        Mesh.prototype.clone = function () {
            // TODO
            var value = Mesh.create(this.vertexCount, 0, this._attributeNames, this._attributeTypes);
            value._drawMode = this._drawMode;
            for (var _i = 0, _a = this._glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                if (primitive.indices !== undefined) {
                    var accessor = this.getAccessor(primitive.indices);
                    value.addSubMesh(accessor.count, primitive.material, primitive.mode);
                }
            }
            var index = 0;
            for (var _b = 0, _c = this.config.bufferViews; _b < _c.length; _b++) {
                var bufferViewA = _c[_b];
                var bufferViewB = value.config.bufferViews[index++];
                var a = this.createTypeArrayFromBufferView(bufferViewA, 5125 /* UnsignedInt */);
                var b = value.createTypeArrayFromBufferView(bufferViewB, 5125 /* UnsignedInt */);
                for (var i = 0, l = a.length; i < l; ++i) {
                    b[i] = a[i];
                }
            }
            return value;
        };
        /**
         *
         */
        Mesh.prototype.applyMatrix = function (matrix) {
            var helpVector3 = egret3d.Vector3.create().release();
            var vertices = this.getVertices();
            var normals = this.getNormals();
            for (var i = 0, l = vertices.length; i < l; i += 3) {
                helpVector3.fromArray(vertices, i).applyMatrix(matrix).toArray(vertices, i);
            }
            if (normals) {
                var normalMatrix = egret3d.Matrix3.create().getNormalMatrix(matrix).release();
                for (var i = 0, l = normals.length; i < l; i += 3) {
                    helpVector3.fromArray(normals, i).applyMatrix3(normalMatrix).normalize().toArray(normals, i);
                }
            }
            return this;
        };
        /**
         *
         */
        Mesh.prototype.getTriangle = function (triangleIndex, out, vertices) {
            if (!out) {
                out = egret3d.Triangle.create();
            }
            var indices = this.getIndices();
            vertices = vertices || this.getVertices();
            if (indices) {
                var vertexOffset = triangleIndex * 3;
                out.fromArray(vertices, indices[vertexOffset + 0] * 3, indices[vertexOffset + 1] * 3, indices[vertexOffset + 2] * 3);
            }
            else {
                out.fromArray(vertices, triangleIndex * 9);
            }
            return out;
        };
        /**
         *
         */
        Mesh.prototype.raycast = function (ray, raycastInfo, vertices) {
            if (raycastInfo === void 0) { raycastInfo = null; }
            if (vertices === void 0) { vertices = null; }
            var subMeshIndex = 0;
            var helpTriangleA = _helpTriangleA;
            var helpTriangleB = _helpTriangleB;
            var helpRaycastInfo = _helpRaycastInfo;
            vertices = vertices || this.getVertices();
            var hit = false;
            for (var _i = 0, _a = this._glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                var indices = primitive.indices !== undefined ? this.getIndices(subMeshIndex) : null;
                switch (primitive.mode) {
                    case 0 /* Points */:
                        break;
                    case 1 /* Lines */:
                        break;
                    case 2 /* LineLoop */:
                        break;
                    case 3 /* LineStrip */:
                        break;
                    case 6 /* TrianglesFan */:
                        break;
                    case 5 /* TrianglesStrip */:
                        break;
                    case 4 /* Triangles */:
                    default:
                        if (indices) {
                            for (var i = 0, l = indices.length; i < l; i += 3) {
                                helpTriangleA.fromArray(vertices, indices[i] * 3, indices[i + 1] * 3, indices[i + 2] * 3);
                                if (raycastInfo) {
                                    helpRaycastInfo.backfaceCulling = raycastInfo.backfaceCulling;
                                    if (helpTriangleA.raycast(ray, helpRaycastInfo) &&
                                        (!hit || raycastInfo.distance > helpRaycastInfo.distance)) {
                                        raycastInfo.subMeshIndex = subMeshIndex;
                                        raycastInfo.triangleIndex = i / 3;
                                        raycastInfo.distance = helpRaycastInfo.distance;
                                        raycastInfo.position.copy(helpRaycastInfo.position);
                                        raycastInfo.coord.copy(helpRaycastInfo.coord);
                                        // raycastInfo.textureCoordB.copy(helpRaycastInfo.textureCoordB); TODO
                                        hit = true;
                                        if (raycastInfo.normal) {
                                            helpTriangleB.copy(helpTriangleA);
                                        }
                                    }
                                }
                                else if (helpTriangleA.raycast(ray)) {
                                    return true;
                                }
                            }
                        }
                        else {
                            for (var i = 0, l = vertices.length; i < l; i += 9) {
                                helpTriangleA.fromArray(vertices, i);
                                if (raycastInfo) {
                                    helpRaycastInfo.backfaceCulling = raycastInfo.backfaceCulling;
                                    if (helpTriangleA.raycast(ray, helpRaycastInfo)) {
                                        if (!hit || raycastInfo.distance > helpRaycastInfo.distance) {
                                            raycastInfo.subMeshIndex = subMeshIndex;
                                            raycastInfo.triangleIndex = i / 9;
                                            raycastInfo.distance = helpRaycastInfo.distance;
                                            raycastInfo.position.copy(helpRaycastInfo.position);
                                            raycastInfo.coord.copy(helpRaycastInfo.coord);
                                            // raycastInfo.textureCoordB.copy(helpRaycastInfo.textureCoordB); TODO
                                            hit = true;
                                            if (raycastInfo.normal) {
                                                helpTriangleB.copy(helpTriangleA);
                                            }
                                        }
                                    }
                                }
                                else if (helpTriangleA.raycast(ray)) {
                                    return true;
                                }
                            }
                        }
                        break;
                }
                subMeshIndex++;
            }
            if (hit && raycastInfo.normal) {
                var normal = raycastInfo.normal;
                // const normals = this.getNormals();
                // if (normals) {
                //     // TODO 三顶点的法线插值。
                //     const indices = this.getIndices();
                //     if (indices) {
                //         normal.fromArray(normals, indices[raycastInfo!.triangleIndex * 3] * 3);
                //     }
                //     else {
                //         normal.fromArray(normals, raycastInfo!.triangleIndex * 9);
                //     }
                // }
                // else {
                helpTriangleB.getNormal(normal);
                // }
            }
            return hit;
        };
        /**
         *
         */
        Mesh.prototype.addSubMesh = function (indexCount, materialIndex, randerMode) {
            if (materialIndex === void 0) { materialIndex = 0; }
            var accessors = this.config.accessors;
            var primitives = this.config.meshes[0].primitives;
            var subMeshIndex = this.buffers.length === primitives.length + 1 ? primitives.length : 0;
            var indexBufferView = this.config.bufferViews[subMeshIndex + 1] = {
                buffer: subMeshIndex + 1,
                byteOffset: 0,
                byteLength: indexCount * Uint16Array.BYTES_PER_ELEMENT,
                target: 34963 /* ElementArrayBuffer */,
            };
            var primitive = primitives[subMeshIndex] = primitives[subMeshIndex] || {
                attributes: primitives[0].attributes,
            };
            primitive.indices = accessors.length;
            primitive.material = materialIndex;
            primitive.mode = randerMode;
            accessors.push({
                bufferView: subMeshIndex + 1, byteOffset: 0,
                count: indexCount,
                typeCount: 1,
                componentType: 5123 /* UnsignedShort */, type: "SCALAR" /* SCALAR */,
            });
            this.buffers[subMeshIndex + 1] = new Uint16Array(indexBufferView.byteLength / Uint16Array.BYTES_PER_ELEMENT);
            this.config.buffers[subMeshIndex + 1] = { byteLength: indexBufferView.byteLength };
            return primitives.length - 1;
        };
        /**
         * 为该网格添加线框子网格。
         * @param materialIndex
         */
        Mesh.prototype.addWireframeSubMesh = function (materialIndex) {
            if (this._wireframeIndex < 0) {
                var index = 0;
                var wireframeIndices = [];
                for (var _i = 0, _a = this._glTFMesh.primitives; _i < _a.length; _i++) {
                    var primitive = _a[_i];
                    if (primitive.indices !== undefined) {
                        var indices = this.getIndices(index);
                        for (var i = 0, l = indices.length; i < l; i += 3) {
                            var a = indices[i + 0];
                            var b = indices[i + 1];
                            var c = indices[i + 2];
                            wireframeIndices.push(a, b, b, c, c, a);
                        }
                    }
                    else {
                        // TODO
                    }
                    index++;
                }
                if (wireframeIndices.length > 0) {
                    this._wireframeIndex = this.addSubMesh(wireframeIndices.length, materialIndex, 1 /* Lines */);
                    this.setIndices(wireframeIndices, this._wireframeIndex);
                }
            }
            return this;
        };
        /**
         * 删除该网格已添加的线框子网格。
         */
        Mesh.prototype.removeWireframeSubMesh = function () {
            if (this._wireframeIndex >= 0) {
                var primitives = this._glTFMesh.primitives;
                var primitive = primitives[this._wireframeIndex];
                // TODO 添加线框后，不能再添加 submesh
                primitives.splice(this._wireframeIndex, 1);
                this.buffers.splice(primitive.indices, 1);
                this._wireframeIndex = -1;
            }
            return this;
        };
        /**
         *
         */
        Mesh.prototype.normalizeNormals = function () {
            var normals = this.getNormals();
            if (normals) {
                var normal = egret3d.Vector3.create().release();
                for (var i = 0, l = normals.length; i < l; i += 3) {
                    normal.fromArray(normals, i).normalize().toArray(normals, i);
                }
                this.uploadVertexBuffer("NORMAL" /* NORMAL */);
            }
            return this;
        };
        /**
         *
         */
        Mesh.prototype.computeVertexNormals = function () {
            var normals = this.getNormals();
            if (normals) {
                var vertices = this.getVertices();
                var indices = this.getIndices();
                for (var i_1 = 0, l_1 = normals.length; i_1 < l_1; i_1++) {
                    normals[i_1] = 0.0;
                }
                var triangle = egret3d.Triangle.create().release();
                var normal = egret3d.Vector3.create().release();
                if (indices) {
                    for (var i = 0, l = indices.length; i < l; i += 3) {
                        var vA = indices[i + 0] * 3;
                        var vB = indices[i + 1] * 3;
                        var vC = indices[i + 2] * 3;
                        triangle.fromArray(vertices, vA, vB, vC);
                        triangle.getNormal(normal);
                        normals[vA] += normal.x;
                        normals[vA + 1] += normal.y;
                        normals[vA + 2] += normal.z;
                        normals[vB] += normal.x;
                        normals[vB + 1] += normal.y;
                        normals[vB + 2] += normal.z;
                        normals[vC] += normal.x;
                        normals[vC + 1] += normal.y;
                        normals[vC + 2] += normal.z;
                    }
                    this.normalizeNormals();
                }
                else {
                    for (var i_2 = 0, l_2 = vertices.length; i_2 < i_2; i_2 += 9) {
                        triangle.fromArray(vertices, i_2);
                        triangle.getNormal(normal);
                        normal.toArray(normals, i_2);
                        normal.toArray(normals, i_2 + 3);
                        normal.toArray(normals, i_2 + 6);
                    }
                    this.uploadVertexBuffer("NORMAL" /* NORMAL */);
                }
            }
            else {
                // TODO
            }
            return this;
        };
        /**
         * 获取该网格顶点的位置属性数据。
         * - x0, y0, z0, x1, y1, z1, ...
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点数。（默认全部顶点）
         */
        Mesh.prototype.getVertices = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("POSITION" /* POSITION */, offset, count);
        };
        /**
         * 获取该网格顶点的 UV 属性数据。
         * - u0, v0, u1, v1, ...
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点数。（默认全部顶点）
         */
        Mesh.prototype.getUVs = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */, offset, count);
        };
        /**
         * 获取该网格顶点的颜色属性数据。
         * - r0, g0, b0, a0, r1, g1, b1, a1, ...
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点数。（默认全部顶点）
         */
        Mesh.prototype.getColors = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("COLOR_0" /* COLOR_0 */, offset, count);
        };
        /**
         * 获取该网格顶点的法线属性数据。
         * - x0, y0, z0, x1, y1, z1, ...
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点数。（默认全部顶点）
         */
        Mesh.prototype.getNormals = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("NORMAL" /* NORMAL */, offset, count);
        };
        /**
         * 获取该网格顶点的切线属性数据。
         * - x0, y0, z0, w0,  x1, y1, z1, w1, ...
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点数。（默认全部顶点）
         */
        Mesh.prototype.getTangents = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("TANGENT" /* TANGENT */, offset, count);
        };
        /**
         * 获取该网格顶点的指定属性数据。
         * @param attributeType 属性名。
         * @param offset 顶点偏移。（默认从第一个点开始）
         * @param count 顶点总数。（默认全部顶点）
         */
        Mesh.prototype.getAttributes = function (attributeType, offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            var accessorIndex = this._glTFMesh.primitives[0].attributes[attributeType];
            if (accessorIndex === undefined) {
                return null;
            }
            return this.createTypeArrayFromAccessor(this.getAccessor(accessorIndex), offset, count);
        };
        /**
         * 设置该网格指定的顶点属性数据。
         * @param attributeType 属性名。
         * @param value 属性数据。
         * @param offset 顶点偏移。（默认从第一个点开始）
         */
        Mesh.prototype.setAttributes = function (attributeType, value, offset) {
            if (offset === void 0) { offset = 0; }
            var target = this.getAttributes(attributeType, offset);
            if (target) {
                for (var i = 0, l = Math.min(value.length, target.length); i < l; i++) {
                    target[i] = value[i];
                }
            }
            return target;
        };
        /**
         * 获取该网格的顶点索引数据。
         * @param subMeshIndex 子网格索引。（默认第一个子网格）
         */
        Mesh.prototype.getIndices = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var accessorIndex = this._glTFMesh.primitives[subMeshIndex].indices;
                if (accessorIndex === undefined) {
                    return null;
                }
                return this.createTypeArrayFromAccessor(this.getAccessor(accessorIndex));
            }
            console.warn("Error arguments.");
            return null;
        };
        /**
         * 设置该网格的顶点索引数据。
         * @param value 顶点索引数据。
         * @param subMeshIndex 子网格索引。（默认第一个子网格）
         * @param offset 索引偏移。（默认不偏移）
         */
        Mesh.prototype.setIndices = function (value, subMeshIndex, offset) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (offset === void 0) { offset = 0; }
            var target = this.getIndices(subMeshIndex);
            if (target) {
                for (var i = 0, l = Math.min(value.length, target.length); i < l; i++) {
                    target[i] = value[offset + i];
                }
            }
            return target;
        };
        Object.defineProperty(Mesh.prototype, "drawMode", {
            /**
             * 该网格的渲染模式。
             */
            get: function () {
                return this._drawMode;
            },
            set: function (value) {
                this._drawMode = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "subMeshCount", {
            /**
             * 该网格的子网格总数。
             */
            get: function () {
                return this._glTFMesh.primitives.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "vertexCount", {
            /**
             * 该网格的顶点总数。
             */
            get: function () {
                return this._vertexCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "attributeNames", {
            /**
             * 该网格的全部顶点属性名称。
             */
            get: function () {
                return this._attributeNames;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "glTFMesh", {
            /**
             * 获取该网格的 glTF 网格数据。
             */
            get: function () {
                return this._glTFMesh;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "boneIndices", {
            /**
             * @internal
             */
            get: function () {
                var config = this.config;
                if (!this._boneIndices && config.skins) {
                    var nodeIndices = this._boneIndices = {};
                    for (var _i = 0, _a = config.skins[0].joints; _i < _a.length; _i++) {
                        var joint = _a[_i];
                        var node = config.nodes[joint];
                        nodeIndices[node.name] = joint;
                    }
                }
                return this._boneIndices;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "inverseBindMatrices", {
            /**
             * @internal
             */
            get: function () {
                var config = this.config;
                if (!this._inverseBindMatrices && config.skins) {
                    // Mast be skinned mesh if has skin.
                    // Skinned mesh mast has inverseBindMatrices.
                    this._inverseBindMatrices = this.createTypeArrayFromAccessor(this.getAccessor(config.skins[0].inverseBindMatrices));
                }
                return this._inverseBindMatrices;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 当修改该网格的顶点属性后，调用此方法来更新顶点属性的缓冲区。
         * @param uploadAttributes
         * @param offset 顶点偏移。（默认不偏移）
         * @param count 顶点总数。（默认全部顶点）
         */
        Mesh.prototype.uploadVertexBuffer = function (uploadAttributes, offset, count) { };
        /**
         * 当修改该网格的顶点索引后，调用此方法来更新顶点索引的缓冲区。
         * @param subMeshIndex 子网格索引。（默认第一个子网格）
         */
        Mesh.prototype.uploadSubIndexBuffer = function (subMeshIndex, offset, count) { };
        return Mesh;
    }(egret3d.GLTFAsset));
    egret3d.Mesh = Mesh;
    __reflect(Mesh.prototype, "egret3d.Mesh", ["egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var webgl;
    (function (webgl_1) {
        var _browserPrefixes = [
            "",
            "MOZ_",
            "OP_",
            "WEBKIT_",
        ];
        function _getExtension(webgl, name) {
            for (var _i = 0, _browserPrefixes_1 = _browserPrefixes; _i < _browserPrefixes_1.length; _i++) {
                var prefixedName = _browserPrefixes_1[_i];
                var extension = webgl.getExtension(prefixedName + name);
                if (extension) {
                    return extension;
                }
            }
            return null;
        }
        function _getMaxShaderPrecision(webgl, precision) {
            if (precision === "highp") {
                if (webgl.getShaderPrecisionFormat(webgl.VERTEX_SHADER, webgl.HIGH_FLOAT).precision > 0 &&
                    webgl.getShaderPrecisionFormat(webgl.FRAGMENT_SHADER, webgl.HIGH_FLOAT).precision > 0) {
                    return "highp";
                }
                precision = "mediump";
            }
            if (precision === "mediump") {
                if (webgl.getShaderPrecisionFormat(webgl.VERTEX_SHADER, webgl.MEDIUM_FLOAT).precision > 0 &&
                    webgl.getShaderPrecisionFormat(webgl.FRAGMENT_SHADER, webgl.MEDIUM_FLOAT).precision > 0) {
                    return "mediump";
                }
            }
            return "lowp";
        }
        /**
         * @internal
         */
        function setTexturexParameters(type, sampler, anisotropy) {
            var webgl = WebGLRenderState.webgl;
            webgl.texParameteri(type, 10240 /* TEXTURE_MAG_FILTER */, sampler.magFilter);
            webgl.texParameteri(type, 10241 /* TEXTURE_MIN_FILTER */, sampler.minFilter);
            webgl.texParameteri(type, 10242 /* TEXTURE_WRAP_S */, sampler.wrapS);
            webgl.texParameteri(type, 10243 /* TEXTURE_WRAP_T */, sampler.wrapT);
            if (egret3d.renderState.textureFilterAnisotropic && anisotropy > 1) {
                webgl.texParameterf(type, egret3d.renderState.textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(anisotropy, egret3d.renderState.maxAnisotropy));
            }
        }
        webgl_1.setTexturexParameters = setTexturexParameters;
        /**
         * @internal
         */
        var WebGLRenderState = (function (_super) {
            __extends(WebGLRenderState, _super);
            function WebGLRenderState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            WebGLRenderState.prototype.initialize = function (config) {
                _super.prototype.initialize.call(this, config);
                WebGLRenderState.canvas = config.canvas;
                WebGLRenderState.webgl = config.webgl;
                var webgl = WebGLRenderState.webgl;
                if (!webgl) {
                    return;
                }
                var webglVersions = /^WebGL\ ([0-9])/.exec(webgl.getParameter(webgl.VERSION));
                this.version = webglVersions ? parseFloat(webglVersions[1]).toString() : "1";
                // use dfdx and dfdy must enable OES_standard_derivatives
                this.standardDerivativesEnabled = !!_getExtension(webgl, "OES_standard_derivatives");
                this.textureFloatEnabled = !!_getExtension(webgl, "OES_texture_float");
                this.fragDepthEnabled = !!_getExtension(webgl, "EXT_frag_depth");
                this.textureFilterAnisotropic = _getExtension(webgl, "EXT_texture_filter_anisotropic");
                this.shaderTextureLOD = _getExtension(webgl, "EXT_shader_texture_lod");
                //
                this.maxPrecision = _getMaxShaderPrecision(webgl, "highp");
                this.maxTextures = webgl.getParameter(webgl.MAX_TEXTURE_IMAGE_UNITS);
                this.maxVertexTextures = webgl.getParameter(webgl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
                this.maxTextureSize = webgl.getParameter(webgl.MAX_TEXTURE_SIZE);
                this.maxCubemapSize = webgl.getParameter(webgl.MAX_CUBE_MAP_TEXTURE_SIZE);
                this.maxRenderBufferize = webgl.getParameter(webgl.MAX_RENDERBUFFER_SIZE);
                this.maxVertexUniformVectors = webgl.getParameter(webgl.MAX_VERTEX_UNIFORM_VECTORS);
                this.maxBoneCount = this.textureFloatEnabled ? 1024 : Math.floor((this.maxVertexUniformVectors - 20) / 4);
                this.maxAnisotropy = (this.textureFilterAnisotropic !== null) ? webgl.getParameter(this.textureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
                //
                this._getCommonExtensions();
                this._getCommonDefines();
                //
                console.info("WebGL version:", this.version);
                console.info("Standard derivatives enabled:", this.standardDerivativesEnabled);
                console.info("Texture float enabled:", this.textureFloatEnabled);
                console.info("Frag depth enabled:", this.fragDepthEnabled);
                console.info("Texture filter anisotropic:", this.textureFilterAnisotropic);
                console.info("Shader texture LOD:", this.shaderTextureLOD);
                //
                console.info("Maximum shader precision:", this.maxPrecision);
                console.info("Maximum texture count:", this.maxTextures);
                console.info("Maximum vertex texture count:", this.maxVertexTextures);
                console.info("Maximum texture size:", this.maxTextureSize);
                console.info("Maximum cube map texture size:", this.maxCubemapSize);
                console.info("Maximum render buffer size:", this.maxRenderBufferize);
                console.info("Maximum vertex uniform vectors:", this.maxVertexUniformVectors);
                console.info("Maximum GPU skinned bone count:", this.maxBoneCount);
                console.info("Maximum anisotropy:", this.maxAnisotropy);
            };
            WebGLRenderState.prototype.updateRenderTarget = function (renderTarget) {
                if (this.renderTarget !== renderTarget) {
                    this.renderTarget = renderTarget;
                    if (renderTarget) {
                        renderTarget.activateTexture();
                    }
                    else {
                        var webgl_2 = WebGLRenderState.webgl;
                        webgl_2.bindFramebuffer(36160 /* FrameBuffer */, null);
                    }
                }
            };
            WebGLRenderState.prototype.updateViewport = function (viewport, renderTarget) {
                var webgl = WebGLRenderState.webgl;
                var currentViewport = this.viewport;
                var w;
                var h;
                if (renderTarget) {
                    w = renderTarget.width;
                    h = renderTarget.height;
                }
                else {
                    var stageViewport = egret3d.stage.viewport;
                    w = stageViewport.w;
                    h = stageViewport.h;
                }
                currentViewport.set(w * viewport.x, h * (1.0 - viewport.y - viewport.h), w * viewport.w, h * viewport.h); //TODO
                webgl.viewport(currentViewport.x, currentViewport.y, currentViewport.w, currentViewport.h);
            };
            WebGLRenderState.prototype.clearBuffer = function (bufferBit, clearColor) {
                var webgl = WebGLRenderState.webgl;
                if (bufferBit & 256 /* Depth */) {
                    webgl.depthMask(true);
                    webgl.clearDepth(1.0);
                }
                if (bufferBit & 1024 /* Stencil */) {
                    webgl.clearStencil(1.0);
                }
                if (bufferBit & 16384 /* Color */) {
                    clearColor && webgl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);
                }
                webgl.clear(bufferBit);
            };
            WebGLRenderState.prototype.copyFramebufferToTexture = function (screenPostion, target, level) {
                if (level === void 0) { level = 0; }
                var webgl = WebGLRenderState.webgl;
                target.bindTexture(0);
                webgl.copyTexImage2D(target.type, level, target.format, screenPostion.x, screenPostion.y, target.width, target.height, 0); //TODO
            };
            WebGLRenderState.prototype.updateState = function (state) {
                var webgl = WebGLRenderState.webgl;
                var stateEnables = this._stateEnables;
                var cacheStateEnable = this._cacheStateEnable;
                //
                for (var _i = 0, stateEnables_1 = stateEnables; _i < stateEnables_1.length; _i++) {
                    var e = stateEnables_1[_i];
                    var b = state ? state.enable && state.enable.indexOf(e) >= 0 : false;
                    if (cacheStateEnable[e] !== b) {
                        cacheStateEnable[e] = b;
                        b ? webgl.enable(e) : webgl.disable(e);
                    }
                }
                // Functions.
                if (state) {
                    var functions = state.functions;
                    if (functions) {
                        for (var k in functions) {
                            webgl[k].apply(webgl, functions[k]);
                        }
                    }
                }
            };
            /**
             * @deprecated
             */
            WebGLRenderState.canvas = null;
            /**
             * @deprecated
             */
            WebGLRenderState.webgl = null;
            return WebGLRenderState;
        }(egret3d.RenderState));
        webgl_1.WebGLRenderState = WebGLRenderState;
        __reflect(WebGLRenderState.prototype, "egret3d.webgl.WebGLRenderState");
        // Retargeting.
        egret3d.RenderState = WebGLRenderState;
    })(webgl = egret3d.webgl || (egret3d.webgl = {}));
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    var utility;
    (function (utility) {
        /**
         *
         * @param array
         */
        function filterArray(array, remove) {
            var index = 0;
            var removeCount = 0;
            for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
                var element = array_1[_i];
                if (element !== remove) {
                    if (removeCount > 0) {
                        array[index - removeCount] = element;
                        array[index] = null;
                    }
                }
                else {
                    removeCount++;
                }
                index++;
            }
            if (removeCount > 0) {
                array.length -= removeCount;
            }
        }
        utility.filterArray = filterArray;
    })(utility = paper.utility || (paper.utility = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @deprecated
     */
    paper.RenderQueue = egret3d.RenderQueue;
})(paper || (paper = {}));
var gltf;
(function (gltf) {
    /**
     * @deprecated
     */
    gltf.BlendMode = egret3d.BlendMode;
    /**
     * @deprecated
     */
    gltf.MeshAttributeType = gltf.AttributeSemantics;
})(gltf || (gltf = {}));
var egret3d;
(function (egret3d) {
    /**
     * @deprecated
     */
    egret3d.RAD_DEG = 57.29577951308232 /* RAD_DEG */;
    /**
     * @deprecated
     */
    egret3d.DEG_RAD = 0.017453292519943295 /* DEG_RAD */;
    /**
     * @deprecated
     */
    egret3d.EPSILON = 2.220446049250313e-16 /* EPSILON */;
    /**
     * @deprecated
     */
    egret3d.floatClamp = egret3d.math.clamp;
    /**
     * @deprecated
     */
    egret3d.numberLerp = egret3d.math.lerp;
    /**
     * @deprecated
     */
    egret3d.AABB = egret3d.Box;
    /**
     * @deprecated
     */
    egret3d.Matrix = egret3d.Matrix4;
    /**
     * @deprecated
     */
    egret3d.Prefab = paper.Prefab;
    /**
     * @deprecated
     */
    egret3d.RawScene = paper.RawScene;
    var RenderQueue;
    (function (RenderQueue) {
        /**
         * @deprecated
         */
        RenderQueue[RenderQueue["AlphaTest"] = 2450] = "AlphaTest";
        /**
         * @deprecated
         */
        RenderQueue[RenderQueue["Transparent"] = 3000] = "Transparent";
    })(RenderQueue = egret3d.RenderQueue || (egret3d.RenderQueue = {}));
    var BlendMode;
    (function (BlendMode) {
        /**
         * @deprecated
         */
        BlendMode[BlendMode["Blend"] = 2] = "Blend";
        /**
         * @deprecated
         */
        BlendMode[BlendMode["Blend_PreMultiply"] = 3] = "Blend_PreMultiply";
        /**
         * @deprecated
         */
        BlendMode[BlendMode["Add"] = 4] = "Add";
        /**
         * @deprecated
         */
        BlendMode[BlendMode["Add_PreMultiply"] = 5] = "Add_PreMultiply";
    })(BlendMode = egret3d.BlendMode || (egret3d.BlendMode = {}));
    /**
     * @deprecated
     * @internal
     */
    egret3d.WebGLCapabilities = egret3d.webgl.WebGLRenderState;
    /**
     * @deprecated
     */
    egret3d.InputManager = {
        /**
         * @deprecated
         * @see egret3d.inputCollecter
         */
        mouse: {
            /**
             * @deprecated
             * @see egret3d.inputCollecter.defaultPointer.isHold()
             */
            isPressed: function (button) {
                var buttons = [1 /* LeftMouse */, 4 /* MiddleMouse */, 2 /* RightMouse */];
                return egret3d.inputCollecter.defaultPointer.isHold(buttons[button]);
            },
            /**
             * @deprecated
             * @see egret3d.inputCollecter.defaultPointer.isDown()
             */
            wasPressed: function (button) {
                var buttons = [1 /* LeftMouse */, 4 /* MiddleMouse */, 2 /* RightMouse */];
                return egret3d.inputCollecter.defaultPointer.isDown(buttons[button]);
            },
            /**
             * @deprecated
             * @see egret3d.inputCollecter.defaultPointer.isUp()
             */
            wasReleased: function (button) {
                var buttons = [1 /* LeftMouse */, 4 /* MiddleMouse */, 2 /* RightMouse */];
                return egret3d.inputCollecter.defaultPointer.isUp(buttons[button]);
            },
        },
        /**
         * @deprecated
         * @see egret3d.inputCollecter
         */
        touch: {
            /**
             * @deprecated
             * @see egret3d.inputCollecter.defaultPointer
             */
            getTouch: function (button) {
                return egret3d.inputCollecter.getHoldPointers()[button];
            },
        },
        /**
         * @deprecated
         * @see egret3d.inputCollecter
         */
        keyboard: {
            /**
             * @deprecated
             * @see egret3d.inputCollecter.getKey()
             */
            isPressed: function (key) {
                return egret3d.inputCollecter.getKey(key).isHold();
            },
            /**
             * @deprecated
             * @see egret3d.inputCollecter.getKey()
             */
            wasPressed: function (key) {
                return egret3d.inputCollecter.getKey(key).isUp();
            },
        },
    };
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 脚本组件。
     * - 为了开发的便捷，允许使用脚本组件实现组件生命周期。
     * - 生命周期的顺序如下：
     * - onAwake();
     * - onReset();
     * - onEnable();
     * - onStart();
     * - onFixedUpdate();
     * - onUpdate();
     * - onAnimationEvent();
     * - onLateUpdate();
     * - onBeforeRender();
     * - onDisable();
     * - onDestroy();
     */
    var Behaviour = (function (_super) {
        __extends(Behaviour, _super);
        function Behaviour() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @internal
         */
        Behaviour.prototype._destroy = function () {
            if (paper.Application.playerMode !== 4 /* Editor */ || this.constructor.executeInEditMode) {
                if (this._lifeStates & 2 /* Awaked */) {
                    this.onDestroy && this.onDestroy();
                }
            }
            _super.prototype._destroy.call(this);
        };
        Behaviour.prototype.initialize = function (config) {
            if (paper.Application.playerMode !== 4 /* Editor */ || this.constructor.executeInEditMode) {
                this.gameObject = this.entity; //
                if (this.isActiveAndEnabled) {
                    this.onAwake && this.onAwake(config);
                    this._lifeStates |= 2 /* Awaked */;
                }
            }
            _super.prototype.initialize.call(this, config);
        };
        Behaviour.prototype.dispatchEnabledEvent = function (enabled) {
            if (paper.Application.playerMode !== 4 /* Editor */ || this.constructor.executeInEditMode) {
                if (enabled) {
                    if ((this._lifeStates & 2 /* Awaked */) === 0) {
                        this.onAwake && this.onAwake();
                        this._lifeStates |= 2 /* Awaked */;
                    }
                    this.onEnable && this.onEnable();
                }
                else {
                    this.onDisable && this.onDisable();
                }
            }
            _super.prototype.dispatchEnabledEvent.call(this, enabled);
        };
        /**
         * @internal
         */
        Behaviour.isBehaviour = true;
        Behaviour = __decorate([
            paper.abstract
        ], Behaviour);
        return Behaviour;
    }(paper.BaseComponent));
    paper.Behaviour = Behaviour;
    __reflect(Behaviour.prototype, "paper.Behaviour");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 全局时钟信息组件。
     */
    var Clock = (function (_super) {
        __extends(Clock, _super);
        function Clock() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 逻辑帧补偿速度
             */
            _this.tickCompensateSpeed = 3;
            /**
             * 逻辑帧时间(秒), 例如设置为 1.0 / 60.0 为每秒 60 帧
             */
            _this.tickInterval = 1.0 / 60.0;
            /**
             * 渲染帧时间(秒), 例如设置为 1.0 / 60.0 为每秒 60 帧
             */
            _this.frameInterval = 1.0 / 60.0;
            /**
             * 运行倍速
             *
             * 为了保证平滑的效果, 不会影响逻辑/渲染帧频
             */
            _this.timeScale = 1.0;
            /**
             * 程序启动后运行的总渲染帧数
             */
            _this._frameCount = 0;
            /**
             * 程序启动后运行的总逻辑帧数
             */
            _this._tickCount = 0;
            _this._beginTime = -1.0;
            _this._unscaledTime = 0.0;
            _this._unscaledDeltaTime = 0.0;
            _this._fixedTime = 0.0;
            _this._needReset = false;
            _this._unusedFrameDelta = 0.0;
            _this._unusedTickDelta = 0.0;
            return _this;
        }
        Clock.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            paper.Time = paper.clock = this;
        };
        /**
         * @internal
         * @returns 此次生成的渲染帧和逻辑帧数量, @see `ClockResult`
         */
        Clock.prototype.update = function (now) {
            now = now * 0.001;
            if (this._beginTime < 0) {
                this._beginTime = now;
            }
            if (this._needReset) {
                this._unscaledTime = now - this._beginTime;
                this._unscaledDeltaTime = 0;
                this._needReset = false;
                // 产生起始的渲染帧和逻辑帧
                this._tickCount++;
                this._frameCount++;
                return { frameCount: 1, tickCount: 1 };
            }
            // 计算和上此的间隔
            var lastTime = this._unscaledTime;
            this._unscaledTime = now - this._beginTime;
            this._unscaledDeltaTime = this._unscaledTime - lastTime;
            var returnValue = { frameCount: 0, tickCount: 0 };
            // 判断是否够一个逻辑帧
            if (this.tickInterval) {
                this._unusedTickDelta += this._unscaledDeltaTime;
                if (this._unusedTickDelta >= this.tickInterval) {
                    // 逻辑帧需要补帧, 最多一次补 `this.maxFixedSubSteps` 帧
                    while (this._unusedTickDelta >= this.tickInterval && returnValue.tickCount < this.tickCompensateSpeed) {
                        this._unusedTickDelta -= this.tickInterval;
                        returnValue.tickCount++;
                        this._tickCount++;
                    }
                }
            }
            else {
                returnValue.tickCount = 1;
                this._tickCount++;
            }
            // TOFIX: 暂时保护性处理, 如果没产生逻辑帧, 那么也不产生渲染帧
            if (!returnValue.tickCount) {
                return returnValue;
            }
            // 判断渲染帧
            if (this.frameInterval) {
                this._unusedFrameDelta += this._unscaledDeltaTime;
                if (this._unusedFrameDelta >= this.frameInterval) {
                    // 渲染帧不需要补帧
                    this._unusedFrameDelta = this._unusedFrameDelta % this.frameInterval;
                    returnValue.frameCount = 1;
                    this._frameCount++;
                }
            }
            else {
                returnValue.frameCount = 1;
                this._frameCount++;
            }
            return returnValue;
        };
        Object.defineProperty(Clock.prototype, "frameCount", {
            /**
             * 程序启动后运行的总渲染帧数
             */
            get: function () {
                return this._frameCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "tickCount", {
            /**
             * 程序启动后运行的总逻辑帧数
             */
            get: function () {
                return this._tickCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "now", {
            /**
             * 系统时间(毫秒)
             */
            get: function () {
                if (Date.now) {
                    return Date.now();
                }
                return new Date().getTime();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "time", {
            /**
             * 从程序开始运行时的累计时间(秒)
             */
            get: function () {
                return this._unscaledTime * this.timeScale;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "fixedTime", {
            /**
             *
             */
            get: function () {
                return this._fixedTime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "lastTickDelta", {
            /**
             * 此次逻辑帧的时长
             */
            get: function () {
                return (this.tickInterval || this._unscaledDeltaTime) * this.timeScale;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "lastFrameDelta", {
            /**
             * 此次渲染帧的时长
             */
            get: function () {
                return this._unscaledDeltaTime * this.timeScale;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "unscaledTime", {
            /**
             *
             */
            get: function () {
                return this._unscaledTime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "unscaledDeltaTime", {
            /**
             *
             */
            get: function () {
                return this._unscaledDeltaTime;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * reset
         */
        Clock.prototype.reset = function () {
            this._needReset = true;
        };
        /**
         * 时间戳
         *
         * 因为 `performance.now()` 精确度更高, 更应该使用它作为时间戳
         * , 但是这个 API 在微信小游戏里支持有问题, 所以暂时使用 `Date.now()` 的实现
         *
         * 关于 `Date.now()` 与 `performance.now()`
         *
         * * 两者都是以毫秒为单位
         * * `Date.now()` 是从 Unix 纪元 (1970-01-01T00:00:00Z) 至今的毫秒数, 而后者是从页面加载至今的毫秒数
         * * `Date.now()` 精确到毫秒, 一般是整数, 后者可以精确到 5 微秒 (理论上, 可能各平台各浏览器实现的不同), 为浮点数
         * * `Date.now()` 是 Javascript 的 API, 而后者为 Web API
         * * `window.requestAnimationFrame()` 回调中使用的时间戳可认为和 `performance.now()` 的基本一致, 区别只是它不是实时的 "now", 而是 `window.requestAnimationFrame()` 调用产生时的 "now"
         */
        Clock.prototype.timestamp = function () {
            return this.now;
        };
        return Clock;
    }(paper.Component));
    paper.Clock = Clock;
    __reflect(Clock.prototype, "paper.Clock");
    /**
     * 全局时钟信息组件实例。
     */
    paper.clock = null;
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 全局销毁信息收集组件。
     */
    var DisposeCollecter = (function (_super) {
        __extends(DisposeCollecter, _super);
        function DisposeCollecter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 缓存此帧销毁的全部场景。
             */
            _this.scenes = [];
            /**
             * 缓存此帧销毁的全部实体。
             */
            _this.entities = [];
            /**
             * 缓存此帧销毁的全部组件。
             */
            _this.components = [];
            /**
             * 缓存此帧结束时释放的对象。
             */
            _this.releases = [];
            /**
             * 缓存此帧结束时释放的资源。
             */
            _this.assets = [];
            return _this;
        }
        DisposeCollecter.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            paper.disposeCollecter = this;
        };
        DisposeCollecter = __decorate([
            paper.singleton
        ], DisposeCollecter);
        return DisposeCollecter;
    }(paper.Component));
    paper.DisposeCollecter = DisposeCollecter;
    __reflect(DisposeCollecter.prototype, "paper.DisposeCollecter");
    /**
     * 全局销毁信息收集组件实例。
     */
    paper.disposeCollecter = null;
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 几何球体。
     */
    var Sphere = (function (_super) {
        __extends(Sphere, _super);
        /**
         * 请使用 `egret3d.Sphere.create()` 创建实例。
         * @see egret3d.Sphere.create()
         */
        function Sphere() {
            var _this = _super.call(this) || this;
            /**
             * 球体半径。
             */
            _this.radius = 0.0;
            /**
             * 球体中心点。
             */
            _this.center = egret3d.Vector3.create();
            return _this;
        }
        /**
         * 创建一个几何球体。
         * @param center 球体中心点。
         * @param radius 球体半径。
         */
        Sphere.create = function (center, radius) {
            if (center === void 0) { center = egret3d.Vector3.ZERO; }
            if (radius === void 0) { radius = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(center, radius);
                instance._released = false;
                return instance;
            }
            return new Sphere().set(center, radius);
        };
        Sphere.prototype.serialize = function () {
            return [this.center.x, this.center.y, this.center.z, this.radius];
        };
        Sphere.prototype.deserialize = function (value) {
            this.radius = value[3];
            this.center.fromArray(value);
            return this;
        };
        Sphere.prototype.clone = function () {
            return Sphere.create(this.center, this.radius);
        };
        Sphere.prototype.copy = function (value) {
            return this.set(value.center, value.radius);
        };
        Sphere.prototype.set = function (center, radius) {
            this.radius = radius;
            this.center.copy(center);
            return this;
        };
        Sphere.prototype.applyMatrix = function (matrix) {
            this.center.applyMatrix(matrix);
            this.radius = this.radius * matrix.maxScaleOnAxis;
            return this;
        };
        /**
         * 根据点集设置球体信息。
         * @param points 点集。
         * @param center 中心点。（不设置则自动计算）
         */
        Sphere.prototype.fromPoints = function (points, center) {
            if (center) {
                this.center.copy(center);
            }
            else {
                this.center.copy(egret3d.helpBoxA.fromPoints(points).center);
            }
            var maxRadiusSqrt = 0.0;
            for (var i = 0, l = points.length; i < l; i++) {
                maxRadiusSqrt = Math.max(maxRadiusSqrt, this.center.getDistance(points[i]));
            }
            this.radius = Math.sqrt(maxRadiusSqrt);
            return this;
        };
        /**
         * 是否包含指定的点或其他球体。
         * @param value 点或球体。
         */
        Sphere.prototype.contains = function (value) {
            if (value instanceof Sphere) {
                var radiusDelta = this.radius - value.radius;
                if (radiusDelta >= 0.0) {
                    this.center.getSquaredDistance(value.center) <= (radiusDelta * radiusDelta);
                }
                return false;
            }
            return this.center.getSquaredDistance(value) <= this.radius * this.radius;
        };
        /**
         * 获取一个点到该球体的最近点。（如果该点在球体内部，则最近点就是该点）
         * @param point 一个点。
         * @param out 最近点。
         */
        Sphere.prototype.getClosestPointToPoint = function (point, out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            var squaredDistance = this.center.getSquaredDistance(point);
            if (squaredDistance > (this.radius * this.radius)) {
                out.subtract(this.center, point).normalize();
                out.multiplyScalar(this.radius).add(this.center);
            }
            else {
                out.copy(point);
            }
            return out;
        };
        /**
         * 获取一点到该球体表面的最近距离。
         * @param value 点。
         */
        Sphere.prototype.getDistance = function (value) {
            return this.center.getDistance(value) - this.radius;
        };
        Sphere.prototype.raycast = function (ray, raycastInfo) {
            if (raycastInfo === void 0) { raycastInfo = null; }
            var radius2 = this.radius * this.radius;
            var v1 = egret3d.helpVector3A.subtract(this.center, ray.origin);
            var tca = v1.dot(ray.direction);
            var d2 = v1.dot(v1) - tca * tca;
            if (d2 > radius2)
                return false;
            var thc = Math.sqrt(radius2 - d2);
            // t0 = first intersect point - entrance on front of sphere
            var t0 = tca - thc;
            // t1 = second intersect point - exit point on back of sphere
            var t1 = tca + thc;
            if (t0 < 0.0 || t1 < 0.0)
                return false;
            if (raycastInfo) {
                var position = ray.getPointAt(t0, raycastInfo.position);
                var normal = raycastInfo.normal;
                raycastInfo.distance = t0;
                if (normal) {
                    normal.subtract(position, this.center).normalize();
                }
            }
            return true;
        };
        Sphere._instances = [];
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], Sphere.prototype, "radius", void 0);
        __decorate([
            paper.editor.property("VECTOR3" /* VECTOR3 */)
        ], Sphere.prototype, "center", void 0);
        return Sphere;
    }(paper.BaseRelease));
    egret3d.Sphere = Sphere;
    __reflect(Sphere.prototype, "egret3d.Sphere", ["paper.ICCS", "paper.ISerializable", "egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var EnableSystem = (function (_super) {
        __extends(EnableSystem, _super);
        function EnableSystem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EnableSystem.prototype.onAwake = function (config) {
            var globalEntity = paper.Application.sceneManager.globalEntity;
            globalEntity.addComponent(paper.Clock);
            globalEntity.addComponent(paper.DisposeCollecter);
            paper.clock.tickInterval = config.tickRate > 0 ? 1.0 / config.tickRate : 0;
            paper.clock.frameInterval = config.frameRate > 0 ? 1.0 / config.frameRate : 0;
            console.info("Tick rate: ", config.tickRate > 0 ? config.tickRate : "Auto");
            console.info("Frame rate: ", config.frameRate > 0 ? config.frameRate : "Auto");
        };
        return EnableSystem;
    }(paper.BaseSystem));
    paper.EnableSystem = EnableSystem;
    __reflect(EnableSystem.prototype, "paper.EnableSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var StartSystem = (function (_super) {
        __extends(StartSystem, _super);
        function StartSystem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        StartSystem.prototype.getMatchers = function () {
            return [
                paper.Matcher.create().extraOf(paper.Behaviour)
            ];
        };
        StartSystem.prototype.onComponentAdded = function (component) {
            if (component._lifeStates & 8 /* Started */) {
                return;
            }
            if (paper.Application.playerMode === 4 /* Editor */ &&
                !component.constructor.executeInEditMode) {
                return;
            }
            component._lifeStates |= 8 /* Started */;
            component.onStart && component.onStart();
        };
        return StartSystem;
    }(paper.BaseSystem));
    paper.StartSystem = StartSystem;
    __reflect(StartSystem.prototype, "paper.StartSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 固定更新系统。
     * TODO
     */
    var FixedUpdateSystem = (function (_super) {
        __extends(FixedUpdateSystem, _super);
        function FixedUpdateSystem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FixedUpdateSystem.prototype.getMatchers = function () {
            return [
                paper.Matcher.create().extraOf(paper.Behaviour)
            ];
        };
        FixedUpdateSystem.prototype.onTick = function (delta) {
            var behaviours = this.groups[0].behaviours;
            for (var _i = 0, behaviours_1 = behaviours; _i < behaviours_1.length; _i++) {
                var behaviour = behaviours_1[_i];
                if (!behaviour || (behaviour._lifeStates & 8 /* Started */) === 0) {
                    continue;
                }
                behaviour.onFixedUpdate && behaviour.onFixedUpdate(delta);
            }
        };
        return FixedUpdateSystem;
    }(paper.BaseSystem));
    paper.FixedUpdateSystem = FixedUpdateSystem;
    __reflect(FixedUpdateSystem.prototype, "paper.FixedUpdateSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var UpdateSystem = (function (_super) {
        __extends(UpdateSystem, _super);
        function UpdateSystem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        UpdateSystem.prototype.getMatchers = function () {
            return [
                paper.Matcher.create().extraOf(paper.Behaviour)
            ];
        };
        UpdateSystem.prototype.onFrame = function (deltaTime) {
            for (var _i = 0, _a = this.groups[0].behaviours; _i < _a.length; _i++) {
                var behaviour = _a[_i];
                if (!behaviour || (behaviour._lifeStates & 8 /* Started */) === 0) {
                    continue;
                }
                behaviour.onUpdate && behaviour.onUpdate(deltaTime);
            }
        };
        return UpdateSystem;
    }(paper.BaseSystem));
    paper.UpdateSystem = UpdateSystem;
    __reflect(UpdateSystem.prototype, "paper.UpdateSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * Late 更新系统。
     */
    var LateUpdateSystem = (function (_super) {
        __extends(LateUpdateSystem, _super);
        function LateUpdateSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._laterCalls = [];
            return _this;
        }
        LateUpdateSystem.prototype.getMatchers = function () {
            return [
                paper.Matcher.create().extraOf(paper.Behaviour)
            ];
        };
        LateUpdateSystem.prototype.onFrame = function (deltaTime) {
            for (var _i = 0, _a = this.groups[0].behaviours; _i < _a.length; _i++) {
                var behaviour = _a[_i];
                if (!behaviour || (behaviour._lifeStates & 8 /* Started */) === 0) {
                    continue;
                }
                behaviour.onLateUpdate && behaviour.onLateUpdate(deltaTime);
            }
            //
            egret.ticker.update(); // TODO 帧频
            //
            var laterCalls = this._laterCalls;
            if (laterCalls.length > 0) {
                for (var _b = 0, laterCalls_1 = laterCalls; _b < laterCalls_1.length; _b++) {
                    var callback = laterCalls_1[_b];
                    callback();
                }
                laterCalls.length = 0;
            }
        };
        /**
         * @deprecated
         */
        LateUpdateSystem.prototype.callLater = function (callback) {
            this._laterCalls.push(callback);
        };
        return LateUpdateSystem;
    }(paper.BaseSystem));
    paper.LateUpdateSystem = LateUpdateSystem;
    __reflect(LateUpdateSystem.prototype, "paper.LateUpdateSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var DisableSystem = (function (_super) {
        __extends(DisableSystem, _super);
        function DisableSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._cacheEntities = [];
            _this._cacheComponents = [];
            _this._disposeCollecter = paper.Application.sceneManager.globalEntity.getComponent(paper.DisposeCollecter);
            return _this;
        }
        DisableSystem.prototype.onAwake = function () {
            var _this = this;
            var scenes = this._disposeCollecter.scenes;
            paper.Scene.onSceneDestroyed.add(function (scene) {
                scenes.push(scene);
            });
            paper.Entity.onEntityDestroyed.add(function (entity) {
                _this._cacheEntities.push(entity);
            });
            paper.Component.onComponentDestroyed.add(function (_a) {
                var entity = _a[0], component = _a[1];
                _this._cacheComponents.push(component);
            });
        };
        DisableSystem.prototype.onTickCleanup = function () {
            var _a = this._disposeCollecter, scenes = _a.scenes, entities = _a.entities, components = _a.components, releases = _a.releases, assets = _a.assets;
            var _b = this, _cacheEntities = _b._cacheEntities, _cacheComponents = _b._cacheComponents;
            if (components.length > 0) {
                for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {
                    var component = components_1[_i];
                    component.uninitialize();
                }
                components.length = 0;
            }
            if (entities.length > 0) {
                for (var _c = 0, entities_1 = entities; _c < entities_1.length; _c++) {
                    var entity = entities_1[_c];
                    entity.uninitialize();
                }
                entities.length = 0;
            }
            if (scenes.length > 0) {
                for (var _d = 0, scenes_1 = scenes; _d < scenes_1.length; _d++) {
                    var scene = scenes_1[_d];
                    scene.uninitialize();
                }
                scenes.length = 0;
            }
            if (releases.length > 0) {
                for (var _e = 0, releases_1 = releases; _e < releases_1.length; _e++) {
                    var instance = releases_1[_e];
                    var instances = instance.constructor._instances; // TODO
                    instance.onClear && instance.onClear();
                    instances.push(instance);
                }
                releases.length = 0;
            }
            if (assets.length > 0) {
                for (var _f = 0, assets_1 = assets; _f < assets_1.length; _f++) {
                    var asset = assets_1[_f];
                    if (asset.onReferenceCountChange(true)) {
                        console.debug("Auto dispose GPU memory.", asset.name);
                    }
                }
                assets.length = 0;
            }
            if (_cacheEntities.length > 0) {
                for (var _g = 0, _cacheEntities_1 = _cacheEntities; _g < _cacheEntities_1.length; _g++) {
                    var entity = _cacheEntities_1[_g];
                    entities.push(entity);
                }
                _cacheEntities.length = 0;
            }
            if (_cacheComponents.length > 0) {
                for (var _h = 0, _cacheComponents_1 = _cacheComponents; _h < _cacheComponents_1.length; _h++) {
                    var component = _cacheComponents_1[_h];
                    components.push(component);
                }
                _cacheComponents.length = 0;
            }
        };
        return DisableSystem;
    }(paper.BaseSystem));
    paper.DisableSystem = DisableSystem;
    __reflect(DisableSystem.prototype, "paper.DisableSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    var KEY_UUID = "uuid";
    var KEY_ASSET = "asset";
    var KEY_CLASS = "class";
    var KEY_DESERIALIZE = "deserialize";
    var KEY_COMPONENTS = "components";
    var KEY_EXTRAS = "extras";
    var KEY_CHILDREN = "children";
    // const KEY_MISSINGOBJECT: keyof MissingComponent = 'missingObject';
    function _getDeserializedKeys(serializedClass, keys) {
        if (keys === void 0) { keys = {}; }
        var serializeKeys = serializedClass.__serializeKeys;
        if (serializeKeys) {
            keys = keys;
            for (var k in serializeKeys) {
                keys[k] = serializeKeys[k] || k;
            }
        }
        if (serializedClass.prototype && serializedClass.prototype.__proto__.constructor !== Object) {
            _getDeserializedKeys(serializedClass.prototype.__proto__.constructor, keys);
        }
        return keys;
    }
    function _getDeserializedIgnoreKeys(serializedClass, keys) {
        if (keys === void 0) { keys = null; }
        if (serializedClass.__deserializeIgnore) {
            keys = keys || [];
            for (var _i = 0, _a = serializedClass.__deserializeIgnore; _i < _a.length; _i++) {
                var key = _a[_i];
                keys.push(key);
            }
        }
        if (serializedClass.prototype && serializedClass.prototype.__proto__.constructor !== Object) {
            _getDeserializedIgnoreKeys(serializedClass.prototype.__proto__.constructor, keys);
        }
        return keys;
    }
    /**
     *
     */
    var Deserializer = (function () {
        function Deserializer() {
            /**
             *
             */
            this.assets = [];
            /**
             *
             */
            this.objects = {};
            /**
             *
             */
            this.components = {};
            this.root = null;
            this._deserializers = {};
            this._prefabRootMap = {};
            this._rootTarget = null;
        }
        /**
         *
         * @param target
         * @param propName
         */
        Deserializer.propertyHasGetterAndSetter = function (target, propName) {
            var prototype = Object.getPrototypeOf(target);
            while (prototype) {
                var descriptror = Object.getOwnPropertyDescriptor(prototype, propName);
                if (descriptror && descriptror.get && descriptror.set) {
                    return true;
                }
                prototype = Object.getPrototypeOf(prototype);
            }
            return false;
        };
        Deserializer.prototype._deserializeObject = function (source, target) {
            var deserializedKeys = _getDeserializedKeys(target.constructor);
            var deserializedIgnoreKeys = _getDeserializedIgnoreKeys(target.constructor);
            for (var k in source) {
                if (k === KEY_CLASS) {
                    continue;
                }
                if (k === KEY_EXTRAS) {
                    continue;
                }
                if (!this._keepUUID && k === KEY_UUID) {
                    continue;
                }
                // if (k === KEY_MISSINGOBJECT) { // 丢失的对象数据直接赋值。 TODO
                //     (target as any)[k] = source[k];
                //     continue;
                // }
                var retargetKey = (deserializedKeys && k in deserializedKeys) ? deserializedKeys[k] : k; // 重定向反序列化 key。
                if (deserializedIgnoreKeys && deserializedIgnoreKeys.indexOf(retargetKey) >= 0) {
                    continue;
                }
                var hasGetterAndSetter = Deserializer.propertyHasGetterAndSetter(target, retargetKey);
                var rawRetarget = target[retargetKey];
                var retarget = this._deserializeChild(source[k], (hasGetterAndSetter && rawRetarget && (rawRetarget.constructor === Array || rawRetarget.constructor === Object)) ? null : rawRetarget);
                if (retarget === undefined) {
                    continue;
                }
                target[retargetKey] = retarget;
            }
            return target;
        };
        Deserializer.prototype._deserializeComponent = function (componentSource, source, target) {
            var className = paper.serializeClassMap[componentSource.class] || componentSource.class; // TODO 废弃 serializeClassMap。
            var clazz = egret.getDefinitionByName(className);
            var componentTarget = undefined;
            if (clazz) {
                var hasLink = KEY_EXTRAS in componentSource && componentSource[KEY_EXTRAS].linkedID;
                if (clazz === egret3d.Transform) {
                    componentTarget = this.components[componentSource.uuid];
                    if (KEY_CHILDREN in componentSource) {
                        for (var _i = 0, _a = componentSource[KEY_CHILDREN]; _i < _a.length; _i++) {
                            var childUUID = _a[_i];
                            var child = this.components[childUUID.uuid];
                            if (child && child.parent !== componentTarget) {
                                componentTarget._addChild(child);
                            }
                        }
                    }
                }
                else {
                    if (hasLink) {
                        var componentExtras = componentSource[KEY_EXTRAS];
                        var extras = source[KEY_EXTRAS];
                        var linkedID = componentExtras.linkedID;
                        var prefabDeserializer = this._deserializers[extras.prefab ? source.uuid : extras.rootID];
                        componentTarget = prefabDeserializer.components[linkedID];
                    }
                    else {
                        paper.Component.createDefaultEnabled = componentSource._enabled === undefined ? true : componentSource._enabled;
                        componentTarget = (target || this._rootTarget).addComponent(clazz);
                    }
                    // if (clazz === Behaviour) { TODO
                    //     (componentTarget as Behaviour)._isReseted = true;
                    // }
                }
                if (!hasLink && this._makeLink && componentTarget) {
                    componentTarget.extras.linkedID = componentSource.uuid;
                }
            }
            else {
                componentTarget = target.addComponent(paper.MissingComponent);
                componentTarget.missingObject = componentSource;
                if (true) {
                    console.warn("Class " + className + " is not defined.");
                }
            }
            this.components[componentSource.uuid] = componentTarget;
            return componentTarget;
        };
        Deserializer.prototype._deserializeChild = function (source, target) {
            if (target === void 0) { target = null; }
            if (source === null || source === undefined) {
                return source;
            }
            switch (typeof source) {
                case "function":
                    return undefined;
                case "object": {
                    if (target) {
                        if (ArrayBuffer.isView(target)) {
                            for (var i = 0, l = Math.min(source.length, target.length); i < l; ++i) {
                                target[i] = source[i];
                            }
                            return target;
                        }
                        else if (Array.isArray(target) && target.length === 0) {
                            for (var i = 0, l = source.length; i < l; ++i) {
                                target[i] = this._deserializeChild(source[i]);
                            }
                            return target;
                        }
                        else if (target[KEY_DESERIALIZE]) {
                            return target.deserialize(source, this);
                        }
                        else {
                            // console.info("Deserialize can be optimized."); TODO
                        }
                    }
                    if (Array.isArray(source)) {
                        target = [];
                        for (var i = 0, l = source.length; i < l; ++i) {
                            target[i] = this._deserializeChild(source[i]);
                        }
                        return target;
                    }
                    var classCodeOrName = source[KEY_CLASS];
                    if (KEY_ASSET in source) {
                        var assetIndex = source.asset;
                        if (assetIndex >= 0) {
                            // TODO 资源获取不到时，对应返回的资源方案
                            // 材质应返回 MISSING
                            // 纹理应返回 MISSING
                            // Shader 
                            // Mesh
                            // ...
                            return paper.Asset.find(this.assets[assetIndex]);
                        }
                        return null;
                    }
                    else if (KEY_UUID in source) {
                        var uuid = source.uuid;
                        if (uuid in this.objects) {
                            return this.objects[uuid];
                        }
                        else if (uuid in this.components) {
                            return this.components[uuid];
                        }
                        else if (classCodeOrName) {
                            var scene = (this._rootTarget instanceof paper.Entity ? this._rootTarget.scene : this._rootTarget);
                            if ((paper.serializeClassMap[classCodeOrName] || classCodeOrName) === egret.getQualifiedClassName(paper.GameObject)) {
                                for (var _i = 0, _a = scene.entities; _i < _a.length; _i++) {
                                    var entity = _a[_i];
                                    if (entity.uuid === uuid) {
                                        return entity;
                                    }
                                }
                            }
                            else {
                                for (var _b = 0, _c = scene.entities; _b < _c.length; _b++) {
                                    var entity = _c[_b];
                                    for (var _d = 0, _e = entity.components; _d < _e.length; _d++) {
                                        var component = _e[_d];
                                        if (component && component.uuid === uuid) {
                                            return component;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else if (classCodeOrName) {
                        var clazz = egret.getDefinitionByName(paper.serializeClassMap[classCodeOrName] || classCodeOrName);
                        if (clazz) {
                            target = new clazz();
                            return target.deserialize(source, this);
                        }
                    }
                    else {
                        target = {};
                        for (var k in source) {
                            target[k] = this._deserializeChild(source[k]);
                        }
                        return target;
                    }
                    console.warn("Deserialize error.", source);
                    return undefined;
                }
                default:
                    return source;
            }
        };
        Deserializer.prototype.getAssetOrComponent = function (source) {
            if (KEY_ASSET in source) {
                var assetIndex = source.asset;
                if (assetIndex >= 0) {
                    return paper.Asset.find(this.assets[assetIndex]);
                }
                return null;
            }
            var uuid = source.uuid;
            return this.components[uuid] || this.objects[uuid];
        };
        /**
         * @private
         */
        Deserializer.prototype.deserialize = function (data, keepUUID, makeLink, rootTarget) {
            if (keepUUID === void 0) { keepUUID = false; }
            if (makeLink === void 0) { makeLink = false; }
            if (rootTarget === void 0) { rootTarget = null; }
            if (data.assets) {
                for (var _i = 0, _a = data.assets; _i < _a.length; _i++) {
                    var assetName = _a[_i];
                    this.assets.push(assetName);
                }
            }
            this._keepUUID = keepUUID;
            this._makeLink = makeLink;
            this._rootTarget = rootTarget;
            var sceneClassName = egret.getQualifiedClassName(paper.Scene);
            var transformClassName = egret.getQualifiedClassName(egret3d.Transform);
            var components = {};
            var root = null;
            if (data.components) {
                for (var _b = 0, _c = data.components; _b < _c.length; _b++) {
                    var componentSource = _c[_b];
                    components[componentSource.uuid] = componentSource;
                }
            }
            if (data.objects) {
                for (var _d = 0, _e = data.objects; _d < _e.length; _d++) {
                    var source = _e[_d];
                    var className = paper.serializeClassMap[source.class] || source.class;
                    var target = undefined;
                    if (className === sceneClassName) {
                        target = paper.Scene.createEmpty(source.name);
                        this._rootTarget = target;
                    }
                    else {
                        if (!this._rootTarget) {
                            this._rootTarget = paper.Application.sceneManager.activeScene; // TODO
                        }
                        var hasLink = KEY_EXTRAS in source && source[KEY_EXTRAS].linkedID;
                        if (hasLink) {
                            var extras = source[KEY_EXTRAS];
                            var linkedID = extras.linkedID;
                            var prefab = extras.prefab;
                            if (prefab) {
                                var assetIndex = prefab.asset;
                                if (assetIndex >= 0) {
                                    var assetName = this.assets[assetIndex];
                                    target = paper.Prefab.create(assetName, this._rootTarget);
                                    if (target) {
                                        this._deserializers[source.uuid] = Deserializer._lastDeserializer;
                                        this._prefabRootMap[source.uuid] = { rootUUID: target.uuid, root: target };
                                    }
                                    else {
                                        target = paper.GameObject.create("Missing Prefab" /* MissingPrefab */, "Untagged" /* Untagged */, this._rootTarget);
                                    }
                                }
                            }
                            else {
                                var prefabDeserializer = this._deserializers[extras.rootID];
                                target = prefabDeserializer.objects[linkedID];
                            }
                        }
                        else {
                            target = paper.GameObject.create("NoName" /* NoName */, "Untagged" /* Untagged */, this._rootTarget);
                            if (this._makeLink) {
                                target.extras.linkedID = source.uuid;
                                if (root) {
                                    target.extras.rootID = root.uuid;
                                }
                            }
                        }
                        if (target && KEY_COMPONENTS in source) {
                            for (var _f = 0, _g = source[KEY_COMPONENTS]; _f < _g.length; _f++) {
                                var componentUUID = _g[_f];
                                var uuid = componentUUID.uuid;
                                var componentSource = components[uuid];
                                if ((paper.serializeClassMap[componentSource.class] || componentSource.class) === transformClassName) {
                                    this.components[uuid] = target.transform;
                                }
                            }
                        }
                    }
                    if (target) {
                        this.objects[source.uuid] = target;
                        root = root || target;
                    }
                }
                var i = data.objects.length;
                while (i--) {
                    var source = data.objects[i];
                    var target = this.objects[source.uuid];
                    if (target) {
                        this._deserializeObject(source, target); // 场景或实体属性反序列化。
                        if (target instanceof paper.Entity && KEY_COMPONENTS in source) {
                            for (var _h = 0, _j = source[KEY_COMPONENTS]; _h < _j.length; _h++) {
                                var componentUUID = _j[_h];
                                this._deserializeComponent(components[componentUUID.uuid], source, target);
                            }
                        }
                    }
                }
                // 重新设置 rootID（只有编辑模式需要处理该内容）
                if (paper.Application.playerMode === 4 /* Editor */) {
                    // 重新设置rootid的值
                    for (var uuid in this._prefabRootMap) {
                        var rootDeser = this._deserializers[uuid];
                        for (var key in rootDeser.objects) {
                            var obj = rootDeser.objects[key];
                            if (obj instanceof paper.Entity) {
                                if (obj.extras.linkedID && obj.extras.rootID === this._prefabRootMap[uuid].rootUUID) {
                                    obj.extras.rootID = this._prefabRootMap[uuid].root.uuid;
                                }
                            }
                        }
                    }
                }
            }
            if (data.components) {
                for (var _k = 0, _l = data.components; _k < _l.length; _k++) {
                    var componentSource = _l[_k];
                    var uuid = componentSource.uuid;
                    var component = this.components[uuid];
                    if (component) {
                        if (component.constructor === paper.MissingComponent &&
                            componentSource[KEY_CLASS].indexOf(component.constructor.name) < 0 // TODO
                        ) {
                            continue;
                        }
                        this._deserializeObject(componentSource, component);
                    }
                    else if (rootTarget && rootTarget instanceof paper.Entity) {
                        component = this._deserializeComponent(componentSource);
                        root = root || component;
                        this._deserializeObject(componentSource, component);
                    }
                }
            }
            Deserializer._lastDeserializer = this;
            this.root = root;
            return root;
        };
        return Deserializer;
    }());
    paper.Deserializer = Deserializer;
    __reflect(Deserializer.prototype, "paper.Deserializer");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @private
     */
    paper.DATA_VERSION = "5";
    /**
     * @private
     */
    paper.DATA_VERSIONS = [paper.DATA_VERSION];
    var KEY_SERIALIZE = "serialize";
    var KEY_ENTITIES = "entities";
    var KEY_COMPONENTS = "components";
    // const KEY_EXTRAS: keyof GameObject = "extras";
    var KEY_CHILDREN = "children";
    var _inline = false;
    var _serializeds = [];
    var _deserializers = {};
    var _ignoreKeys = ["extras"];
    var _rootIgnoreKeys = ["name", "localPosition", "localRotation", "extras"];
    var _serializeData = null;
    var _defaultGameObject = null;
    /**
     * @private
     */
    function serialize(source, inline) {
        if (inline === void 0) { inline = false; }
        if (_serializeData) {
            console.error("The deserialization is not complete.");
        }
        if (!_defaultGameObject) {
            _defaultGameObject = paper.GameObject.create("NoName" /* NoName */, "Untagged" /* Untagged */, paper.Application.sceneManager.globalScene);
            _defaultGameObject.enabled = false;
        }
        _inline = inline;
        _serializeData = { version: paper.DATA_VERSION, assets: [], objects: [], components: [] };
        _serializeObject(source);
        _serializeds.length = 0;
        for (var k in _deserializers) {
            delete _deserializers[k];
        }
        _defaultGameObject.destroy();
        _defaultGameObject = null;
        var serializeData = _serializeData;
        _serializeData = null;
        return serializeData;
    }
    paper.serialize = serialize;
    /**
     * @private
     */
    function clone(object) {
        var data = serialize(object, true);
        var deserializer = new paper.Deserializer();
        return deserializer.deserialize(data);
    }
    paper.clone = clone;
    /**
     * @private
     */
    function equal(source, target) {
        var typeSource = typeof source;
        var typeTarget = typeof target;
        if (typeSource !== typeTarget) {
            return false;
        }
        if (source === null && target === null) {
            return true;
        }
        if (source === null || target === null) {
            return false;
        }
        switch (typeSource) {
            case "undefined":
            case "boolean":
            case "number":
            case "string":
            case "symbol":
            case "function":
                return source === target;
            case "object":
            default:
                break;
        }
        if ((Array.isArray(source) || ArrayBuffer.isView(source)) &&
            (Array.isArray(target) || ArrayBuffer.isView(target))) {
            var sl = source.length;
            if (sl !== target.length) {
                return false;
            }
            if (sl === 0) {
                return true;
            }
            for (var i = 0; i < sl; ++i) {
                if (!equal(source[i], target[i])) {
                    return false;
                }
            }
            return true;
        }
        if (source.constructor !== target.constructor) {
            return false;
        }
        if (source instanceof paper.Asset ||
            source instanceof paper.Entity ||
            source instanceof paper.Component) {
            return source === target;
        }
        if (source.constructor === Object) {
            for (var k in source) {
                if (!equal(source[k], target[k])) {
                    return false;
                }
            }
            return true;
        }
        // if (source[KEY_SERIALIZE] !== null) {
        if (KEY_SERIALIZE in source) {
            return equal(source.serialize(), target.serialize());
        }
        if (source instanceof paper.BaseObject) {
            return equal(serializeStruct(source), serializeStruct(target));
        }
        throw new Error("Unsupported data.");
    }
    paper.equal = equal;
    /**
     * @private
     */
    function serializeAsset(source) {
        if (!source.name) {
            return { asset: -1 };
        }
        if (_serializeData) {
            var assets = _serializeData.assets;
            var index = assets.indexOf(source.name);
            if (index < 0) {
                index = assets.length;
                assets.push(source.name);
            }
            return { asset: index };
        }
        return { asset: -1 };
    }
    paper.serializeAsset = serializeAsset;
    /**
     * 创建指定对象的结构体。
     */
    function serializeStruct(source) {
        var className = egret.getQualifiedClassName(source);
        var target = { class: className };
        _serializeChildren(source, target, null, null);
        return target;
    }
    paper.serializeStruct = serializeStruct;
    function _getSerializedKeys(serializedClass, keys) {
        if (keys === void 0) { keys = {}; }
        var serializeKeys = serializedClass.__serializeKeys;
        if (serializeKeys) {
            for (var k in serializeKeys) {
                keys[k] = serializeKeys[k] || k;
            }
        }
        if (serializedClass.prototype && serializedClass.prototype.__proto__.constructor !== Object) {
            _getSerializedKeys(serializedClass.prototype.__proto__.constructor, keys);
        }
        return keys;
    }
    function _serializeReference(source) {
        var className = egret.getQualifiedClassName(source);
        return { uuid: source.uuid, class: className };
    }
    function _getPrefabRoot(gameObject) {
        while (!gameObject.extras.prefab) {
            gameObject = gameObject.parent;
        }
        return gameObject;
    }
    function _serializeObject(source) {
        if (_serializeds.indexOf(source.uuid) >= 0) {
            return true;
        }
        var target = _serializeReference(source);
        var ignoreKeys = _ignoreKeys;
        var equalTemplate = null;
        if (source instanceof paper.Entity) {
            if (source.isDestroyed) {
                console.warn("Missing game object.");
                return false;
            }
            if (source.extras && source.extras.linkedID) {
                var rootPrefabObject = source instanceof paper.GameObject ? _getPrefabRoot(source) : source;
                var prefabName = rootPrefabObject.extras.prefab.name;
                if (!(prefabName in _deserializers)) {
                    var prefabGameObject = paper.Prefab.create(prefabName, _defaultGameObject.scene);
                    prefabGameObject.parent = _defaultGameObject;
                    _deserializers[prefabName] = paper.Deserializer._lastDeserializer;
                }
                var deserializer = _deserializers[prefabName];
                equalTemplate = deserializer.objects[source.extras.linkedID];
                if (source.extras.prefab) {
                    ignoreKeys = _rootIgnoreKeys;
                }
            }
            else {
                equalTemplate = _defaultGameObject;
            }
            _serializeData.objects.push(target);
        }
        else if (source instanceof paper.Component) {
            if (source.isDestroyed) {
                console.warn("Missing component.");
                return false;
            }
            if (source.hideFlags & 4 /* DontSave */) {
                return false;
            }
            if (source.extras && source.extras.linkedID) {
                var rootPrefabObject = source.entity instanceof paper.GameObject ? _getPrefabRoot(source.entity) : source.entity;
                var prefabName = rootPrefabObject.extras.prefab.name;
                if (!(prefabName in _deserializers)) {
                    var prefabGameObject = paper.Prefab.create(prefabName, _defaultGameObject.scene);
                    prefabGameObject.parent = _defaultGameObject;
                    _deserializers[prefabName] = paper.Deserializer._lastDeserializer;
                }
                var deserializer = _deserializers[prefabName];
                equalTemplate = deserializer.components[source.extras.linkedID];
                if (source.entity.extras.prefab) {
                    ignoreKeys = _rootIgnoreKeys;
                }
            }
            else {
                equalTemplate = _defaultGameObject.getOrAddComponent(source.constructor);
            }
            _serializeData.components.push(target);
        }
        else {
            _serializeData.objects.push(target);
        }
        _serializeds.push(source.uuid);
        _serializeChildren(source, target, equalTemplate, ignoreKeys);
        return true;
    }
    function _serializeChildren(source, target, equalTemplate, ignoreKeys) {
        var serializedKeys = _getSerializedKeys(source.constructor);
        if (serializedKeys) {
            for (var k in serializedKeys) {
                if (equalTemplate &&
                    (!ignoreKeys || ignoreKeys.indexOf(k) < 0) &&
                    equal(source[k], equalTemplate[k])) {
                    continue;
                }
                target[k] = _serializeChild(source[k], source, k);
            }
        }
    }
    function _serializeChild(source, parent, key) {
        if (source === null || source === undefined) {
            return source;
        }
        switch (typeof source) {
            case "function":
                return undefined;
            case "object": {
                if (Array.isArray(source) || ArrayBuffer.isView(source)) {
                    var target = [];
                    for (var _i = 0, _a = source; _i < _a.length; _i++) {
                        var element = _a[_i];
                        var result = _serializeChild(element, parent, key);
                        if (result !== undefined) {
                            target.push(result);
                        }
                    }
                    return target;
                }
                if (source.constructor === Object) {
                    var target = {};
                    for (var k in source) {
                        var result = _serializeChild(source[k], parent, key);
                        if (result !== undefined) {
                            target[k] = result;
                        }
                    }
                    return target;
                }
                // if (source[KEY_SERIALIZE] !== null) {
                if (KEY_SERIALIZE in source) {
                    return source.serialize();
                }
                if (source instanceof paper.BaseObject) {
                    if (source instanceof paper.Scene) {
                        return undefined; // Pass.
                    }
                    if (source instanceof paper.Asset) {
                        return serializeAsset(source);
                    }
                    if (source instanceof paper.Entity || source instanceof paper.Component) {
                        if (source instanceof paper.Entity && (source.hideFlags & 4 /* DontSave */)) {
                            return undefined; // Pass.
                        }
                        if (source instanceof paper.Component && (source.hideFlags & 4 /* DontSave */)) {
                            return undefined; // Pass.
                        }
                        if (parent) {
                            if (parent instanceof paper.Scene) {
                                if (key === KEY_ENTITIES) {
                                    return _serializeObject(source) ? { uuid: source.uuid } : undefined; // Pass.
                                }
                            }
                            else if (parent instanceof paper.Entity) {
                                if (key === KEY_COMPONENTS) {
                                    return _serializeObject(source) ? { uuid: source.uuid } : undefined; // Pass.
                                }
                            }
                            else if (parent instanceof paper.BaseTransform) {
                                if (key === KEY_CHILDREN) {
                                    return _serializeObject(source.entity) ? { uuid: source.uuid } : undefined; // Pass.
                                }
                            }
                        }
                        return _serializeReference(source);
                    }
                    return serializeStruct(source);
                }
                console.error("Serialize error.", source);
                return undefined; // Pass.
            }
            default:
                return source;
        }
    }
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @deprecated
     */
    paper.CullingMask = paper.Layer;
    /**
     * @deprecated
     * @internal
     */
    paper.serializeClassMap = {
        0: "paper.Scene",
        1: "paper.GameObject",
        2: "egret3d.AniPlayer",
        3: "egret3d.BoxCollider",
        4: "egret3d.Camera",
        5: "egret3d.MeshFilter",
        6: "egret3d.MeshRenderer",
        7: "egret3d.particle.ParticleComponent",
        8: "egret3d.particle.ParticleRenderer",
        9: "egret3d.SkinnedMeshRenderer",
        10: "egret3d.SphereCollider",
        11: "egret3d.Transform",
        12: "egret3d.Shader",
        15: "egret3d.AnimationClip",
        16: "egret3d.TPoseInfo",
        17: "egret3d.PoseBoneMatrix",
        18: "egret3d.Texture",
        19: "egret3d.Texture",
        20: "egret3d.Vector2",
        21: "egret3d.Vector3",
        22: "egret3d.Vector4",
        23: "egret3d.Quaternion",
        24: "egret3d.Color",
        25: "egret3d.Gradient",
        26: "egret3d.Curve",
        27: "egret3d.Keyframe",
        28: "egret3d.Rect",
        29: "egret3d.MainModule",
        30: "egret3d.EmissionModule",
        31: "egret3d.ShapeModule",
        32: "egret3d.VelocityOverLifetimeModule",
        33: "egret3d.RotationOverLifetimeModule",
        34: "egret3d.ColorOverLifetimeModule",
        35: "egret3d.SizeOverLifetimeModule",
        36: "egret3d.MinMaxCurve",
        37: "egret3d.MinMaxGradient",
        38: "egret3d.alphaKey",
        39: "egret3d.colorKey",
        40: "egret3d.Animation",
        41: "egret3d.GLTFAsset",
        //
        13: "paper.Compatible",
        14: "paper.Compatible",
    };
    /**
     * @deprecated
     * @internal
     */
    var Compatible = (function () {
        function Compatible() {
        }
        Compatible.prototype.serialize = function () {
            throw new Error("Never");
        };
        Compatible.prototype.deserialize = function (element, data) {
            if (!data) {
                throw new Error("Never");
            }
            return data.getAssetOrComponent(element._glTFAsset);
        };
        return Compatible;
    }());
    paper.Compatible = Compatible;
    __reflect(Compatible.prototype, "paper.Compatible", ["paper.ISerializable"]);
    /**
     * @deprecated
     * @see paper.singleton
     */
    var SingletonComponent = (function (_super) {
        __extends(SingletonComponent, _super);
        function SingletonComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SingletonComponent = __decorate([
            paper.singleton
        ], SingletonComponent);
        return SingletonComponent;
    }(paper.BaseComponent));
    paper.SingletonComponent = SingletonComponent;
    __reflect(SingletonComponent.prototype, "paper.SingletonComponent");
    paper.GameObjectGroup = paper.Group;
    /**
     * @deprecated
     */
    /**
     * @deprecated
     * @see paper.clock
     */
    paper.Time = null;
    /**
     * @deprecated
     */
    var InterestType;
    (function (InterestType) {
        InterestType[InterestType["Extends"] = 1] = "Extends";
        InterestType[InterestType["Exculde"] = 2] = "Exculde";
        InterestType[InterestType["Unessential"] = 4] = "Unessential";
    })(InterestType = paper.InterestType || (paper.InterestType = {}));
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * Shader 通用宏定义。
     */
    var ShaderDefine;
    (function (ShaderDefine) {
        //
        ShaderDefine["TONE_MAPPING"] = "TONE_MAPPING";
        ShaderDefine["GAMMA_FACTOR"] = "GAMMA_FACTOR";
        ShaderDefine["USE_LOGDEPTHBUF"] = "USE_LOGDEPTHBUF";
        ShaderDefine["USE_LOGDEPTHBUF_EXT"] = "USE_LOGDEPTHBUF_EXT";
        //
        ShaderDefine["USE_COLOR"] = "USE_COLOR";
        ShaderDefine["USE_MAP"] = "USE_MAP";
        ShaderDefine["USE_ALPHAMAP"] = "USE_ALPHAMAP";
        ShaderDefine["USE_AOMAP"] = "USE_AOMAP";
        ShaderDefine["USE_BUMPMAP"] = "USE_BUMPMAP";
        ShaderDefine["USE_NORMALMAP"] = "USE_NORMALMAP";
        ShaderDefine["USE_SPECULARMAP"] = "USE_SPECULARMAP";
        ShaderDefine["USE_ROUGHNESSMAP"] = "USE_ROUGHNESSMAP";
        ShaderDefine["USE_METALNESSMAP"] = "USE_METALNESSMAP";
        ShaderDefine["USE_DISPLACEMENTMAP"] = "USE_DISPLACEMENTMAP";
        ShaderDefine["USE_EMISSIVEMAP"] = "USE_EMISSIVEMAP";
        ShaderDefine["USE_ENVMAP"] = "USE_ENVMAP";
        ShaderDefine["USE_LIGHTMAP"] = "USE_LIGHTMAP";
        ShaderDefine["USE_SHADOWMAP"] = "USE_SHADOWMAP";
        ShaderDefine["USE_SKINNING"] = "USE_SKINNING";
        ShaderDefine["USE_SIZEATTENUATION"] = "USE_SIZEATTENUATION";
        ShaderDefine["TOON"] = "TOON";
        ShaderDefine["STANDARD"] = "STANDARD";
        //
        ShaderDefine["TEXTURE_LOD_EXT"] = "TEXTURE_LOD_EXT";
        //
        ShaderDefine["ENVMAP_TYPE_CUBE"] = "ENVMAP_TYPE_CUBE";
        ShaderDefine["ENVMAP_TYPE_CUBE_UV"] = "ENVMAP_TYPE_CUBE_UV";
        ShaderDefine["ENVMAP_TYPE_EQUIREC"] = "ENVMAP_TYPE_EQUIREC";
        ShaderDefine["ENVMAP_TYPE_SPHERE"] = "ENVMAP_TYPE_SPHERE";
        ShaderDefine["ENVMAP_MODE_REFRACTION"] = "ENVMAP_MODE_REFRACTION";
        ShaderDefine["ENVMAP_BLENDING_MULTIPLY"] = "ENVMAP_BLENDING_MULTIPLY";
        ShaderDefine["ENVMAP_BLENDING_MIX"] = "ENVMAP_BLENDING_MIX";
        ShaderDefine["ENVMAP_BLENDING_ADD"] = "ENVMAP_BLENDING_ADD";
        //
        ShaderDefine["FLAT_SHADED"] = "FLAT_SHADED";
        //
        ShaderDefine["MAX_BONES"] = "MAX_BONES";
        ShaderDefine["BONE_TEXTURE"] = "BONE_TEXTURE";
        //
        ShaderDefine["NUM_DIR_LIGHTS"] = "NUM_DIR_LIGHTS";
        ShaderDefine["NUM_POINT_LIGHTS"] = "NUM_POINT_LIGHTS";
        ShaderDefine["NUM_RECT_AREA_LIGHTS"] = "NUM_RECT_AREA_LIGHTS";
        ShaderDefine["NUM_SPOT_LIGHTS"] = "NUM_SPOT_LIGHTS";
        ShaderDefine["NUM_HEMI_LIGHTS"] = "NUM_HEMI_LIGHTS";
        ShaderDefine["NUM_CLIPPING_PLANES"] = "NUM_CLIPPING_PLANES";
        ShaderDefine["UNION_CLIPPING_PLANES"] = "UNION_CLIPPING_PLANES";
        //
        ShaderDefine["SHADOWMAP_TYPE_PCF"] = "SHADOWMAP_TYPE_PCF";
        ShaderDefine["SHADOWMAP_TYPE_PCF_SOFT"] = "SHADOWMAP_TYPE_PCF_SOFT";
        ShaderDefine["DEPTH_PACKING_3200"] = "DEPTH_PACKING 3200";
        ShaderDefine["DEPTH_PACKING_3201"] = "DEPTH_PACKING 3201";
        //
        ShaderDefine["FLIP_SIDED"] = "FLIP_SIDED";
        ShaderDefine["DOUBLE_SIDED"] = "DOUBLE_SIDED";
        ShaderDefine["PREMULTIPLIED_ALPHA"] = "PREMULTIPLIED_ALPHA";
        //
        ShaderDefine["USE_FOG"] = "USE_FOG";
        ShaderDefine["FOG_EXP2"] = "FOG_EXP2";
        //
        ShaderDefine["FLIP_V"] = "FLIP_V";
    })(ShaderDefine = egret3d.ShaderDefine || (egret3d.ShaderDefine = {}));
    /**
     * Shader 通用 Uniform 名称。
     */
    var ShaderUniformName;
    (function (ShaderUniformName) {
        ShaderUniformName["Diffuse"] = "diffuse";
        ShaderUniformName["Opacity"] = "opacity";
        ShaderUniformName["Size"] = "size";
        ShaderUniformName["Map"] = "map";
        ShaderUniformName["AlphaMap"] = "alphaMap";
        ShaderUniformName["AOMap"] = "aoMap";
        ShaderUniformName["BumpMap"] = "bumpMap";
        ShaderUniformName["NormalMap"] = "normalMap";
        ShaderUniformName["SpecularMap"] = "specularMap";
        ShaderUniformName["GradientMap"] = "gradientMap";
        ShaderUniformName["RoughnessMap"] = "roughnessMap";
        ShaderUniformName["MetalnessMap"] = "metalnessMap";
        ShaderUniformName["DisplacementMap"] = "displacementMap";
        ShaderUniformName["EnvMap"] = "envMap";
        ShaderUniformName["EmissiveMap"] = "emissiveMap";
        ShaderUniformName["CubeMap"] = "tCube";
        ShaderUniformName["EquirectMap"] = "tEquirect";
        ShaderUniformName["Flip"] = "tFlip";
        ShaderUniformName["UVTransform"] = "uvTransform";
        ShaderUniformName["Reflectivity"] = "reflectivity";
        ShaderUniformName["RefractionRatio"] = "refractionRatio";
        ShaderUniformName["Specular"] = "specular";
        ShaderUniformName["Shininess"] = "shininess";
        ShaderUniformName["BumpScale"] = "bumpScale";
        ShaderUniformName["NormalScale"] = "normalScale";
        ShaderUniformName["Roughness"] = "roughness";
        ShaderUniformName["Metalness"] = "metalness";
        ShaderUniformName["Emissive"] = "emissive";
        ShaderUniformName["EmissiveIntensity"] = "emissiveIntensity";
        ShaderUniformName["FlipEnvMap"] = "flipEnvMap";
        ShaderUniformName["MaxMipLevel"] = "maxMipLevel";
        ShaderUniformName["Rotation"] = "rotation";
        ShaderUniformName["Scale2D"] = "scale2D";
        ShaderUniformName["Center"] = "center";
    })(ShaderUniformName = egret3d.ShaderUniformName || (egret3d.ShaderUniformName = {}));
    /**
     * Shader宏定义排序。
     */
    var ShaderDefineOrder;
    (function (ShaderDefineOrder) {
        ShaderDefineOrder[ShaderDefineOrder["GammaFactor"] = 1] = "GammaFactor";
        ShaderDefineOrder[ShaderDefineOrder["DecodingFun"] = 2] = "DecodingFun";
        ShaderDefineOrder[ShaderDefineOrder["EncodingFun"] = 3] = "EncodingFun";
    })(ShaderDefineOrder = egret3d.ShaderDefineOrder || (egret3d.ShaderDefineOrder = {}));
    /**
     *
     */
    var HumanoidMask;
    (function (HumanoidMask) {
        HumanoidMask[HumanoidMask["Head"] = 0] = "Head";
        HumanoidMask[HumanoidMask["Body"] = 1] = "Body";
        HumanoidMask[HumanoidMask["LeftArm"] = 2] = "LeftArm";
        HumanoidMask[HumanoidMask["RightArm"] = 3] = "RightArm";
        HumanoidMask[HumanoidMask["LeftHand"] = 4] = "LeftHand";
        HumanoidMask[HumanoidMask["RightHand"] = 5] = "RightHand";
        HumanoidMask[HumanoidMask["LeftLeg"] = 6] = "LeftLeg";
        HumanoidMask[HumanoidMask["RightLeg"] = 7] = "RightLeg";
        HumanoidMask[HumanoidMask["LeftHandIK"] = 8] = "LeftHandIK";
        HumanoidMask[HumanoidMask["RightHandIK"] = 9] = "RightHandIK";
        HumanoidMask[HumanoidMask["LeftFootIK"] = 10] = "LeftFootIK";
        HumanoidMask[HumanoidMask["RightFootIK"] = 11] = "RightFootIK";
    })(HumanoidMask = egret3d.HumanoidMask || (egret3d.HumanoidMask = {}));
    /**
     *
     */
    var HumanoidJoint;
    (function (HumanoidJoint) {
        HumanoidJoint["Heck"] = "H_Neck";
        HumanoidJoint["Head"] = "H_Head";
        HumanoidJoint["LeftEye"] = "H_LeftEye";
        HumanoidJoint["RightEye"] = "H_RightEye";
        HumanoidJoint["Jaw"] = "H_Jaw";
        HumanoidJoint["Hips"] = "B_Hips";
        HumanoidJoint["Spine"] = "B_Spine";
        HumanoidJoint["Chest"] = "B_Chest";
        HumanoidJoint["UpperChest"] = "B_UpperChest";
        HumanoidJoint["LeftShoulder"] = "LA_Shoulder";
        HumanoidJoint["LeftUpperArm"] = "LA_UpperArm";
        HumanoidJoint["LeftLowerArm"] = "LA_LowerArm";
        HumanoidJoint["LeftHand"] = "LA_Hand";
        HumanoidJoint["RightShoulder"] = "RA_Shoulder";
        HumanoidJoint["RightUpperArm"] = "RA_UpperArm";
        HumanoidJoint["RightLowerArm"] = "RA_LowerArm";
        HumanoidJoint["RightHand"] = "RA_Hand";
        HumanoidJoint["LeftUpperLeg"] = "LL_UpperLeg";
        HumanoidJoint["LeftLowerLeg"] = "LL_LowerLeg";
        HumanoidJoint["LeftFoot"] = "LL_Foot";
        HumanoidJoint["LeftToes"] = "LL_Toes";
        HumanoidJoint["RightUpperLeg"] = "RL_UpperLeg";
        HumanoidJoint["RightLowerLeg"] = "RL_LowerLeg";
        HumanoidJoint["RightFoot"] = "RL_Foot";
        HumanoidJoint["RightToes"] = "RL_Toes";
        HumanoidJoint["LeftThumbProximal"] = "LH_ThumbProximal";
        HumanoidJoint["LeftThumbIntermediate"] = "LH_ThumbIntermediate";
        HumanoidJoint["LeftThumbDistal"] = "LH_ThumbDistal";
        HumanoidJoint["LeftIndexProximal"] = "LH_IndexProximal";
        HumanoidJoint["LeftIndexIntermediate"] = "LH_IndexIntermediate";
        HumanoidJoint["LeftIndexDistal"] = "LH_IndexDistal";
        HumanoidJoint["LeftMiddleProximal"] = "LH_MiddleProximal";
        HumanoidJoint["LeftMiddleIntermediate"] = "LH_MiddleIntermediate";
        HumanoidJoint["LeftMiddleDistal"] = "LH_MiddleDistal";
        HumanoidJoint["LeftRingProximal"] = "LH_RingProximal";
        HumanoidJoint["LeftRingIntermediate"] = "LH_RingIntermediate";
        HumanoidJoint["LeftRingDistal"] = "LH_RingDistal";
        HumanoidJoint["LeftLittleProximal"] = "LH_LittleProximal";
        HumanoidJoint["LeftLittleIntermediate"] = "LH_LittleIntermediate";
        HumanoidJoint["LeftLittleDistal"] = "LH_LittleDistal";
        HumanoidJoint["RightThumbProximal"] = "RH_ThumbProximal";
        HumanoidJoint["RightThumbIntermediate"] = "RH_ThumbIntermediate";
        HumanoidJoint["RightThumbDistal"] = "RH_ThumbDistal";
        HumanoidJoint["RightIndexProximal"] = "RH_IndexProximal";
        HumanoidJoint["RightIndexIntermediate"] = "RH_IndexIntermediate";
        HumanoidJoint["RightIndexDistal"] = "RH_IndexDistal";
        HumanoidJoint["RightMiddleProximal"] = "RH_MiddleProximal";
        HumanoidJoint["RightMiddleIntermediate"] = "RH_MiddleIntermediate";
        HumanoidJoint["RightMiddleDistal"] = "RH_MiddleDistal";
        HumanoidJoint["RightRingProximal"] = "RH_RingProximal";
        HumanoidJoint["RightRingIntermediate"] = "RH_RingIntermediate";
        HumanoidJoint["RightRingDistal"] = "RH_RingDistal";
        HumanoidJoint["RightLittleProximal"] = "RH_LittleProximal";
        HumanoidJoint["RightLittleIntermediate"] = "RH_LittleIntermediate";
        HumanoidJoint["RightLittleDistal"] = "RH_LittleDistal";
    })(HumanoidJoint = egret3d.HumanoidJoint || (egret3d.HumanoidJoint = {}));
    /**
     * TODO
     * @internal
     */
    egret3d.TextureDecodingFunction = {
        "map": "mapTexelToLinear",
        "envMap": "envMapTexelToLinear",
        "emissiveMap": "emissiveMapTexelToLinear",
    };
    /**
     * TODO
     * @internal
     */
    egret3d.ShaderTextureDefine = {
        "map": "USE_MAP" /* USE_MAP */,
        "alphaMap": "USE_ALPHAMAP" /* USE_ALPHAMAP */,
        "aoMap": "USE_AOMAP" /* USE_AOMAP */,
        "bumpMap": "USE_BUMPMAP" /* USE_BUMPMAP */,
        "normalMap": "USE_NORMALMAP" /* USE_NORMALMAP */,
        "specularMap": "USE_SPECULARMAP" /* USE_SPECULARMAP */,
        "gradientMap": "TOON" /* TOON */,
        "roughnessMap": "USE_ROUGHNESSMAP" /* USE_ROUGHNESSMAP */,
        "metalnessMap": "USE_METALNESSMAP" /* USE_METALNESSMAP */,
        "displacementMap": "USE_DISPLACEMENTMAP" /* USE_DISPLACEMENTMAP */,
        "envMap": "USE_ENVMAP" /* USE_ENVMAP */,
        "emissiveMap": "USE_EMISSIVEMAP" /* USE_EMISSIVEMAP */,
    };
    /**
     * 内置提供的全局 Attribute。
     * @private
     */
    egret3d.globalAttributeSemantics = {
        "position": "POSITION" /* POSITION */,
        "normal": "NORMAL" /* NORMAL */,
        "uv": "TEXCOORD_0" /* TEXCOORD_0 */,
        "uv2": "TEXCOORD_1" /* TEXCOORD_1 */,
        "color": "COLOR_0" /* COLOR_0 */,
        // "morphTarget0": gltf.AttributeSemanticType.MORPHTARGET_0,
        // "morphTarget1": gltf.AttributeSemanticType.MORPHTARGET_1,
        // "morphTarget2": gltf.AttributeSemanticType.MORPHTARGET_2,
        // "morphTarget3": gltf.AttributeSemanticType.MORPHTARGET_3,
        // "morphTarget4": gltf.AttributeSemanticType.MORPHTARGET_4,
        // "morphTarget5": gltf.AttributeSemanticType.MORPHTARGET_5,
        // "morphTarget6": gltf.AttributeSemanticType.MORPHTARGET_6,
        // "morphTarget7": gltf.AttributeSemanticType.MORPHTARGET_7,
        // "morphNormal0": gltf.AttributeSemanticType.MORPHNORMAL_0,
        // "morphNormal1": gltf.AttributeSemanticType.MORPHNORMAL_1,
        // "morphNormal2": gltf.AttributeSemanticType.MORPHNORMAL_2,
        // "morphNormal3": gltf.AttributeSemanticType.MORPHNORMAL_3,
        "skinIndex": "JOINTS_0" /* JOINTS_0 */,
        "skinWeight": "WEIGHTS_0" /* WEIGHTS_0 */,
        "corner": "_CORNER" /* _CORNER */,
        "startPosition": "_START_POSITION" /* _START_POSITION */,
        "startVelocity": "_START_VELOCITY" /* _START_VELOCITY */,
        "startColor": "_START_COLOR" /* _START_COLOR */,
        "startSize": "_START_SIZE" /* _START_SIZE */,
        "startRotation": "_START_ROTATION" /* _START_ROTATION */,
        "time": "_TIME" /* _TIME */,
        "random0": "_RANDOM0" /* _RANDOM0 */,
        "random1": "_RANDOM1" /* _RANDOM1 */,
        "startWorldPosition": "_WORLD_POSITION" /* _WORLD_POSITION */,
        "startWorldRotation": "_WORLD_ROTATION" /* _WORLD_ROTATION */,
        "lineDistance": "_INSTANCE_DISTANCE" /* _INSTANCE_DISTANCE */,
        "instanceStart": "_INSTANCE_START" /* _INSTANCE_START */,
        "instanceEnd": "_INSTANCE_END" /* _INSTANCE_END */,
        "instanceColorStart": "_INSTANCE_COLOR_START" /* _INSTANCE_COLOR_START */,
        "instanceColorEnd": "_INSTANCE_COLOR_END" /* _INSTANCE_COLOR_END */,
        "instanceDistanceStart": "_INSTANCE_DISTANCE_START" /* _INSTANCE_DISTANCE_START */,
        "instanceDistanceEnd": "_INSTANCE_DISTANCE_END" /* _INSTANCE_DISTANCE_END */,
    };
    /**
     * 内置提供的全局 Uniform。
     * @private
     */
    egret3d.globalUniformSemantics = {
        "ambientLightColor": "_AMBIENTLIGHTCOLOR" /* _AMBIENTLIGHTCOLOR */,
        "fogColor": "_FOG_COLOR" /* _FOG_COLOR */,
        "fogDensity": "_FOG_DENSITY" /* _FOG_DENSITY */,
        "fogNear": "_FOG_NEAR" /* _FOG_NEAR */,
        "fogFar": "_FOG_FAR" /* _FOG_FAR */,
        "toneMappingExposure": "_TONE_MAPPING_EXPOSURE" /* _TONE_MAPPING_EXPOSURE */,
        "toneMappingWhitePoint": "_TONE_MAPPING_WHITE_POINT" /* _TONE_MAPPING_WHITE_POINT */,
        "resolution": "_RESOLUTION" /* _RESOLUTION */,
    };
    /**
     * 内置提供的场景 Uniform。
     * @private
     */
    egret3d.sceneUniformSemantics = {
        "lightMapIntensity": "_LIGHTMAPINTENSITY" /* _LIGHTMAPINTENSITY */,
    };
    /**
     * 内置提供的摄像机 Uniform。
     * @private
     */
    egret3d.cameraUniformSemantics = {
        "viewMatrix": "VIEW" /* VIEW */,
        "projectionMatrix": "PROJECTION" /* PROJECTION */,
        "viewProjectionMatrix": "_VIEWPROJECTION" /* _VIEWPROJECTION */,
        "cameraForward": "_CAMERA_FORWARD" /* _CAMERA_FORWARD */,
        "cameraUp": "_CAMERA_UP" /* _CAMERA_UP */,
        "cameraPosition": "_CAMERA_POS" /* _CAMERA_POS */,
        "directionalLights[0]": "_DIRECTLIGHTS" /* _DIRECTLIGHTS */,
        "spotLights[0]": "_SPOTLIGHTS" /* _SPOTLIGHTS */,
        "rectAreaLights[0]": "_RECTAREALIGHTS" /* _RECTAREALIGHTS */,
        "pointLights[0]": "_POINTLIGHTS" /* _POINTLIGHTS */,
        "hemisphereLights[0]": "_HEMILIGHTS" /* _HEMILIGHTS */,
        "logDepthBufFC": "_LOG_DEPTH_BUFFC" /* _LOG_DEPTH_BUFFC */,
    };
    /**
     * 内置提供的影子 Uniform。
     * @private
     */
    egret3d.shadowUniformSemantics = {
        "referencePosition": "_REFERENCEPOSITION" /* _REFERENCEPOSITION */,
        "nearDistance": "_NEARDICTANCE" /* _NEARDICTANCE */,
        "farDistance": "_FARDISTANCE" /* _FARDISTANCE */,
    };
    /**
     * 内置提供的模型 Uniform。
     * @private
     */
    egret3d.modelUniformSemantics = {
        "modelMatrix": "MODEL" /* MODEL */,
        "modelViewMatrix": "MODELVIEW" /* MODELVIEW */,
        "modelViewProjectionMatrix": "MODELVIEWPROJECTION" /* MODELVIEWPROJECTION */,
        "normalMatrix": "MODELVIEWINVERSE" /* MODELVIEWINVERSE */,
        "boneMatrices[0]": "JOINTMATRIX" /* JOINTMATRIX */,
        "boneTexture": "_BONETEXTURE" /* _BONETEXTURE */,
        "boneTextureSize": "_BONETEXTURESIZE" /* _BONETEXTURESIZE */,
        "clock": "_CLOCK" /* _CLOCK */,
        "lightMap": "_LIGHTMAPTEX" /* _LIGHTMAPTEX */,
        "lightMapScaleOffset": "_LIGHTMAP_SCALE_OFFSET" /* _LIGHTMAP_SCALE_OFFSET */,
        "directionalShadowMatrix[0]": "_DIRECTIONSHADOWMAT" /* _DIRECTIONSHADOWMAT */,
        "spotShadowMatrix[0]": "_SPOTSHADOWMAT" /* _SPOTSHADOWMAT */,
        "pointShadowMatrix[0]": "_POINTSHADOWMAT" /* _POINTSHADOWMAT */,
        "directionalShadowMap[0]": "_DIRECTIONSHADOWMAP" /* _DIRECTIONSHADOWMAP */,
        "pointShadowMap[0]": "_POINTSHADOWMAP" /* _POINTSHADOWMAP */,
        "spotShadowMap[0]": "_SPOTSHADOWMAP" /* _SPOTSHADOWMAP */,
        "rotation": "_ROTATION" /* _ROTATION */,
        "scale2D": "_SCALE2D" /* _SCALE2D */,
    };
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3 = egret3d.Vector3.create();
    var _helpRotation = egret3d.Quaternion.create();
    var _helpMatrix = egret3d.Matrix4.create();
    var TransformDirty;
    (function (TransformDirty) {
        TransformDirty[TransformDirty["All"] = 63] = "All";
        TransformDirty[TransformDirty["PRS"] = 7] = "PRS";
        TransformDirty[TransformDirty["MIM"] = 48] = "MIM";
        TransformDirty[TransformDirty["Position"] = 1] = "Position";
        TransformDirty[TransformDirty["Rotation"] = 2] = "Rotation";
        TransformDirty[TransformDirty["Scale"] = 4] = "Scale";
        TransformDirty[TransformDirty["Euler"] = 8] = "Euler";
        TransformDirty[TransformDirty["Matrix"] = 16] = "Matrix";
        TransformDirty[TransformDirty["InverseMatrix"] = 32] = "InverseMatrix";
    })(TransformDirty || (TransformDirty = {}));
    /**
     * 变换组件。
     * - 实现 3D 空间坐标系变换。
     */
    var Transform = (function (_super) {
        __extends(Transform, _super);
        function Transform() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._localDirty = 63 /* All */;
            _this._worldDirty = 63 /* All */;
            _this._observers = [];
            /**
             * 世界矩阵的行列式，如果小于0，说明进行了反转
             * @internal
             */
            _this._worldMatrixDeterminant = 0.0;
            _this._localPosition = egret3d.Vector3.create();
            _this._localRotation = egret3d.Quaternion.create();
            _this._localEuler = egret3d.Vector3.create();
            _this._localEulerAngles = egret3d.Vector3.create();
            _this._localScale = egret3d.Vector3.ONE.clone();
            _this._position = egret3d.Vector3.create();
            _this._rotation = egret3d.Quaternion.create();
            _this._euler = egret3d.Vector3.create();
            _this._eulerAngles = egret3d.Vector3.create();
            _this._scale = egret3d.Vector3.ONE.clone();
            _this._localToParentMatrix = egret3d.Matrix4.create();
            _this._worldToLocalMatrix = egret3d.Matrix4.create();
            _this._localToWorldMatrix = egret3d.Matrix4.create();
            return _this;
        }
        /**
         * @internal
         */
        Transform.prototype._destroy = function () {
            _super.prototype._destroy.call(this);
            this._observers.length > 0 && (this._observers.length = 0);
        };
        Transform.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this._localPosition.onUpdateTarget = this._position.onUpdateTarget = this;
            this._localPosition.onUpdate = this._position.onUpdate = this._onPositionUpdate;
            this._localRotation.onUpdateTarget = this._rotation.onUpdateTarget = this;
            this._localRotation.onUpdate = this._rotation.onUpdate = this._onRotationUpdate;
            this._localEuler.onUpdateTarget = this._euler.onUpdateTarget = this;
            this._localEuler.onUpdate = this._euler.onUpdate = this._onEulerUpdate;
            this._localEulerAngles.onUpdateTarget = this._eulerAngles.onUpdateTarget = this;
            this._localEulerAngles.onUpdate = this._eulerAngles.onUpdate = this._onEulerAnglesUpdate;
            this._localScale.onUpdateTarget = this._scale.onUpdateTarget = this;
            this._localScale.onUpdate = this._scale.onUpdate = this._onScaleUpdate;
        };
        /**
         *
         * @param observer
         */
        Transform.prototype.registerObserver = function (observer) {
            var observers = this._observers;
            if (observers.indexOf(observer) < 0) {
                observers.push(observer);
            }
        };
        /**
         *
         * @param observer
         */
        Transform.prototype.unregisterObserver = function (observer) {
            var observers = this._observers;
            var index = observers.indexOf(observer);
            if (index >= 0) {
                observers.splice(index, 1);
            }
        };
        Transform.prototype._onChangeParent = function (isBefore, worldTransformStays) {
            if (isBefore) {
                if (worldTransformStays) {
                    _helpVector3.copy(this.position);
                    _helpRotation.copy(this.rotation);
                }
            }
            else {
                this._dirtify(false, 7 /* PRS */);
                if (worldTransformStays) {
                    this.position = _helpVector3;
                    this.rotation = _helpRotation;
                }
            }
        };
        Transform.prototype._onPositionUpdate = function (position) {
            if (position === this._localPosition) {
                this._dirtify(true, 1 /* Position */);
            }
            else {
                this.position = position;
            }
        };
        Transform.prototype._onRotationUpdate = function (rotation) {
            if (rotation === this._localRotation) {
                this._dirtify(true, 2 /* Rotation */);
            }
            else {
                this.rotation = rotation;
            }
        };
        Transform.prototype._onEulerUpdate = function (euler) {
            if (euler === this._localEuler) {
                this.localEuler = euler;
            }
            else {
                this.euler = euler;
            }
        };
        Transform.prototype._onEulerAnglesUpdate = function (euler) {
            if (euler === this._localEulerAngles) {
                this.localEulerAngles = euler;
            }
            else {
                this.eulerAngles = euler;
            }
        };
        Transform.prototype._onScaleUpdate = function (scale) {
            if (scale === this._localScale) {
                this._dirtify(true, 4 /* Scale */);
            }
            else {
                this.scale = scale;
            }
        };
        Transform.prototype._dirtify = function (isLocalDirty, dirty) {
            if (isLocalDirty) {
                this._localDirty |= dirty | 48 /* MIM */;
                if (dirty & 2 /* Rotation */) {
                    this._localDirty |= 4 /* Scale */ | 8 /* Euler */;
                }
                else if (dirty & 4 /* Scale */) {
                    this._localDirty |= 2 /* Rotation */;
                }
                if (true) {
                    if (dirty & 1 /* Position */) {
                        var isError = false;
                        var localPosition = this._localPosition;
                        if (localPosition.x !== localPosition.x) {
                            isError = true;
                            localPosition.x = 0.0;
                        }
                        if (localPosition.y !== localPosition.y) {
                            isError = true;
                            localPosition.y = 0.0;
                        }
                        if (localPosition.z !== localPosition.z) {
                            isError = true;
                            localPosition.z = 0.0;
                        }
                        if (isError) {
                            console.error("Error local position.");
                        }
                    }
                    if (dirty & 2 /* Rotation */) {
                        var isError = false;
                        var localRotation = this._localRotation;
                        if (localRotation.x !== localRotation.x) {
                            isError = true;
                            localRotation.x = 0.0;
                        }
                        if (localRotation.y !== localRotation.y) {
                            isError = true;
                            localRotation.y = 0.0;
                        }
                        if (localRotation.z !== localRotation.z) {
                            isError = true;
                            localRotation.z = 0.0;
                        }
                        if (localRotation.w !== localRotation.w) {
                            isError = true;
                            localRotation.w = 0.0;
                        }
                        if (isError) {
                            console.error("Error local rotation.");
                        }
                    }
                    if (dirty & 4 /* Scale */) {
                        var isError = false;
                        var localScale = this._localScale;
                        if (localScale.x !== localScale.x) {
                            isError = true;
                            localScale.x = 0.0;
                        }
                        if (localScale.y !== localScale.y) {
                            isError = true;
                            localScale.y = 0.0;
                        }
                        if (localScale.z !== localScale.z) {
                            isError = true;
                            localScale.z = 0.0;
                        }
                        if (isError) {
                            console.error("Error local scale.");
                        }
                    }
                }
            }
            for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                var child = _a[_i];
                child._dirtify(false, 63 /* All */);
            }
            if (!(this._worldDirty & dirty) || !(this._worldDirty & 16 /* Matrix */)) {
                this._worldDirty |= dirty | 48 /* MIM */;
                if (dirty & 2 /* Rotation */) {
                    this._worldDirty |= 4 /* Scale */ | 8 /* Euler */;
                }
                else if (dirty & 4 /* Scale */) {
                    this._worldDirty |= 2 /* Rotation */;
                }
            }
            var observers = this._observers;
            if (observers.length > 0) {
                for (var _b = 0, _c = this._observers; _b < _c.length; _b++) {
                    var observer = _c[_b];
                    observer.onTransformChange();
                }
            }
        };
        Transform.prototype._updateMatrix = function (isWorldSpace) {
            if (isWorldSpace) {
                var localMatrix = this.localToParentMatrix;
                if (this._parent) {
                    this._localToWorldMatrix.multiply(this._parent.localToWorldMatrix, localMatrix);
                }
                else {
                    this._localToWorldMatrix.copy(localMatrix);
                }
                this._worldMatrixDeterminant = this._localToWorldMatrix.determinant;
                this._worldDirty &= ~16 /* Matrix */;
            }
            else {
                if ((this._localDirty & 2 /* Rotation */) || (this._localDirty & 4 /* Scale */)) {
                    this._localToParentMatrix.compose(this.localPosition, this.localRotation, this.localScale);
                    this._localDirty &= ~7 /* PRS */;
                }
                else if (this._localDirty & 1 /* Position */) {
                    this._localToParentMatrix.fromTranslate(this.localPosition, true);
                    this._localDirty &= ~1 /* Position */;
                }
                this._localDirty &= ~16 /* Matrix */;
            }
        };
        Transform.prototype._updateEuler = function (isWorldSpace, order) {
            if (isWorldSpace) {
                this.rotation.toEuler(this._euler, order);
                this._eulerAngles.multiplyScalar(57.29577951308232 /* RAD_DEG */, this._euler);
                this._worldDirty &= ~8 /* Euler */;
            }
            else {
                this.localRotation.toEuler(this._localEuler, order);
                this._localEulerAngles.multiplyScalar(57.29577951308232 /* RAD_DEG */, this._localEuler);
                this._localDirty &= ~8 /* Euler */;
            }
        };
        Transform.prototype.setLocalPosition = function (p1, p2, p3) {
            var localPosition = this._localPosition;
            if (p1.hasOwnProperty("x")) {
                localPosition.x = p1.x;
                localPosition.y = p1.y;
                localPosition.z = p1.z;
            }
            else {
                localPosition.x = p1;
                localPosition.y = p2 || 0.0;
                localPosition.z = p3 || 0.0;
            }
            this._dirtify(true, 1 /* Position */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "localPosition", {
            /**
             * 该组件的本地位置。
             * - 并不会返回一个新的 `egret3d.Vector3` 实例。
             * - 可以调用 `vector3.update()` 将对该向量的修改同步到该组件，`gameObject.transform.localPosition.add(egret3d.Vector3.ONE).update()`。
             */
            get: function () {
                return this._localPosition;
            },
            set: function (value) {
                this._localPosition.x = value.x;
                this._localPosition.y = value.y;
                this._localPosition.z = value.z;
                this._dirtify(true, 1 /* Position */);
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.setLocalRotation = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                this._localRotation.x = p1.x;
                this._localRotation.y = p1.y;
                this._localRotation.z = p1.z;
                this._localRotation.w = p1.w;
            }
            else {
                this._localRotation.x = p1;
                this._localRotation.y = p2 || 0.0;
                this._localRotation.z = p3 || 0.0;
                this._localRotation.w = p4 !== undefined ? p4 : 1.0;
            }
            this._dirtify(true, 2 /* Rotation */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "localRotation", {
            /**
             * 该组件的本地四元数旋转。
             * - 并不会返回一个新的 `egret3d.Quaternion` 实例。
             * - 可以调用 `quaternion.update()` 将对该四元数的修改同步到该组件，`gameObject.transform.localRotation.multiplyScalar(0.1).update()`。
             */
            get: function () {
                return this._localRotation;
            },
            set: function (value) {
                this._localRotation.x = value.x;
                this._localRotation.y = value.y;
                this._localRotation.z = value.z;
                this._localRotation.w = value.w;
                this._dirtify(true, 2 /* Rotation */);
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.setLocalEuler = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                this._localEuler.x = p1.x;
                this._localEuler.y = p1.y;
                this._localEuler.z = p1.z;
                this._localEulerAngles.multiplyScalar(57.29577951308232 /* RAD_DEG */, this._localEuler);
                this._localRotation.fromEuler(this._localEuler, p2);
            }
            else {
                this._localEuler.x = p1;
                this._localEuler.y = p2;
                this._localEuler.z = p3;
                this._localEulerAngles.multiplyScalar(57.29577951308232 /* RAD_DEG */, this._localEuler);
                this._localRotation.fromEuler(this._localEuler, p4);
            }
            this._dirtify(true, 2 /* Rotation */);
            this._localDirty &= ~8 /* Euler */;
            return this;
        };
        Object.defineProperty(Transform.prototype, "localEuler", {
            /**
             * 该组件的本地欧拉旋转。（弧度制）
             */
            get: function () {
                if (this._localDirty & 8 /* Euler */) {
                    this._updateEuler(false);
                }
                return this._localEuler;
            },
            set: function (value) {
                this._localEuler.x = value.x;
                this._localEuler.y = value.y;
                this._localEuler.z = value.z;
                this._localEulerAngles.multiplyScalar(57.29577951308232 /* RAD_DEG */, this._localEuler);
                this._localRotation.fromEuler(this._localEuler);
                this._dirtify(true, 2 /* Rotation */);
                this._localDirty &= ~8 /* Euler */;
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.setLocalEulerAngles = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                this._localEulerAngles.x = p1.x;
                this._localEulerAngles.y = p1.y;
                this._localEulerAngles.z = p1.z;
                this._localEuler.multiplyScalar(0.017453292519943295 /* DEG_RAD */, this._localEulerAngles);
                this._localRotation.fromEuler(this._localEuler, p2);
            }
            else {
                this._localEulerAngles.x = p1;
                this._localEulerAngles.y = p2;
                this._localEulerAngles.z = p3;
                this._localEuler.multiplyScalar(0.017453292519943295 /* DEG_RAD */, this._localEulerAngles);
                this._localRotation.fromEuler(this._localEuler, p4);
            }
            this._dirtify(true, 2 /* Rotation */);
            this._localDirty &= ~8 /* Euler */;
            return this;
        };
        Object.defineProperty(Transform.prototype, "localEulerAngles", {
            /**
             * 该组件的本地欧拉旋转。（角度制）
             */
            get: function () {
                if (this._localDirty & 8 /* Euler */) {
                    this._updateEuler(false);
                }
                return this._localEulerAngles;
            },
            set: function (value) {
                this._localEulerAngles.x = value.x;
                this._localEulerAngles.y = value.y;
                this._localEulerAngles.z = value.z;
                this._localEuler.multiplyScalar(0.017453292519943295 /* DEG_RAD */, this._localEulerAngles);
                this._localRotation.fromEuler(this._localEuler);
                this._dirtify(true, 2 /* Rotation */);
                this._localDirty &= ~8 /* Euler */;
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.setLocalScale = function (p1, p2, p3) {
            var EPSILON = 2.220446049250313e-16 /* EPSILON */;
            if (p1.hasOwnProperty("x")) {
                this._localScale.x = p1.x || EPSILON;
                this._localScale.y = p1.y || EPSILON;
                this._localScale.z = p1.z || EPSILON;
            }
            else {
                this._localScale.x = p1 || EPSILON;
                this._localScale.y = (p2 !== undefined ? p2 : p1) || EPSILON;
                this._localScale.z = (p3 !== undefined ? p3 : p1) || EPSILON;
            }
            this._dirtify(true, 4 /* Scale */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "localScale", {
            /**
             * 该组件的本地缩放。
             */
            get: function () {
                return this._localScale;
            },
            set: function (value) {
                var EPSILON = 2.220446049250313e-16 /* EPSILON */;
                this._localScale.x = value.x || EPSILON;
                this._localScale.y = value.y || EPSILON;
                this._localScale.z = value.z || EPSILON;
                this._dirtify(true, 4 /* Scale */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "localToParentMatrix", {
            /**
             * 该组件的本地矩阵。
             */
            get: function () {
                if (this._localDirty & 16 /* Matrix */) {
                    this._updateMatrix(false);
                }
                return this._localToParentMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.setPosition = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                this._localPosition.x = p1.x;
                this._localPosition.y = p1.y;
                this._localPosition.z = p1.z;
            }
            else {
                this._localPosition.x = p1;
                this._localPosition.y = p2 || 0.0;
                this._localPosition.z = p3 || 0.0;
            }
            if (this._parent) {
                this._localPosition.applyMatrix(this._parent.worldToLocalMatrix);
            }
            this._dirtify(true, 1 /* Position */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "position", {
            /**
             * 该组件的世界位置。
             */
            get: function () {
                if (this._worldDirty & 1 /* Position */) {
                    this.localToWorldMatrix.decompose(this._position, null, null);
                    this._worldDirty &= ~1 /* Position */;
                }
                return this._position;
            },
            set: function (value) {
                this._localPosition.x = value.x;
                this._localPosition.y = value.y;
                this._localPosition.z = value.z;
                if (this._parent) {
                    this._localPosition.applyMatrix(this._parent.worldToLocalMatrix);
                }
                this._dirtify(true, 1 /* Position */);
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.setRotation = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                this._localRotation.x = p1.x;
                this._localRotation.y = p1.y;
                this._localRotation.z = p1.z;
                this._localRotation.w = p1.w;
            }
            else {
                this._localRotation.x = p1;
                this._localRotation.y = p2 || 0.0;
                this._localRotation.z = p3 || 0.0;
                this._localRotation.w = p4 !== undefined ? p4 : 1.0;
            }
            if (this._parent) {
                this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
            }
            this._dirtify(true, 2 /* Rotation */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "rotation", {
            /**
             * 该组件的世界旋转。
             */
            get: function () {
                if (this._worldDirty & 2 /* Rotation */) {
                    this.localToWorldMatrix.decompose(null, this._rotation, null);
                    this._worldDirty &= ~2 /* Rotation */;
                }
                return this._rotation;
            },
            set: function (value) {
                this._localRotation.x = value.x;
                this._localRotation.y = value.y;
                this._localRotation.z = value.z;
                this._localRotation.w = value.w;
                if (this._parent) {
                    this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
                }
                this._dirtify(true, 2 /* Rotation */);
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.setEuler = function (q1, q2, q3, q4) {
            if (q1.hasOwnProperty("x")) {
                this._localRotation.fromEuler(q1, q2);
            }
            else {
                _helpVector3.set(q1, q2, q3);
                this._localRotation.fromEuler(_helpVector3, q4);
            }
            if (this._parent) {
                this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
            }
            this._dirtify(true, 2 /* Rotation */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "euler", {
            /**
             * 该组件的世界欧拉旋转。（弧度制）
             */
            get: function () {
                if (this._worldDirty & 8 /* Euler */) {
                    this._updateEuler(true);
                }
                return this._euler;
            },
            set: function (value) {
                this._localRotation.fromEuler(value);
                if (this._parent) {
                    this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
                }
                this._dirtify(true, 2 /* Rotation */);
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.setEulerAngles = function (q1, q2, q3, q4) {
            if (q1.hasOwnProperty("x")) {
                _helpVector3.multiplyScalar(0.017453292519943295 /* DEG_RAD */, q1);
                this._localRotation.fromEuler(_helpVector3, q2);
            }
            else {
                _helpVector3.set(q1 * 0.017453292519943295 /* DEG_RAD */, q2 * 0.017453292519943295 /* DEG_RAD */, q3 * 0.017453292519943295 /* DEG_RAD */);
                this._localRotation.fromEuler(_helpVector3, q4);
            }
            if (this._parent) {
                this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
            }
            this._dirtify(true, 2 /* Rotation */);
            return this;
        };
        Object.defineProperty(Transform.prototype, "eulerAngles", {
            /**
             * 该组件的世界欧拉旋转。（角度制）
             */
            get: function () {
                if (this._worldDirty & 8 /* Euler */) {
                    this._updateEuler(true);
                }
                return this._eulerAngles;
            },
            set: function (value) {
                _helpVector3.multiplyScalar(0.017453292519943295 /* DEG_RAD */, value);
                this._localRotation.fromEuler(_helpVector3);
                if (this._parent) {
                    this._localRotation.premultiply(_helpRotation.inverse(this._parent.rotation)).normalize();
                }
                this._dirtify(true, 2 /* Rotation */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "scale", {
            /**
             * 该组件的世界缩放。
             */
            get: function () {
                if (this._worldDirty & 4 /* Scale */) {
                    this.localToWorldMatrix.decompose(null, null, this._scale);
                    this._worldDirty &= ~4 /* Scale */;
                }
                return this._scale;
            },
            /**
             * @deprecated
             */
            set: function (value) {
                console.error("Can not set transform scale.");
                this.localScale = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "localToWorldMatrix", {
            /**
             * 从该组件空间坐标系到世界空间坐标系的变换矩阵。
             */
            get: function () {
                if (this._worldDirty & 16 /* Matrix */) {
                    this._updateMatrix(true);
                }
                return this._localToWorldMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "worldToLocalMatrix", {
            /**
             * 从世界空间坐标系到该组件空间坐标系的变换矩阵。
             */
            get: function () {
                if (this._worldDirty & 32 /* InverseMatrix */) {
                    this._worldToLocalMatrix.inverse(this.localToWorldMatrix);
                    this._worldDirty &= ~32 /* InverseMatrix */;
                }
                return this._worldToLocalMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.translate = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                if (p2) {
                    this.position = this._localPosition.add(p1, this.position);
                }
                else {
                    this.localPosition = this._localPosition.add(p1);
                }
            }
            else {
                _helpVector3.set(p1, p2, p3);
                if (p4) {
                    this.position = this._localPosition.add(_helpVector3, this.position);
                }
                else {
                    this.localPosition = this._localPosition.add(_helpVector3);
                }
            }
            return this;
        };
        Transform.prototype.rotate = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                if (p2) {
                    this.euler = this._localEuler.add(p1, this.euler);
                }
                else {
                    this.localEuler; // Update euler.
                    this.localEuler = this._localEuler.add(p1);
                }
            }
            else {
                _helpVector3.set(p1, p2, p3);
                if (p4) {
                    this.euler = this._localEuler.add(_helpVector3, this.euler);
                }
                else {
                    this.localEuler; // Update euler.
                    this.localEuler = this._localEuler.add(_helpVector3);
                }
            }
            return this;
        };
        /**
         * 将该组件绕指定轴旋转指定弧度。
         * @param axis 指定轴。
         * @param angle 指定弧度。
         * @param isWorldSpace 是否是世界坐标系。
         */
        Transform.prototype.rotateOnAxis = function (axis, angle, isWorldSpace) {
            _helpRotation.fromAxis(axis, angle);
            if (isWorldSpace) {
                this.localRotation = this._localRotation.premultiply(_helpRotation).normalize();
            }
            else {
                this.localRotation = this._localRotation.multiply(_helpRotation).normalize();
            }
            return this;
        };
        /**
         * 将该组件绕世界指定点和世界指定轴旋转指定弧度。
         * @param worldPosition 世界指定点。
         * @param worldAxis 世界指定轴。
         * @param angle 指定弧度。
         */
        Transform.prototype.rotateAround = function (worldPosition, worldAxis, angle) {
            this.rotateOnAxis(worldAxis, angle, true);
            this.position = this._localPosition.applyMatrix(_helpMatrix.fromRotation(_helpRotation.fromAxis(worldAxis, angle)).fromTranslate(worldPosition, true), this.position);
            return this;
        };
        /**
         * 通过旋转使得该组件的 Z 轴正方向指向目标点。
         * @param target 目标点。
         * @param up 旋转后，该组件在世界空间坐标系下描述的 Y 轴正方向。
         */
        Transform.prototype.lookAt = function (target, up) {
            if (up === void 0) { up = egret3d.Vector3.UP; }
            this.rotation = this._localRotation.fromMatrix(_helpMatrix.lookAt(this.position, target instanceof Transform ? target.position : target, up));
            return this;
        };
        /**
         * 通过旋转使得该组件的 Z 轴正方向指向目标方向。
         * @param target 目标方向。
         * @param up 旋转后，该组件在世界空间坐标系下描述的 Y 轴正方向。
         */
        Transform.prototype.lookRotation = function (direction, up) {
            if (up === void 0) { up = egret3d.Vector3.UP; }
            this.rotation = this._localRotation.fromMatrix(_helpMatrix.lookRotation(direction, up));
            return this;
        };
        /**
         * 获取该组件在世界空间坐标系下描述的 X 轴正方向。
         * @param out 输出向量。
         */
        Transform.prototype.getRight = function (out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return out.applyDirection(this.localToWorldMatrix, egret3d.Vector3.RIGHT);
        };
        /**
         * 获取该组件在世界空间坐标系下描述的 Y 轴正方向。
         * @param out 输出向量。
         */
        Transform.prototype.getUp = function (out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return out.applyDirection(this.localToWorldMatrix, egret3d.Vector3.UP);
        };
        /**
         * 获取该组件在世界空间坐标系下描述的 Z 轴正方向。
         * @param out 输出向量。
         */
        Transform.prototype.getForward = function (out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return out.applyDirection(this.localToWorldMatrix, egret3d.Vector3.FORWARD);
        };
        /**
         * @deprecated
         */
        Transform.prototype.getLocalPosition = function () {
            return this._localPosition;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getLocalRotation = function () {
            return this._localRotation;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getLocalEuler = function (order) {
            if (this._localDirty & 8 /* Euler */) {
                this._updateEuler(false, order);
            }
            return this._localEuler;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getLocalEulerAngles = function (order) {
            if (this._localDirty & 8 /* Euler */) {
                this._updateEuler(false, order);
            }
            return this._localEulerAngles;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getLocalScale = function () {
            return this._localScale;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getPosition = function () {
            if (this._worldDirty & 1 /* Position */) {
                this.localToWorldMatrix.decompose(this._position, null, null);
                this._worldDirty &= ~1 /* Position */;
            }
            return this._position;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getRotation = function () {
            if (this._worldDirty & 2 /* Rotation */) {
                this.localToWorldMatrix.decompose(null, this._rotation, null);
                this._worldDirty &= ~2 /* Rotation */;
            }
            return this._rotation;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getEuler = function (order) {
            if (this._worldDirty & 8 /* Euler */) {
                this._updateEuler(true, order);
            }
            return this._euler;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getEulerAngles = function (order) {
            if (this._worldDirty & 8 /* Euler */) {
                this._updateEuler(true, order);
            }
            return this._eulerAngles;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getScale = function () {
            if (this._worldDirty & 4 /* Scale */) {
                this.localToWorldMatrix.decompose(null, null, this._scale);
                this._worldDirty &= ~4 /* Scale */;
            }
            return this._scale;
        };
        Transform.prototype.setScale = function (p1, p2, p3) {
            console.error("Can not set transform scale.");
            if (p1 instanceof egret3d.Vector3) {
                this.localScale = p1;
            }
            else {
                this.localScale.set(p1, p2 === undefined ? p1 : p2, p3 === undefined ? p1 : p3);
            }
            return this;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getLocalMatrix = function () {
            if (this._localDirty & 16 /* Matrix */) {
                this._updateMatrix(false);
            }
            return this._localToParentMatrix;
        };
        /**
         * @deprecated
         */
        Transform.prototype.getWorldMatrix = function () {
            if (this._worldDirty & 16 /* Matrix */) {
                this._updateMatrix(true);
            }
            return this._localToWorldMatrix;
        };
        Object.defineProperty(Transform.prototype, "localMatrix", {
            /**
             * @deprecated
             */
            get: function () {
                if (this._localDirty & 16 /* Matrix */) {
                    this._updateMatrix(false);
                }
                return this._localToParentMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "worldMatrix", {
            /**
             * @deprecated
             */
            get: function () {
                if (this._worldDirty & 16 /* Matrix */) {
                    this._updateMatrix(true);
                }
                return this._localToWorldMatrix;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField("localPosition")
        ], Transform.prototype, "_localPosition", void 0);
        __decorate([
            paper.serializedField("localRotation")
        ], Transform.prototype, "_localRotation", void 0);
        __decorate([
            paper.serializedField("localScale")
        ], Transform.prototype, "_localScale", void 0);
        __decorate([
            paper.editor.property("VECTOR3" /* VECTOR3 */)
        ], Transform.prototype, "localPosition", null);
        __decorate([
            paper.editor.property("VECTOR3" /* VECTOR3 */, { step: 1.0 })
        ], Transform.prototype, "localEulerAngles", null);
        __decorate([
            paper.editor.property("VECTOR3" /* VECTOR3 */)
        ], Transform.prototype, "localScale", null);
        return Transform;
    }(paper.BaseTransform));
    egret3d.Transform = Transform;
    __reflect(Transform.prototype, "egret3d.Transform");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 全局舞台信息组件。
     */
    var Stage = (function (_super) {
        __extends(Stage, _super);
        function Stage() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 当屏幕尺寸改变时派发事件。
             */
            _this.onScreenResize = new signals.Signal();
            /**
             * 当舞台尺寸改变时派发事件。
             */
            _this.onResize = new signals.Signal();
            /**
             * 舞台到屏幕的缩放系数。
             */
            _this.scaler = 1.0;
            _this._rotated = false;
            _this._matchFactor = 1.0;
            _this._screenSize = { w: 1024, h: 1024 };
            _this._size = { w: 1024, h: 1024 };
            _this._viewport = egret3d.Rectangle.create(0.0, 0.0, 1.0, 1.0);
            return _this;
        }
        Stage.prototype._updateViewport = function () {
            var screenSize = this._screenSize;
            var size = this._size;
            var viewport = this._viewport;
            if (paper.Application.isMobile) {
                var screenW = screenSize.w;
                var screenH = screenSize.h;
                if (this._rotated = (size.w > size.h) ? screenSize.h > screenSize.w : screenSize.w > screenSize.h) {
                    screenW = screenSize.h;
                    screenH = screenSize.w;
                }
                var scalerW = size.w / screenW;
                var scalerH = size.h / screenH;
                this.scaler = egret3d.math.lerp(scalerW, scalerH, this._matchFactor);
                viewport.w = Math.ceil(screenW * this.scaler);
                viewport.h = Math.ceil(screenH * this.scaler);
                this.scaler = screenW / screenSize.w;
            }
            else {
                var scalerW = Math.min(size.w, screenSize.w) / screenSize.w;
                var scalerH = size.h / screenSize.h;
                this.scaler = egret3d.math.lerp(scalerW, scalerH, this._matchFactor);
                this._rotated = false;
                viewport.w = Math.ceil(screenSize.w * this.scaler);
                viewport.h = Math.ceil(screenSize.h * this.scaler);
                this.scaler = viewport.w / screenSize.w;
            }
        };
        Stage.prototype.initialize = function (config) {
            _super.prototype.initialize.call(this);
            egret3d.stage = this;
            this._size.w = config.size.w || 1.0;
            this._size.h = config.size.h || 1.0;
            this._screenSize.w = config.screenSize.w || 1.0;
            this._screenSize.h = config.screenSize.h || 1.0;
            this._updateViewport();
        };
        /**
         * 屏幕到舞台坐标的转换。
         */
        Stage.prototype.screenToStage = function (value, out) {
            var screenSize = this._screenSize;
            var viewPort = this._viewport;
            var x = value.x, y = value.y;
            if (this._rotated) {
                out.y = (screenSize.w - (x - viewPort.x)) * (viewPort.w / screenSize.h);
                out.x = (y - viewPort.y) * (viewPort.h / screenSize.w);
            }
            else {
                out.x = (x - viewPort.x) * (viewPort.w / screenSize.w);
                out.y = (y - viewPort.y) * (viewPort.h / screenSize.h);
            }
            return this;
        };
        /**
         * 舞台到屏幕坐标的转换。
            // TODO
         */
        Stage.prototype.stageToScreen = function (value, out) {
            return this;
        };
        Object.defineProperty(Stage.prototype, "rotated", {
            /**
             * 舞台是否因屏幕尺寸的改变而发生了旋转。
             * - 旋转不会影响渲染视口的宽高交替，引擎通过反向旋转外部画布来抵消屏幕的旋转。
             */
            get: function () {
                return this._rotated;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "matchFactor", {
            /**
             * 以宽或高适配的系数。
             * - `0.0` ~ `1.0`。
             * - `0.0` 以宽适配。
             * - `1.0` 以高适配。
             */
            get: function () {
                return this._matchFactor;
            },
            set: function (value) {
                if (this._matchFactor === value) {
                    return;
                }
                this._matchFactor = value;
                this._updateViewport();
                this.onResize.dispatch();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "screenSize", {
            /**
             * 屏幕尺寸。
             */
            get: function () {
                return this._screenSize;
            },
            set: function (value) {
                this._screenSize.w = value.w || 1.0;
                this._screenSize.h = value.h || 1.0;
                this._updateViewport();
                this.onScreenResize.dispatch();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "size", {
            /**
             * 舞台初始尺寸。
             */
            get: function () {
                return this._size;
            },
            set: function (value) {
                this._size.w = value.w || 1.0;
                this._size.h = value.h || 1.0;
                this._updateViewport();
                this.onResize.dispatch();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "viewport", {
            /**
             * 渲染视口。
             */
            get: function () {
                return this._viewport;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "screenViewport", {
            /**
             * @deprecated
             */
            get: function () {
                return this._viewport;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.editor.property("CHECKBOX" /* CHECKBOX */, { readonly: true })
        ], Stage.prototype, "rotated", null);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0, maximum: 1.0 })
        ], Stage.prototype, "matchFactor", null);
        __decorate([
            paper.editor.property("SIZE" /* SIZE */)
        ], Stage.prototype, "screenSize", null);
        __decorate([
            paper.editor.property("SIZE" /* SIZE */)
        ], Stage.prototype, "size", null);
        __decorate([
            paper.editor.property("RECT" /* RECT */, { readonly: true })
        ], Stage.prototype, "viewport", null);
        Stage = __decorate([
            paper.singleton
        ], Stage);
        return Stage;
    }(paper.BaseComponent));
    egret3d.Stage = Stage;
    __reflect(Stage.prototype, "egret3d.Stage");
    /**
     * 全局舞台信息组件实例。
     */
    egret3d.stage = null;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 提供默认的几何网格资源的快速访问方式。
     */
    var DefaultMeshes = (function (_super) {
        __extends(DefaultMeshes, _super);
        function DefaultMeshes() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultMeshes_1 = DefaultMeshes;
        DefaultMeshes.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            // TODO 颜色，更多类型。
            var attributesA = ["POSITION" /* POSITION */, "COLOR_0" /* COLOR_0 */];
            {
                var mesh = egret3d.Mesh.create(3, 0, attributesA);
                mesh.name = "builtin/triangle.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes_1.TRIANGLE = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    0.0, 0.5, 0.0,
                    -0.5, -0.5, 0.0,
                    0.5, -0.5, 0.0,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                ]);
            }
            {
                var mesh = egret3d.MeshBuilder.createPlane();
                mesh.name = "builtin/quad.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes_1.QUAD = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createPlane(1.0, 1.0, -0.5, 0.0);
                mesh.name = "builtin/quad_particle.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes_1.QUAD_PARTICLE = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createPlane();
                mesh.name = "builtin/sprite.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes_1.SPRITE = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createPlane(2.0, 2.0);
                mesh.name = "builtin/fullscreen_quad.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes_1.FULLSCREEN_QUAD = mesh;
                // 后期渲染专用，UV 反转一下，这样 shader 中就不用反转。
                var uvs = mesh.getUVs();
                for (var i = 1, l = uvs.length; i < l; i += 2) {
                    uvs[i] = 1.0 - uvs[i];
                }
            }
            {
                var mesh = egret3d.MeshBuilder.createPlane(10.0, 10.0);
                mesh.name = "builtin/plane.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes_1.PLANE = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createCube();
                mesh.name = "builtin/cube.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes_1.CUBE = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createCylinder(0.0, Math.sqrt(0.5), 1.0, 0.0, 0.0, 0.0, 4, 1, false, 0.7853981633974483 /* PI_QUARTER */);
                mesh.name = "builtin/pyramid.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes_1.PYRAMID = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createCylinder(0.0, 0.5, 1.0, 0.0, 0.0, 0.0, 10, 1);
                mesh.name = "builtin/cone.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes_1.CONE = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createCylinder();
                mesh.name = "builtin/cylinder.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes_1.CYLINDER = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createTorus();
                mesh.name = "builtin/torus.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes_1.TORUS = mesh;
            }
            {
                var mesh = egret3d.MeshBuilder.createSphere();
                mesh.name = "builtin/sphere.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes_1.SPHERE = mesh;
            }
            {
                var mesh = egret3d.Mesh.create(4, 2, attributesA);
                mesh.name = "builtin/line_x.mesh.bin";
                mesh.glTFMesh.primitives[0].mode = 1 /* Lines */;
                paper.Asset.register(mesh);
                DefaultMeshes_1.LINE_X = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    0.0, 0.0, 0.0,
                    1.0, 0.0, 0.0,
                    0.0, 0.0, 0.0,
                    1.0, 0.0, 0.0,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                ]);
                mesh.setIndices([0, 1], 0);
            }
            {
                var mesh = egret3d.Mesh.create(4, 2, attributesA);
                mesh.name = "builtin/line_y.mesh.bin";
                mesh.glTFMesh.primitives[0].mode = 1 /* Lines */;
                paper.Asset.register(mesh);
                DefaultMeshes_1.LINE_Y = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    0.0, 0.0, 0.0,
                    0.0, 1.0, 0.0,
                    0.0, 0.0, 0.0,
                    0.0, 1.0, 0.0,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                ]);
                mesh.setIndices([0, 1], 0);
            }
            {
                var mesh = egret3d.Mesh.create(4, 2, attributesA);
                mesh.name = "builtin/line_z.mesh.bin";
                mesh.glTFMesh.primitives[0].mode = 1 /* Lines */;
                paper.Asset.register(mesh);
                DefaultMeshes_1.LINE_Z = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    0.0, 0.0, 0.0,
                    0.0, 0.0, 1.0,
                    0.0, 0.0, 0.0,
                    0.0, 0.0, 1.0,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                    1.0, 1.0, 1.0, 1.0,
                ]);
                mesh.setIndices([0, 1], 0);
            }
            {
                var mesh = egret3d.MeshBuilder.createCircle();
                mesh.name = "builtin/circle_line.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes_1.CIRCLE_LINE = mesh;
            }
            {
                var mesh = egret3d.Mesh.create(8, 24, attributesA);
                mesh.name = "builtin/cube_line.mesh.bin";
                mesh.glTFMesh.primitives[0].mode = 1 /* Lines */;
                paper.Asset.register(mesh);
                DefaultMeshes_1.CUBE_LINE = mesh;
                //
                mesh.setAttributes("POSITION" /* POSITION */, [
                    // Z-
                    -0.5, 0.5, -0.5,
                    0.5, 0.5, -0.5,
                    0.5, -0.5, -0.5,
                    -0.5, -0.5, -0.5,
                    // Z+
                    0.5, 0.5, 0.5,
                    0.5, -0.5, 0.5,
                    -0.5, -0.5, 0.5,
                    -0.5, 0.5, 0.5,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                ]);
                mesh.setIndices([
                    0, 1, 1, 2, 2, 3, 3, 0,
                    4, 5, 5, 6, 6, 7, 7, 4,
                    0, 7, 1, 4, 2, 5, 3, 6,
                ]);
            }
        };
        /**
         * @deprecated
         */
        DefaultMeshes.createObject = function (mesh, name, tag, scene) {
            var gameObject = paper.GameObject.create(name, tag, scene);
            var meshFilter = gameObject.addComponent(egret3d.MeshFilter);
            var renderer = gameObject.addComponent(egret3d.MeshRenderer);
            meshFilter.mesh = mesh;
            switch (mesh) {
                case this.QUAD:
                case this.QUAD_PARTICLE:
                case this.PLANE:
                    renderer.material = egret3d.DefaultMaterials.MESH_BASIC_DOUBLESIDE;
                    break;
                case this.LINE_X:
                case this.LINE_Y:
                case this.LINE_Z:
                    renderer.material = egret3d.DefaultMaterials.LINEDASHED_COLOR;
                    break;
                case this.CIRCLE_LINE:
                case this.CUBE_LINE:
                    renderer.material = egret3d.DefaultMaterials.LINEDASHED;
                    break;
            }
            return gameObject;
        };
        DefaultMeshes = DefaultMeshes_1 = __decorate([
            paper.singleton
        ], DefaultMeshes);
        return DefaultMeshes;
        var DefaultMeshes_1;
    }(paper.BaseComponent));
    egret3d.DefaultMeshes = DefaultMeshes;
    __reflect(DefaultMeshes.prototype, "egret3d.DefaultMeshes");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 默认的纹理。
     */
    var DefaultTextures = (function (_super) {
        __extends(DefaultTextures, _super);
        function DefaultTextures() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultTextures_1 = DefaultTextures;
        DefaultTextures.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            var texture;
            texture = egret3d.Texture.createColorTexture("builtin/white.image.json", 255, 255, 255);
            DefaultTextures_1.WHITE = texture;
            paper.Asset.register(texture);
            texture = egret3d.Texture.createColorTexture("builtin/gray.image.json", 128, 128, 128);
            DefaultTextures_1.GRAY = texture;
            paper.Asset.register(texture);
            texture = egret3d.Texture.createGridTexture("builtin/grid.image.json");
            DefaultTextures_1.GRID = texture;
            paper.Asset.register(texture);
            texture = egret3d.Texture.createColorTexture("builtin/missing.image.json", 255, 0, 255);
            DefaultTextures_1.MISSING = texture;
            paper.Asset.register(texture);
        };
        DefaultTextures = DefaultTextures_1 = __decorate([
            paper.singleton
        ], DefaultTextures);
        return DefaultTextures;
        var DefaultTextures_1;
    }(paper.BaseComponent));
    egret3d.DefaultTextures = DefaultTextures;
    __reflect(DefaultTextures.prototype, "egret3d.DefaultTextures");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 默认的 shader。
     */
    var DefaultShaders = (function (_super) {
        __extends(DefaultShaders, _super);
        function DefaultShaders() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultShaders_1 = DefaultShaders;
        DefaultShaders.prototype._createShader = function (name, config, renderQueue, tStates, defines) {
            var shader = egret3d.Shader.create(name, config);
            if (renderQueue) {
                shader._renderQueue = renderQueue;
            }
            shader._states = {
                enable: [],
                functions: {},
            };
            egret3d.Shader.copyStates(tStates, shader._states);
            if (defines) {
                shader._defines = defines;
            }
            paper.Asset.register(shader);
            return shader;
        };
        DefaultShaders.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            //
            var helpMaterial = egret3d.Material.create("helpMaterial", egret3d.Shader.create("helpShader", egret3d.ShaderLib.linedashed));
            var helpStates = helpMaterial.technique.states;
            //
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* Back */);
            DefaultShaders_1.LINEDASHED = this._createShader("builtin/linedashed.shader.json", egret3d.ShaderLib.linedashed, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* Back */);
            DefaultShaders_1.VERTEX_COLOR = this._createShader("builtin/vertcolor.shader.json", egret3d.ShaderLib.meshbasic, 2000 /* Geometry */, helpStates, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* Back */);
            DefaultShaders_1.MESH_BASIC = this._createShader("builtin/meshbasic.shader.json", egret3d.ShaderLib.meshbasic, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* Back */);
            DefaultShaders_1.MESH_NORMAL = this._createShader("builtin/meshnormal.shader.json", egret3d.ShaderLib.normal, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* Back */);
            DefaultShaders_1.MESH_LAMBERT = this._createShader("builtin/meshlambert.shader.json", egret3d.ShaderLib.meshlambert, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* Back */);
            DefaultShaders_1.MESH_PHONG = this._createShader("builtin/meshphong.shader.json", egret3d.ShaderLib.meshphong, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* Back */);
            DefaultShaders_1.MESH_PHYSICAL = this._createShader("builtin/meshphysical.shader.json", egret3d.ShaderLib.meshphysical, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* Back */);
            DefaultShaders_1.MESH_STANDARD = this._createShader("builtin/meshstandard.shader.json", egret3d.ShaderLib.meshphysical, 2000 /* Geometry */, helpStates, ["STANDARD" /* STANDARD */]);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(false);
            DefaultShaders_1.PARTICLE = this._createShader("builtin/particle.shader.json", egret3d.ShaderLib.particle, 2000 /* Geometry */, helpStates, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders_1.POINTS = this._createShader("builtin/points.shader.json", egret3d.ShaderLib.points, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders_1.SPRITE = this._createShader("builtin/sprite.shader.json", egret3d.ShaderLib.sprite, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, false).setCullFace(true, 2305 /* CCW */, 1028 /* Front */);
            DefaultShaders_1.CUBE = this._createShader("builtin/cube.shader.json", egret3d.ShaderLib.cube, 1000 /* Background */, helpStates);
            helpMaterial.clearStates().setDepth(true, false).setCullFace(true, 2305 /* CCW */, 1028 /* Front */);
            DefaultShaders_1.EQUIRECT = this._createShader("builtin/equirect.shader.json", egret3d.ShaderLib.equirect, 1000 /* Background */, helpStates);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders_1.DEPTH = this._createShader("builtin/depth.shader.json", egret3d.ShaderLib.depth, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders_1.DISTANCE_RGBA = this._createShader("builtin/distance_rgba.shader.json", egret3d.ShaderLib.distanceRGBA, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders_1.SHADOW = this._createShader("builtin/shadow.shader.json", egret3d.ShaderLib.shadow, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders_1.COPY = this._createShader("builtin/copy.shader.json", egret3d.ShaderLib.copy, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders_1.FXAA = this._createShader("builtin/fxaa.shader.json", egret3d.ShaderLib.fxaa, 2000 /* Geometry */, helpStates);
            // deprecated
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders_1.MATERIAL_COLOR = this._createShader("builtin/materialcolor.shader.json", egret3d.ShaderLib.meshbasic, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders_1.MESH_BASIC_DOUBLESIDE = this._createShader("builtin/meshbasic_doubleside.shader.json", egret3d.ShaderLib.meshbasic, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders_1.MESH_LAMBERT_DOUBLESIDE = this._createShader("builtin/meshlambert_doubleside.shader.json", egret3d.ShaderLib.meshlambert, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders_1.MESH_PHONE_DOUBLESIDE = this._createShader("builtin/meshphong_doubleside.shader.json", egret3d.ShaderLib.meshphong, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders_1.MESH_PHYSICAL_DOUBLESIDE = this._createShader("builtin/meshphysical_doubleside.shader.json", egret3d.ShaderLib.meshphysical, 2000 /* Geometry */, helpStates);
            helpMaterial.clearStates().setDepth(true, false).setCullFace(true, 2305 /* CCW */, 1029 /* Back */).setBlend(2 /* Blend */, 3000 /* Blend */);
            DefaultShaders_1.TRANSPARENT_COLOR = this._createShader("builtin/transparent_color.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Blend */, helpStates);
            helpMaterial.clearStates().setDepth(true, false).setCullFace(true, 2305 /* CCW */, 1029 /* Back */).setBlend(2 /* Normal */, 3000 /* Blend */);
            DefaultShaders_1.TRANSPARENT = this._createShader("builtin/transparent.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Blend */, helpStates);
            helpMaterial.clearStates().setDepth(true, false).setBlend(2 /* Blend */, 3000 /* Blend */);
            DefaultShaders_1.TRANSPARENT_DOUBLESIDE = this._createShader("builtin/transparent_doubleside.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Blend */, helpStates);
            helpMaterial.clearStates().setDepth(true, false).setCullFace(true, 2305 /* CCW */, 1029 /* Back */).setBlend(4 /* Add */, 3000 /* Blend */);
            DefaultShaders_1.TRANSPARENT_ADDITIVE = this._createShader("builtin/transparent_additive.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Blend */, helpStates);
            helpMaterial.clearStates().setDepth(true, false).setBlend(4 /* Add */, 3000 /* Blend */);
            DefaultShaders_1.TRANSPARENT_ADDITIVE_DOUBLESIDE = this._createShader("builtin/transparent_additive_doubleside.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Blend */, helpStates);
            helpMaterial.clearStates().setDepth(true, false).setCullFace(true, 2305 /* CCW */, 1029 /* Back */).setBlend(16 /* Multiply */, 3000 /* Blend */);
            DefaultShaders_1.TRANSPARENT_MULTIPLY = this._createShader("builtin/transparent_multiply.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Blend */, helpStates);
            helpMaterial.clearStates().setDepth(true, false).setBlend(16 /* Multiply */, 3000 /* Blend */);
            DefaultShaders_1.TRANSPARENT_MULTIPLY_DOUBLESIDE = this._createShader("builtin/transparent_multiply_doubleside.shader.json", egret3d.ShaderLib.meshbasic, 3000 /* Blend */, helpStates);
            helpMaterial.clearStates().setDepth(true, false).setBlend(2 /* Blend */, 3000 /* Blend */).setCullFace(false);
            DefaultShaders_1.PARTICLE_BLEND = this._createShader("builtin/particle_blend.shader.json", egret3d.ShaderLib.particle, 3000 /* Blend */, helpStates, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(4 /* Add */, 3000 /* Blend */).setCullFace(false);
            DefaultShaders_1.PARTICLE_ADDITIVE = this._createShader("builtin/particle_additive.shader.json", egret3d.ShaderLib.particle, 3000 /* Blend */, helpStates, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(16 /* Multiply */, 3000 /* Blend */).setCullFace(false);
            DefaultShaders_1.PARTICLE_MULTIPLY = this._createShader("builtin/particle_multiply.shader.json", egret3d.ShaderLib.particle, 3000 /* Blend */, helpStates, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(3 /* Blend_PreMultiply */, 3000 /* Blend */).setCullFace(false);
            DefaultShaders_1.PARTICLE_BLEND_PREMULTIPLY = this._createShader("builtin/particle_blend_premultiply.shader.json", egret3d.ShaderLib.particle, 3000 /* Blend */, helpStates, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(5 /* Add_PreMultiply */, 3000 /* Blend */).setCullFace(false);
            DefaultShaders_1.PARTICLE_ADDITIVE_PREMULTIPLY = this._createShader("builtin/particle_additive_premultiply.shader.json", egret3d.ShaderLib.particle, 3000 /* Blend */, helpStates, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(17 /* Multiply_PreMultiply */, 3000 /* Blend */).setCullFace(false);
            DefaultShaders_1.PARTICLE_MULTIPLY_PREMULTIPLY = this._createShader("builtin/particle_multiply_premultiply.shader.json", egret3d.ShaderLib.particle, 3000 /* Blend */, helpStates, ["USE_COLOR" /* USE_COLOR */]);
            helpMaterial.dispose();
        };
        DefaultShaders = DefaultShaders_1 = __decorate([
            paper.singleton
        ], DefaultShaders);
        return DefaultShaders;
        var DefaultShaders_1;
    }(paper.BaseComponent));
    egret3d.DefaultShaders = DefaultShaders;
    __reflect(DefaultShaders.prototype, "egret3d.DefaultShaders");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 默认的材质。
     */
    var DefaultMaterials = (function (_super) {
        __extends(DefaultMaterials, _super);
        function DefaultMaterials() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultMaterials_1 = DefaultMaterials;
        DefaultMaterials.prototype._createMaterial = function (name, shader) {
            var material = egret3d.Material.create(name, shader);
            paper.Asset.register(material);
            return material;
        };
        DefaultMaterials.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            DefaultMaterials_1.MESH_BASIC = this._createMaterial("builtin/meshbasic.mat.json", egret3d.DefaultShaders.MESH_BASIC)
                .setTexture(egret3d.DefaultTextures.WHITE);
            DefaultMaterials_1.MESH_BASIC_DOUBLESIDE = this._createMaterial("builtin/meshbasic_doubleside.mat.json", egret3d.DefaultShaders.MESH_BASIC)
                .setTexture(egret3d.DefaultTextures.WHITE)
                .setCullFace(false);
            DefaultMaterials_1.MESH_LAMBERT = this._createMaterial("builtin/meshlambert.mat.json", egret3d.DefaultShaders.MESH_LAMBERT)
                .setTexture(egret3d.DefaultTextures.WHITE);
            DefaultMaterials_1.MESH_LAMBERT_DOUBLESIDE = this._createMaterial("builtin/meshlambert_doubleside.mat.json", egret3d.DefaultShaders.MESH_LAMBERT)
                .setTexture(egret3d.DefaultTextures.WHITE)
                .setCullFace(false);
            DefaultMaterials_1.MESH_PHONG = this._createMaterial("builtin/meshphong.mat.json", egret3d.DefaultShaders.MESH_PHONG);
            DefaultMaterials_1.LINEDASHED = this._createMaterial("builtin/linedashed.mat.json", egret3d.DefaultShaders.LINEDASHED);
            DefaultMaterials_1.LINEDASHED_COLOR = this._createMaterial("builtin/linedashed_color.mat.json", egret3d.DefaultShaders.LINEDASHED)
                .addDefine("USE_COLOR" /* USE_COLOR */);
            DefaultMaterials_1.CUBE = this._createMaterial("builtin/cube.mat.json", egret3d.DefaultShaders.CUBE);
            DefaultMaterials_1.MISSING = this._createMaterial("builtin/missing.mat.json", egret3d.DefaultShaders.MESH_BASIC)
                .setColor(egret3d.Color.PURPLE);
            DefaultMaterials_1.SHADOW_DEPTH_3200 = this._createMaterial("builtin/shadow_depth_3200.mat.json", egret3d.DefaultShaders.DEPTH)
                .setDepth(true, true)
                .setCullFace(true, 2305 /* CCW */, 1029 /* Back */)
                .addDefine("DEPTH_PACKING 3200" /* DEPTH_PACKING_3200 */);
            DefaultMaterials_1.SHADOW_DEPTH_3201 = this._createMaterial("builtin/shadow_depth_3201.mat.json", egret3d.DefaultShaders.DEPTH)
                .setDepth(true, true)
                .setCullFace(true, 2305 /* CCW */, 1029 /* Back */)
                .addDefine("DEPTH_PACKING 3201" /* DEPTH_PACKING_3201 */);
            DefaultMaterials_1.SHADOW_DISTANCE = this._createMaterial("builtin/shadow_distance.mat.json", egret3d.DefaultShaders.DISTANCE_RGBA)
                .setDepth(true, true)
                .addDefine("FLIP_SIDED" /* FLIP_SIDED */).addDefine("USE_SHADOWMAP" /* USE_SHADOWMAP */)
                .setCullFace(true, 2305 /* CCW */, 1029 /* Back */);
            DefaultMaterials_1.COPY = this._createMaterial("builtin/copy.mat.json", egret3d.DefaultShaders.COPY);
            DefaultMaterials_1.FXAA = this._createMaterial("builtin/fxaa.mat.json", egret3d.DefaultShaders.FXAA);
        };
        DefaultMaterials = DefaultMaterials_1 = __decorate([
            paper.singleton
        ], DefaultMaterials);
        return DefaultMaterials;
        var DefaultMaterials_1;
    }(paper.BaseComponent));
    egret3d.DefaultMaterials = DefaultMaterials;
    __reflect(DefaultMaterials.prototype, "egret3d.DefaultMaterials");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var LightCountDirty;
    (function (LightCountDirty) {
        LightCountDirty[LightCountDirty["None"] = 0] = "None";
        LightCountDirty[LightCountDirty["DirectionalLight"] = 1] = "DirectionalLight";
        LightCountDirty[LightCountDirty["SpotLight"] = 2] = "SpotLight";
        LightCountDirty[LightCountDirty["RectangleAreaLight"] = 4] = "RectangleAreaLight";
        LightCountDirty[LightCountDirty["PointLight"] = 8] = "PointLight";
        LightCountDirty[LightCountDirty["HemisphereLight"] = 16] = "HemisphereLight";
    })(LightCountDirty = egret3d.LightCountDirty || (egret3d.LightCountDirty = {}));
    /**
     * 全局摄像机和灯光组件。
     */
    var CameraAndLightCollecter = (function (_super) {
        __extends(CameraAndLightCollecter, _super);
        function CameraAndLightCollecter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * TODO
             */
            _this.lightCountDirty = LightCountDirty.None;
            /**
             *
             */
            _this.postprocessingCamera = null;
            /**
             *
             */
            _this.shadowCamera = null;
            /**
             *
             */
            _this.cameras = [];
            /**
             *
             */
            _this.lights = [];
            /**
             *
             */
            _this.directionalLights = [];
            /**
             *
             */
            _this.spotLights = [];
            /**
             *
             */
            _this.rectangleAreaLights = [];
            /**
             *
             */
            _this.pointLights = [];
            /**
             *
             */
            _this.hemisphereLights = [];
            /**
             * 在渲染阶段正在执行渲染的相机组件。
             * - 通常在后期渲染和渲染前生命周期中使用。
             */
            _this.currentCamera = null;
            /**
             * 在渲染阶段正在执行阴影渲染的灯光组件。
             */
            _this.currentShadowLight = null;
            return _this;
        }
        CameraAndLightCollecter.prototype._sortCameras = function (a, b) {
            // renderTarget 相机应优先渲染。
            var aOrder = (a.renderTarget || a._previewRenderTarget) ? a.order : (a.order * 1000 + 1);
            var bOrder = (b.renderTarget || b._previewRenderTarget) ? b.order : (b.order * 1000 + 1);
            return aOrder - bOrder;
        };
        /**
         * @internal
         */
        CameraAndLightCollecter.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            egret3d.cameraAndLightCollecter = this;
            {
                var gameObject = paper.GameObject.create("Postprocessing Camera", "Global" /* Global */, paper.Application.sceneManager.globalScene);
                //
                var camera = gameObject.getOrAddComponent(egret3d.Camera);
                camera.enabled = false;
                camera.opvalue = 0.0;
                camera.size = 1.0;
                camera.near = 0.01;
                camera.far = 1.0;
                camera.projectionMatrix = egret3d.Matrix4.IDENTITY;
                //
                this.postprocessingCamera = camera;
            }
            {
                var gameObject = paper.GameObject.create("Shadow Camera", "Global" /* Global */, paper.Application.sceneManager.globalScene);
                //
                var camera = gameObject.getOrAddComponent(egret3d.Camera);
                camera.enabled = false;
                //
                this.shadowCamera = camera;
            }
        };
        /**
         * 更新相机。
         */
        CameraAndLightCollecter.prototype.updateCameras = function (entities) {
            this.cameras.length = 0;
            for (var _i = 0, entities_2 = entities; _i < entities_2.length; _i++) {
                var entity = entities_2[_i];
                this.cameras.push(entity.getComponent(egret3d.Camera));
            }
        };
        /**
         * 更新灯光。
         */
        CameraAndLightCollecter.prototype.updateLights = function (entities) {
            var directLightCount = 0, spotLightCount = 0, rectangleAreaLightCount = 0, pointLightCount = 0, hemisphereLightCount = 0;
            var _a = this, lights = _a.lights, directionalLights = _a.directionalLights, spotLights = _a.spotLights, rectangleAreaLights = _a.rectangleAreaLights, pointLights = _a.pointLights, hemisphereLights = _a.hemisphereLights;
            lights.length = 0;
            for (var _i = 0, entities_3 = entities; _i < entities_3.length; _i++) {
                var entity = entities_3[_i];
                var light = entity.getComponent(egret3d.BaseLight, true);
                lights.push(light);
                switch (light.constructor) {
                    case egret3d.DirectionalLight:
                        directLightCount++;
                        break;
                    case egret3d.SpotLight:
                        spotLightCount++;
                        break;
                    case egret3d.RectangleAreaLight:
                        rectangleAreaLightCount++;
                        break;
                    case egret3d.PointLight:
                        pointLightCount++;
                        break;
                    case egret3d.HemisphereLight:
                        hemisphereLightCount++;
                        break;
                }
            }
            var defines = egret3d.renderState.defines;
            // if (directLightCount !== directionalLights.length) {
            if (directLightCount > 0) {
                var define = defines.addDefine("NUM_DIR_LIGHTS" /* NUM_DIR_LIGHTS */, directLightCount);
                if (define) {
                    define.type = 0 /* None */;
                }
            }
            else {
                defines.removeDefine("NUM_DIR_LIGHTS" /* NUM_DIR_LIGHTS */);
            }
            this.lightCountDirty |= LightCountDirty.DirectionalLight;
            directionalLights.length = directLightCount;
            var index = 0;
            for (var _b = 0, lights_1 = lights; _b < lights_1.length; _b++) {
                var light = lights_1[_b];
                if (light.constructor !== egret3d.DirectionalLight) {
                    continue;
                }
                directionalLights[index++] = light;
            }
            // }
            // if (spotLightCount !== spotLights.length) {
            if (spotLightCount > 0) {
                var define = defines.addDefine("NUM_SPOT_LIGHTS" /* NUM_SPOT_LIGHTS */, spotLightCount);
                if (define) {
                    define.type = 0 /* None */;
                }
            }
            else {
                defines.removeDefine("NUM_SPOT_LIGHTS" /* NUM_SPOT_LIGHTS */);
            }
            this.lightCountDirty |= LightCountDirty.SpotLight;
            spotLights.length = spotLightCount;
            index = 0;
            for (var _c = 0, lights_2 = lights; _c < lights_2.length; _c++) {
                var light = lights_2[_c];
                if (light.constructor !== egret3d.SpotLight) {
                    continue;
                }
                spotLights[index++] = light;
            }
            // }
            // if (rectangleAreaLightCount !== rectangleAreaLights.length) {
            if (rectangleAreaLightCount > 0) {
                var define = defines.addDefine("NUM_RECT_AREA_LIGHTS" /* NUM_RECT_AREA_LIGHTS */, rectangleAreaLightCount);
                if (define) {
                    define.type = 0 /* None */;
                }
            }
            else {
                defines.removeDefine("NUM_RECT_AREA_LIGHTS" /* NUM_RECT_AREA_LIGHTS */);
            }
            this.lightCountDirty |= LightCountDirty.RectangleAreaLight;
            rectangleAreaLights.length = rectangleAreaLightCount;
            index = 0;
            for (var _d = 0, lights_3 = lights; _d < lights_3.length; _d++) {
                var light = lights_3[_d];
                if (light.constructor !== egret3d.RectangleAreaLight) {
                    continue;
                }
                rectangleAreaLights[index++] = light;
            }
            // }
            // if (pointLightCount !== pointLights.length) {
            if (pointLightCount > 0) {
                var define = defines.addDefine("NUM_POINT_LIGHTS" /* NUM_POINT_LIGHTS */, pointLightCount);
                if (define) {
                    define.type = 0 /* None */;
                }
            }
            else {
                defines.removeDefine("NUM_POINT_LIGHTS" /* NUM_POINT_LIGHTS */);
            }
            this.lightCountDirty |= LightCountDirty.PointLight;
            pointLights.length = pointLightCount;
            index = 0;
            for (var _e = 0, lights_4 = lights; _e < lights_4.length; _e++) {
                var light = lights_4[_e];
                if (light.constructor !== egret3d.PointLight) {
                    continue;
                }
                pointLights[index++] = light;
            }
            // }
            // if (hemisphereLightCount !== hemisphereLights.length) {
            if (hemisphereLightCount > 0) {
                var define = defines.addDefine("NUM_HEMI_LIGHTS" /* NUM_HEMI_LIGHTS */, hemisphereLightCount);
                if (define) {
                    define.type = 0 /* None */;
                }
            }
            else {
                defines.removeDefine("NUM_HEMI_LIGHTS" /* NUM_HEMI_LIGHTS */);
            }
            this.lightCountDirty |= LightCountDirty.HemisphereLight;
            hemisphereLights.length = hemisphereLightCount;
            index = 0;
            for (var _f = 0, lights_5 = lights; _f < lights_5.length; _f++) {
                var light = lights_5[_f];
                if (light.constructor !== egret3d.HemisphereLight) {
                    continue;
                }
                hemisphereLights[index++] = light;
            }
            // }
        };
        /**
         * 排序相机。
         */
        CameraAndLightCollecter.prototype.sortCameras = function () {
            this.cameras.sort(this._sortCameras);
        };
        Object.defineProperty(CameraAndLightCollecter.prototype, "cameraCount", {
            /**
             * 相机计数。
             */
            get: function () {
                return this.cameras.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CameraAndLightCollecter.prototype, "lightCount", {
            /**
             * 灯光计数。
             */
            get: function () {
                return this.directionalLights.length
                    + this.spotLights.length
                    + this.rectangleAreaLights.length
                    + this.pointLights.length
                    + this.hemisphereLights.length;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.editor.property("UINT" /* UINT */, { readonly: true })
        ], CameraAndLightCollecter.prototype, "cameraCount", null);
        __decorate([
            paper.editor.property("UINT" /* UINT */, { readonly: true })
        ], CameraAndLightCollecter.prototype, "lightCount", null);
        CameraAndLightCollecter = __decorate([
            paper.singleton
        ], CameraAndLightCollecter);
        return CameraAndLightCollecter;
    }(paper.BaseComponent));
    egret3d.CameraAndLightCollecter = CameraAndLightCollecter;
    __reflect(CameraAndLightCollecter.prototype, "egret3d.CameraAndLightCollecter");
    /**
     * 全局摄像机和灯光组件实例。
     */
    egret3d.cameraAndLightCollecter = null;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 全局绘制信息组件。
     */
    var DrawCallCollecter = (function (_super) {
        __extends(DrawCallCollecter, _super);
        function DrawCallCollecter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             *
             */
            _this.drawCallCount = 0;
            /**
             * 专用于天空盒渲染的绘制信息。
             */
            _this.skyBox = egret3d.DrawCall.create();
            /**
             * 专用于后期渲染的绘制信息。
             */
            _this.postprocessing = egret3d.DrawCall.create();
            // /**
            //  * 此帧新添加的绘制信息列表。
            //  */
            // public readonly addDrawCalls: (DrawCall | null)[] = [];
            _this._drawCallsDirty = false;
            _this._entities = [];
            _this._drawCalls = [];
            return _this;
        }
        /**
         * @interal
         */
        DrawCallCollecter.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            egret3d.drawCallCollecter = this;
            this.skyBox.subMeshIndex = 0;
            this.postprocessing.matrix = egret3d.Matrix4.IDENTITY;
            this.postprocessing.subMeshIndex = 0;
            this.postprocessing.mesh = egret3d.DefaultMeshes.FULLSCREEN_QUAD;
        };
        /**
         * 添加绘制信息。
         * @param drawCall
         */
        DrawCallCollecter.prototype.addDrawCall = function (drawCall) {
            var _a = this, _entities = _a._entities, _drawCalls = _a._drawCalls;
            var entity = drawCall.entity;
            if (_entities.indexOf(entity) < 0) {
                _entities[_entities.length] = entity;
            }
            _drawCalls[_drawCalls.length] = drawCall;
        };
        /**
         * 移除指定渲染组件的绘制信息列表。
         */
        DrawCallCollecter.prototype.removeDrawCalls = function (entity) {
            var _a = this, _entities = _a._entities, _drawCalls = _a._drawCalls;
            var index = _entities.indexOf(entity);
            if (index < 0) {
                return false;
            }
            var i = _drawCalls.length;
            while (i--) {
                var drawCall = _drawCalls[i];
                if (drawCall && drawCall.entity === entity) {
                    _drawCalls[i] = null;
                    drawCall.release();
                }
            }
            _entities[index] = null;
            this._drawCallsDirty = true;
            return true;
        };
        /**
         * 是否包含指定渲染组件的绘制信息列表。
         */
        DrawCallCollecter.prototype.hasDrawCalls = function (entity) {
            return this._entities.indexOf(entity) >= 0;
        };
        Object.defineProperty(DrawCallCollecter.prototype, "drawCalls", {
            /**
             * 此帧可能参与渲染的绘制信息列表。
             * - 未进行视锥剔除的。
             */
            get: function () {
                var _a = this, _entities = _a._entities, _drawCalls = _a._drawCalls;
                if (this._drawCallsDirty) {
                    paper.utility.filterArray(_entities, null);
                    paper.utility.filterArray(_drawCalls, null);
                    this._drawCallsDirty = false;
                }
                return _drawCalls;
            },
            enumerable: true,
            configurable: true
        });
        DrawCallCollecter = __decorate([
            paper.singleton
        ], DrawCallCollecter);
        return DrawCallCollecter;
    }(paper.BaseComponent));
    egret3d.DrawCallCollecter = DrawCallCollecter;
    __reflect(DrawCallCollecter.prototype, "egret3d.DrawCallCollecter");
    /**
     * 全局绘制信息收集组件实例。
     */
    egret3d.drawCallCollecter = null;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 全局碰撞信息收集组件。
     */
    var ContactCollecter = (function (_super) {
        __extends(ContactCollecter, _super);
        function ContactCollecter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 当前帧开始碰撞的。
             */
            _this.begin = [];
            /**
             * 当前帧维持碰撞的。
             */
            _this.stay = [];
            /**
             * 当前帧结束碰撞的。
             */
            _this.end = [];
            return _this;
        }
        /**
         * @internal
         */
        ContactCollecter.prototype._update = function () {
            if (this.begin.length > 0) {
                this.begin.length = 0;
            }
            if (this.end.length > 0) {
                this.end.length = 0;
            }
        };
        ContactCollecter = __decorate([
            paper.singleton
        ], ContactCollecter);
        return ContactCollecter;
    }(paper.BaseComponent));
    egret3d.ContactCollecter = ContactCollecter;
    __reflect(ContactCollecter.prototype, "egret3d.ContactCollecter");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * Pointer 按钮的类型。
     * - https://www.w3.org/TR/pointerevents/#the-button-property
     */
    var PointerButtonType;
    (function (PointerButtonType) {
        PointerButtonType[PointerButtonType["None"] = -1] = "None";
        PointerButtonType[PointerButtonType["LeftMouse"] = 0] = "LeftMouse";
        PointerButtonType[PointerButtonType["TouchContact"] = 0] = "TouchContact";
        PointerButtonType[PointerButtonType["Pencontac"] = 0] = "Pencontac";
        PointerButtonType[PointerButtonType["MiddleMouse"] = 1] = "MiddleMouse";
        PointerButtonType[PointerButtonType["RightMouse"] = 2] = "RightMouse";
        PointerButtonType[PointerButtonType["PenBarrel"] = 2] = "PenBarrel";
        PointerButtonType[PointerButtonType["Back"] = 3] = "Back";
        PointerButtonType[PointerButtonType["X1"] = 3] = "X1";
        PointerButtonType[PointerButtonType["Forward"] = 4] = "Forward";
        PointerButtonType[PointerButtonType["X2"] = 4] = "X2";
        PointerButtonType[PointerButtonType["PenEraser"] = 5] = "PenEraser";
    })(PointerButtonType = egret3d.PointerButtonType || (egret3d.PointerButtonType = {}));
    /**
     * Pointer 按钮的状态类型。
     * - https://www.w3.org/TR/pointerevents/#the-buttons-property
     */
    var PointerButtonsType;
    (function (PointerButtonsType) {
        PointerButtonsType[PointerButtonsType["None"] = 0] = "None";
        PointerButtonsType[PointerButtonsType["LeftMouse"] = 1] = "LeftMouse";
        PointerButtonsType[PointerButtonsType["TouchContact"] = 1] = "TouchContact";
        PointerButtonsType[PointerButtonsType["PenContac"] = 1] = "PenContac";
        PointerButtonsType[PointerButtonsType["MiddleMouse"] = 4] = "MiddleMouse";
        PointerButtonsType[PointerButtonsType["RightMouse"] = 2] = "RightMouse";
        PointerButtonsType[PointerButtonsType["PenBarrel"] = 2] = "PenBarrel";
        PointerButtonsType[PointerButtonsType["Back"] = 8] = "Back";
        PointerButtonsType[PointerButtonsType["X1"] = 8] = "X1";
        PointerButtonsType[PointerButtonsType["Forward"] = 16] = "Forward";
        PointerButtonsType[PointerButtonsType["X2"] = 16] = "X2";
        PointerButtonsType[PointerButtonsType["PenEraser"] = 32] = "PenEraser";
    })(PointerButtonsType = egret3d.PointerButtonsType || (egret3d.PointerButtonsType = {}));
    /**
     * 按键类型。
     */
    var KeyCode;
    (function (KeyCode) {
        KeyCode["Unknown"] = "Unknown";
        KeyCode["F1"] = "F1";
        KeyCode["F2"] = "F2";
        KeyCode["F3"] = "F3";
        KeyCode["F4"] = "F4";
        KeyCode["F5"] = "F5";
        KeyCode["F6"] = "F6";
        KeyCode["F7"] = "F7";
        KeyCode["F8"] = "F8";
        KeyCode["F9"] = "F9";
        KeyCode["F10"] = "F10";
        KeyCode["F11"] = "F11";
        KeyCode["F12"] = "F12";
        KeyCode["Digit0"] = "Digit0";
        KeyCode["Digit1"] = "Digit1";
        KeyCode["Digit2"] = "Digit2";
        KeyCode["Digit3"] = "Digit3";
        KeyCode["Digit4"] = "Digit4";
        KeyCode["Digit5"] = "Digit5";
        KeyCode["Digit6"] = "Digit6";
        KeyCode["Digit7"] = "Digit7";
        KeyCode["Digit8"] = "Digit8";
        KeyCode["Digit9"] = "Digit9";
        KeyCode["KeyA"] = "KeyA";
        KeyCode["KeyB"] = "KeyB";
        KeyCode["KeyC"] = "KeyC";
        KeyCode["KeyD"] = "KeyD";
        KeyCode["KeyE"] = "KeyE";
        KeyCode["KeyF"] = "KeyF";
        KeyCode["KeyG"] = "KeyG";
        KeyCode["KeyH"] = "KeyH";
        KeyCode["KeyI"] = "KeyI";
        KeyCode["KeyJ"] = "KeyJ";
        KeyCode["KeyK"] = "KeyK";
        KeyCode["KeyL"] = "KeyL";
        KeyCode["KeyM"] = "KeyM";
        KeyCode["KeyN"] = "KeyN";
        KeyCode["KeyO"] = "KeyO";
        KeyCode["KeyP"] = "KeyP";
        KeyCode["KeyQ"] = "KeyQ";
        KeyCode["KeyR"] = "KeyR";
        KeyCode["KeyS"] = "KeyS";
        KeyCode["KeyT"] = "KeyT";
        KeyCode["KeyU"] = "KeyU";
        KeyCode["KeyV"] = "KeyV";
        KeyCode["KeyW"] = "KeyW";
        KeyCode["KeyX"] = "KeyX";
        KeyCode["KeyY"] = "KeyY";
        KeyCode["KeyZ"] = "KeyZ";
        KeyCode["Backquote"] = "Backquote";
        KeyCode["Minus"] = "Minus";
        KeyCode["Equal"] = "Equal";
        KeyCode["BracketLeft"] = "BracketLeft";
        KeyCode["BracketRight"] = "BracketRight";
        KeyCode["Backslash"] = "Backslash";
        KeyCode["Semicolon"] = "Semicolon";
        KeyCode["Quote"] = "Quote";
        KeyCode["Comma"] = "Comma";
        KeyCode["Period"] = "Period";
        KeyCode["Slash"] = "Slash";
        KeyCode["Escape"] = "Escape";
        KeyCode["ScrollLock"] = "ScrollLock";
        KeyCode["Pause"] = "Pause";
        KeyCode["Backspace"] = "Backspace";
        KeyCode["Tab"] = "Tab";
        KeyCode["CapsLock"] = "CapsLock";
        KeyCode["Space"] = "Space";
        KeyCode["ContextMenu"] = "ContextMenu";
        KeyCode["ShiftLeft"] = "ShiftLeft";
        KeyCode["ControlLeft"] = "ControlLeft";
        KeyCode["AltLeft"] = "AltLeft";
        KeyCode["MetaLeft"] = "MetaLeft";
        KeyCode["ShiftRight"] = "ShiftRight";
        KeyCode["ControlRight"] = "ControlRight";
        KeyCode["AltRight"] = "AltRight";
        KeyCode["MetaRight"] = "MetaRight";
        KeyCode["Insert"] = "Insert";
        KeyCode["Delete"] = "Delete";
        KeyCode["Home"] = "Home";
        KeyCode["End"] = "End";
        KeyCode["PageUp"] = "PageUp";
        KeyCode["PageDown"] = "PageDown";
        KeyCode["ArrowUp"] = "ArrowUp";
        KeyCode["ArrowDown"] = "ArrowDown";
        KeyCode["ArrowLeft"] = "ArrowLeft";
        KeyCode["ArrowRight"] = "ArrowRight";
        KeyCode["NumpadLock"] = "NumLock";
        KeyCode["NumpadDivide"] = "NumpadDivide";
        KeyCode["NumpadMultiply"] = "NumpadMultiply";
        KeyCode["NumpadSubtract"] = "NumpadSubtract";
        KeyCode["NumpadAdd"] = "NumpadAdd";
        KeyCode["NumpadEnter"] = "NumpadEnter";
        KeyCode["NumpadDecimal"] = "NumpadDecimal";
        KeyCode["Numpad0"] = "Numpad0";
        KeyCode["Numpad1"] = "Numpad1";
        KeyCode["Numpad2"] = "Numpad2";
        KeyCode["Numpad3"] = "Numpad3";
        KeyCode["Numpad4"] = "Numpad4";
        KeyCode["Numpad5"] = "Numpad5";
        KeyCode["Numpad6"] = "Numpad6";
        KeyCode["Numpad7"] = "Numpad7";
        KeyCode["Numpad8"] = "Numpad8";
        KeyCode["Numpad9"] = "Numpad9";
    })(KeyCode = egret3d.KeyCode || (egret3d.KeyCode = {}));
    var _keyToCode = [
        "`", "Backquote" /* Backquote */,
        "1", "Digit1" /* Digit1 */,
        "2", "Digit2" /* Digit2 */,
        "3", "Digit3" /* Digit3 */,
        "4", "Digit4" /* Digit4 */,
        "5", "Digit5" /* Digit5 */,
        "6", "Digit6" /* Digit6 */,
        "7", "Digit7" /* Digit7 */,
        "8", "Digit8" /* Digit8 */,
        "9", "Digit9" /* Digit9 */,
        "0", "Digit0" /* Digit0 */,
        "-", "Minus" /* Minus */,
        "=", "Equal" /* Equal */,
        "[", "BracketLeft" /* BracketLeft */,
        "]", "BracketRight" /* BracketRight */,
        "\\", "Backslash" /* Backslash */,
        ";", "Semicolon" /* Semicolon */,
        "'", "Quote" /* Quote */,
        ",", "Comma" /* Comma */,
        ".", "Period" /* Period */,
        "/", "Slash" /* Slash */,
        "~", "Backquote" /* Backquote */,
        "!", "Digit1" /* Digit1 */,
        "@", "Digit2" /* Digit2 */,
        "#", "Digit3" /* Digit3 */,
        "$", "Digit4" /* Digit4 */,
        "%", "Digit5" /* Digit5 */,
        "^", "Digit6" /* Digit6 */,
        "&", "Digit7" /* Digit7 */,
        "*", "Digit8" /* Digit8 */,
        "(", "Digit9" /* Digit9 */,
        ")", "Digit0" /* Digit0 */,
        "_", "Minus" /* Minus */,
        "+", "Equal" /* Equal */,
        "{", "BracketLeft" /* BracketLeft */,
        "}", "BracketRight" /* BracketRight */,
        "|", "Backslash" /* Backslash */,
        ":", "Semicolon" /* Semicolon */,
        '"', "Quote" /* Quote */,
        "<", "Comma" /* Comma */,
        ">", "Period" /* Period */,
        "?", "Slash" /* Slash */,
        "a", "KeyA" /* KeyA */,
        "b", "KeyB" /* KeyB */,
        "c", "KeyC" /* KeyC */,
        "d", "KeyD" /* KeyD */,
        "e", "KeyE" /* KeyE */,
        "f", "KeyF" /* KeyF */,
        "g", "KeyG" /* KeyG */,
        "h", "KeyH" /* KeyH */,
        "i", "KeyI" /* KeyI */,
        "j", "KeyJ" /* KeyJ */,
        "k", "KeyK" /* KeyK */,
        "l", "KeyL" /* KeyL */,
        "m", "KeyM" /* KeyM */,
        "n", "KeyN" /* KeyN */,
        "o", "KeyO" /* KeyO */,
        "p", "KeyP" /* KeyP */,
        "q", "KeyQ" /* KeyQ */,
        'r', "KeyR" /* KeyR */,
        "s", "KeyS" /* KeyS */,
        "t", "KeyT" /* KeyT */,
        "u", "KeyU" /* KeyU */,
        "v", "KeyV" /* KeyV */,
        "w", "KeyW" /* KeyW */,
        "x", "KeyX" /* KeyX */,
        "y", "KeyY" /* KeyY */,
        "z", "KeyZ" /* KeyZ */,
    ];
    var _keyCodeToCode = [
        48, "Digit0" /* Digit0 */,
        49, "Digit1" /* Digit1 */,
        50, "Digit2" /* Digit2 */,
        51, "Digit3" /* Digit3 */,
        52, "Digit4" /* Digit4 */,
        53, "Digit5" /* Digit5 */,
        54, "Digit6" /* Digit6 */,
        55, "Digit7" /* Digit7 */,
        56, "Digit8" /* Digit8 */,
        57, "Digit9" /* Digit9 */,
        65, "KeyA" /* KeyA */,
        66, "KeyB" /* KeyB */,
        67, "KeyC" /* KeyC */,
        68, "KeyD" /* KeyD */,
        69, "KeyE" /* KeyE */,
        70, "KeyF" /* KeyF */,
        71, "KeyG" /* KeyG */,
        72, "KeyH" /* KeyH */,
        73, "KeyI" /* KeyI */,
        74, "KeyJ" /* KeyJ */,
        75, "KeyK" /* KeyK */,
        76, "KeyL" /* KeyL */,
        77, "KeyM" /* KeyM */,
        78, "KeyN" /* KeyN */,
        79, "KeyO" /* KeyO */,
        80, "KeyP" /* KeyP */,
        81, "KeyQ" /* KeyQ */,
        82, "KeyR" /* KeyR */,
        83, "KeyS" /* KeyS */,
        84, "KeyT" /* KeyT */,
        85, "KeyU" /* KeyU */,
        86, "KeyV" /* KeyV */,
        87, "KeyW" /* KeyW */,
        88, "KeyX" /* KeyX */,
        89, "KeyY" /* KeyY */,
        90, "KeyZ" /* KeyZ */,
        96, "Digit0" /* Digit0 */,
        97, "Digit1" /* Digit1 */,
        98, "Digit2" /* Digit2 */,
        99, "Digit3" /* Digit3 */,
        100, "Digit4" /* Digit4 */,
        101, "Digit5" /* Digit5 */,
        102, "Digit6" /* Digit6 */,
        103, "Digit7" /* Digit7 */,
        104, "Digit8" /* Digit8 */,
        105, "Digit9" /* Digit9 */,
    ];
    /**
     * 鼠标、笔、触控等的信息。
     */
    var Pointer = (function (_super) {
        __extends(Pointer, _super);
        function Pointer() {
            var _this = _super.call(this) || this;
            /**
             * 该 Pointer 持续按下的时间。
             */
            _this.holdedTime = 0.0;
            /**
             * 该 Pointer 的舞台坐标。
             */
            _this.position = egret3d.Vector3.create();
            /**
             * 该 Pointer 按下的舞台坐标。
             */
            _this.downPosition = egret3d.Vector3.create();
            /**
             * 该 Pointer 此帧的移动速度。
             */
            _this.speed = egret3d.Vector3.create();
            /**
             * 该 Pointer 最近的事件。
             */
            _this.event = null;
            /**
             * @internal
             */
            _this._prevButtons = 0 /* None */;
            /**
             * @internal
             */
            _this._prevPosition = egret3d.Vector3.create();
            return _this;
        }
        /**
         * 创建一个 Pointer 实例。
         */
        Pointer.create = function () {
            if (this._instances.length > 0) {
                var instance = this._instances.pop();
                instance._released = false;
                return instance;
            }
            return new Pointer();
        };
        /**
         * 该 Pointer 此帧按下的状态。
         * @param value
         */
        Pointer.prototype.isDown = function (value, isPlayerMode) {
            if (value === void 0) { value = 1 /* TouchContact */; }
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (!this.event || (isPlayerMode && paper.Application.playerMode !== 1 /* Player */)) {
                return false;
            }
            return (this.event.buttons & value) !== 0 && (this._prevButtons & value) === 0;
        };
        /**
         * 该 Pointer 此帧持续按下的状态。
         * @param value
         */
        Pointer.prototype.isHold = function (value, isPlayerMode) {
            if (value === void 0) { value = 1 /* TouchContact */; }
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (!this.event || (isPlayerMode && paper.Application.playerMode !== 1 /* Player */)) {
                return false;
            }
            return (this.event.buttons & value) !== 0 && (this._prevButtons & value) !== 0;
        };
        /**
         * 该 Pointer 此帧抬起的状态。
         * @param value
         */
        Pointer.prototype.isUp = function (value, isPlayerMode) {
            if (value === void 0) { value = 1 /* TouchContact */; }
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (!this.event || (isPlayerMode && paper.Application.playerMode !== 1 /* Player */)) {
                return false;
            }
            return (this.event.buttons & value) === 0 && (this._prevButtons & value) !== 0;
        };
        /**
         * 该 Pointer 此帧移动的状态。
         * @param value
         */
        Pointer.prototype.isMove = function (distance, isPlayerMode) {
            if (distance === void 0) { distance = 5; }
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (!this.event || (isPlayerMode && paper.Application.playerMode !== 1 /* Player */)) {
                return null;
            }
            return Math.abs(this.speed.x) > distance || Math.abs(this.speed.y) > distance;
        };
        Pointer._instances = [];
        return Pointer;
    }(paper.BaseRelease));
    egret3d.Pointer = Pointer;
    __reflect(Pointer.prototype, "egret3d.Pointer");
    /**
     * 按键的信息。
     */
    var Key = (function () {
        function Key() {
            /**
             * 该按键持续按下的时间。
             */
            this.holdedTime = 0.0;
            /**
             * 该按键最近的事件。
             */
            this.event = null;
        }
        /**
         * 该按键此帧按下的状态。
         * @param value
         */
        Key.prototype.isDown = function (isPlayerMode) {
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (!this.event || (isPlayerMode && paper.Application.playerMode !== 1 /* Player */)) {
                return false;
            }
            return egret3d.inputCollecter._downKeys.indexOf(this) >= 0;
        };
        /**
         * 该按键此帧持续按下的状态。
         * @param value
         */
        Key.prototype.isHold = function (isPlayerMode) {
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (!this.event || (isPlayerMode && paper.Application.playerMode !== 1 /* Player */)) {
                return false;
            }
            return egret3d.inputCollecter._holdKeys.indexOf(this) >= 0;
        };
        /**
         * 该按键此帧抬起的状态。
         * @param value
         */
        Key.prototype.isUp = function (isPlayerMode) {
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (!this.event || (isPlayerMode && paper.Application.playerMode !== 1 /* Player */)) {
                return false;
            }
            return egret3d.inputCollecter._upKeys.indexOf(this) >= 0;
        };
        return Key;
    }());
    egret3d.Key = Key;
    __reflect(Key.prototype, "egret3d.Key");
    /**
     * 全局输入信息组件。
     * - https://www.w3.org/TR/pointerevents/
     * - https://github.com/millermedeiros/js-signals/
     */
    // @requireComponent(Stage) TODO
    var InputCollecter = (function (_super) {
        __extends(InputCollecter, _super);
        function InputCollecter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 滚轮当前值。
             */
            _this.mouseWheel = 0;
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerOver = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerEnter = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerDown = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerMove = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerUp = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerCancel = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerOut = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onPointerLeave = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onMouseWheel = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onKeyDown = new signals.Signal();
            /**
             * 通常不需要使用该事件。
             */
            _this.onKeyUp = new signals.Signal();
            /**
             * @internal
             */
            _this._downPointers = [];
            /**
             * @internal
             */
            _this._holdPointers = [];
            /**
             * @internal
             */
            _this._upPointers = [];
            /**
             * @internal
             */
            _this._downKeys = [];
            /**
             * @internal
             */
            _this._holdKeys = [];
            /**
             * @internal
             */
            _this._upKeys = [];
            /**
             * 默认的 Pointer 实例。
             */
            _this.defaultPointer = Pointer.create();
            _this._pointers = {};
            _this._keys = {};
            return _this;
        }
        /**
         * @internal
         */
        InputCollecter.prototype._update = function (deltaTime) {
            for (var _i = 0, _a = this._downPointers; _i < _a.length; _i++) {
                var pointer = _a[_i];
                pointer.holdedTime = 0.0;
            }
            for (var _b = 0, _c = this._holdPointers; _b < _c.length; _b++) {
                var pointer = _c[_b];
                if (this._downPointers.indexOf(pointer) >= 0) {
                    continue;
                }
                pointer.holdedTime += deltaTime;
            }
            for (var _d = 0, _e = this._downKeys; _d < _e.length; _d++) {
                var key = _e[_d];
                key.holdedTime = 0.0;
            }
            for (var _f = 0, _g = this._holdKeys; _f < _g.length; _f++) {
                var key = _g[_f];
                if (this._downKeys.indexOf(key) >= 0) {
                    continue;
                }
                key.holdedTime += deltaTime;
            }
        };
        /**
         * @internal
         */
        InputCollecter.prototype._clear = function () {
            this.mouseWheel = 0;
            for (var k in this._pointers) {
                var pointer = this._pointers[k];
                if (pointer.event) {
                    pointer.speed.subtract(pointer.position, pointer._prevPosition);
                    pointer._prevButtons = pointer.event.buttons;
                    pointer._prevPosition.copy(pointer.position);
                }
            }
            if (this._upPointers.length > 0) {
                this._upPointers.length = 0;
            }
            if (this._downPointers.length > 0) {
                this._downPointers.length = 0;
            }
            if (this._upKeys.length > 0) {
                this._upKeys.length = 0;
            }
            if (this._downKeys.length > 0) {
                this._downKeys.length = 0;
            }
        };
        /**
         * @internal
         */
        InputCollecter.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            egret3d.inputCollecter = this;
            this._pointers[1] = this.defaultPointer;
        };
        /**
         * 此帧按下的全部 Pointer。
         */
        InputCollecter.prototype.getDownPointers = function (isPlayerMode) {
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (isPlayerMode && paper.Application.playerMode !== 1 /* Player */) {
                return [];
            }
            return this._downPointers;
        };
        /**
         * 此帧持续按下的全部 Pointer。
         */
        InputCollecter.prototype.getHoldPointers = function (isPlayerMode) {
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (isPlayerMode && paper.Application.playerMode !== 1 /* Player */) {
                return [];
            }
            return this._holdPointers;
        };
        /**
         * 此帧抬起的全部 Pointer。
         */
        InputCollecter.prototype.getUpPointers = function (isPlayerMode) {
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (isPlayerMode && paper.Application.playerMode !== 1 /* Player */) {
                return [];
            }
            return this._upPointers;
        };
        /**
         * 此帧按下的全部按键。
         */
        InputCollecter.prototype.getDownKeys = function (isPlayerMode) {
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (isPlayerMode && paper.Application.playerMode !== 1 /* Player */) {
                return [];
            }
            return this._downKeys;
        };
        /**
         * 此帧持续按下的全部按键。
         */
        InputCollecter.prototype.getHoldKeys = function (isPlayerMode) {
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (isPlayerMode && paper.Application.playerMode !== 1 /* Player */) {
                return [];
            }
            return this._holdKeys;
        };
        /**
         * 此帧抬起的全部按键。
         */
        InputCollecter.prototype.getUpKeys = function (isPlayerMode) {
            if (isPlayerMode === void 0) { isPlayerMode = true; }
            if (isPlayerMode && paper.Application.playerMode !== 1 /* Player */) {
                return [];
            }
            return this._upKeys;
        };
        /**
         * @internal
         */
        InputCollecter.prototype.getPointer = function (pointerID) {
            var pointers = this._pointers;
            if (!(pointerID in pointers)) {
                if (this._downPointers.length === 0 && this._holdPointers.length === 0) {
                    pointers[pointerID] = this.defaultPointer;
                }
                else {
                    pointers[pointerID] = Pointer.create();
                }
            }
            return pointers[pointerID];
        };
        /**
         * @internal
         */
        InputCollecter.prototype.removePointer = function (pointerID) {
            if (pointerID === 1) {
                return;
            }
            var pointers = this._pointers;
            if (pointerID in pointers) {
                var pointer = pointers[pointerID];
                if (pointer !== this.defaultPointer) {
                    pointer.release();
                }
                delete pointers[pointerID];
            }
        };
        /**
         * 通过键名称创建或获取一个按键实例。
         */
        InputCollecter.prototype.getKey = function (code) {
            if (typeof code === "number") {
                var index = _keyCodeToCode.indexOf(code);
                if (index >= 0) {
                    code = _keyCodeToCode[index + 1];
                }
                else {
                    if (true) {
                        console.error("Unsupported keyCode \"" + code + "\", use egret3d.keyCode enumeration instead.");
                    }
                    code = "Unknown" /* Unknown */;
                }
            }
            else if (code.length === 1) {
                var index = _keyToCode.indexOf(code);
                if (index >= 0) {
                    code = _keyToCode[index + 1];
                }
                else {
                    if (true) {
                        console.error("Unsupported key \"" + code + "\", use egret3d.keyCode enumeration instead.");
                    }
                    code = "Unknown" /* Unknown */;
                }
            }
            else if (!code) {
                if (true) {
                    console.error("Invalid code.");
                }
                code = "Unknown" /* Unknown */;
            }
            code = code.toLowerCase();
            var keys = this._keys;
            if (!(code in keys)) {
                keys[code] = new Key();
            }
            return keys[code];
        };
        Object.defineProperty(InputCollecter.prototype, "maxTouchPoints", {
            /**
             * 设备最大可支持的多点触摸数量。
             */
            get: function () {
                if (window.navigator) {
                    return window.navigator.maxTouchPoints;
                }
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        InputCollecter = __decorate([
            paper.singleton
        ], InputCollecter);
        return InputCollecter;
    }(paper.BaseComponent));
    egret3d.InputCollecter = InputCollecter;
    __reflect(InputCollecter.prototype, "egret3d.InputCollecter");
    /**
     * 全局输入信息组件实例。
     */
    egret3d.inputCollecter = null;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 碰撞体类型。
     * - 枚举需要支持的全部碰撞体类型。
     */
    var ColliderType;
    (function (ColliderType) {
        /**
         * 立方体。
         */
        ColliderType[ColliderType["Box"] = 0] = "Box";
        /**
         * 球体。
         */
        ColliderType[ColliderType["Sphere"] = 1] = "Sphere";
        /**
         * 圆柱体。
         */
        ColliderType[ColliderType["Cylinder"] = 2] = "Cylinder";
        /**
         * 圆锥体。
         */
        ColliderType[ColliderType["Cone"] = 3] = "Cone";
        /**
         * 胶囊体。
         */
        ColliderType[ColliderType["Capsule"] = 4] = "Capsule";
        /**
         * TODO
         */
        ColliderType[ColliderType["ConvexHull"] = 5] = "ConvexHull";
        /**
         * TODO
         */
        ColliderType[ColliderType["Mesh"] = 6] = "Mesh";
    })(ColliderType = egret3d.ColliderType || (egret3d.ColliderType = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Spherical = (function (_super) {
        __extends(Spherical, _super);
        /**
         * 请使用 `egret3d.Spherical.create()` 创建实例。
         * @see egret3d.Spherical.create()
         */
        function Spherical() {
            var _this = _super.call(this) || this;
            /**
             *
             */
            _this.radius = 1.0;
            /**
             *
             */
            _this.phi = 0.0;
            /**
             *
             */
            _this.theta = 0.0;
            return _this;
        }
        /**
         *
         */
        Spherical.create = function (radius, phi, theta) {
            if (radius === void 0) { radius = 1.0; }
            if (phi === void 0) { phi = 0.0; }
            if (theta === void 0) { theta = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(radius, phi, theta);
                instance._released = false;
                return instance;
            }
            return new Spherical().set(radius, phi, theta);
        };
        Spherical.prototype.serialize = function () {
            return [this.radius, this.phi, this.theta];
        };
        Spherical.prototype.deserialize = function (value) {
            this.radius = value[0];
            this.phi = value[1];
            this.theta = value[2];
            return this;
        };
        Spherical.prototype.clone = function () {
            return Spherical.create(this.radius, this.phi, this.theta);
        };
        Spherical.prototype.copy = function (value) {
            return this.set(value.radius, value.phi, value.theta);
        };
        Spherical.prototype.set = function (radius, phi, theta) {
            this.radius = radius;
            this.phi = phi;
            this.theta = theta;
            return this;
        };
        Spherical.prototype.fromCartesianCoords = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                p3 = p1.z;
                p2 = p1.y;
                p1 = p1.x;
            }
            this.radius = Math.sqrt(p1 * p1 + p2 * p2 + p3 * p3);
            if (this.radius === 0.0) {
                this.theta = 0.0;
                this.phi = 0.0;
            }
            else {
                this.theta = Math.atan2(p1, p3); // TODO
                this.phi = Math.acos(egret3d.math.clamp(p2 / this.radius, -1.0, 1.0));
            }
            return this;
        };
        Spherical.prototype.makeSafe = function () {
            var EPS = 0.000001;
            this.phi = Math.max(EPS, Math.min(3.141592653589793 /* PI */ - EPS, this.phi));
            return this;
        };
        Spherical._instances = [];
        return Spherical;
    }(paper.BaseRelease));
    egret3d.Spherical = Spherical;
    __reflect(Spherical.prototype, "egret3d.Spherical", ["paper.ICCS", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 立方体碰撞组件。
     */
    var BoxCollider = (function (_super) {
        __extends(BoxCollider, _super);
        function BoxCollider() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.colliderType = egret3d.ColliderType.Box;
            _this.box = egret3d.Box.create(egret3d.Vector3.MINUS_ONE, egret3d.Vector3.ONE).expand(0.5);
            return _this;
        }
        BoxCollider.prototype.raycast = function (ray, raycastInfo) {
            if (raycastInfo === void 0) { raycastInfo = null; }
            return egret3d._colliderRaycast(this, this.box, null, ray, raycastInfo, false);
        };
        Object.defineProperty(BoxCollider.prototype, "aabb", {
            /**
             * @deprecated
             */
            get: function () {
                return this.box;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.editor.property("NESTED" /* NESTED */),
            paper.serializedField("aabb")
        ], BoxCollider.prototype, "box", void 0);
        BoxCollider = __decorate([
            paper.allowMultiple
        ], BoxCollider);
        return BoxCollider;
    }(paper.BaseComponent));
    egret3d.BoxCollider = BoxCollider;
    __reflect(BoxCollider.prototype, "egret3d.BoxCollider", ["egret3d.IBoxCollider", "egret3d.ICollider", "egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 球体碰撞组件。
     */
    var SphereCollider = (function (_super) {
        __extends(SphereCollider, _super);
        function SphereCollider() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.colliderType = egret3d.ColliderType.Sphere;
            _this.sphere = egret3d.Sphere.create(egret3d.Vector3.ZERO, 0.5);
            return _this;
        }
        SphereCollider.prototype.raycast = function (ray, raycastInfo) {
            if (raycastInfo === void 0) { raycastInfo = null; }
            return egret3d._colliderRaycast(this, this.sphere, null, ray, raycastInfo, true);
        };
        __decorate([
            paper.serializedField,
            paper.editor.property("NESTED" /* NESTED */)
        ], SphereCollider.prototype, "sphere", void 0);
        SphereCollider = __decorate([
            paper.allowMultiple
        ], SphereCollider);
        return SphereCollider;
    }(paper.BaseComponent));
    egret3d.SphereCollider = SphereCollider;
    __reflect(SphereCollider.prototype, "egret3d.SphereCollider", ["egret3d.ISphereCollider", "egret3d.ICollider", "egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 圆柱（锥）体碰撞组件。
     * - 与 Y 轴对齐。
     */
    var CylinderCollider = (function (_super) {
        __extends(CylinderCollider, _super);
        function CylinderCollider() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.colliderType = egret3d.ColliderType.Cylinder;
            _this.cylinder = egret3d.Cylinder.create(egret3d.Vector3.ZERO, 0.5, 0.5, 1.0);
            return _this;
        }
        CylinderCollider.prototype.raycast = function (ray, raycastInfo) {
            if (raycastInfo === void 0) { raycastInfo = null; }
            return egret3d._colliderRaycast(this, this.cylinder, null, ray, raycastInfo, true);
        };
        __decorate([
            paper.editor.property("NESTED" /* NESTED */),
            paper.serializedField
        ], CylinderCollider.prototype, "cylinder", void 0);
        CylinderCollider = __decorate([
            paper.allowMultiple
        ], CylinderCollider);
        return CylinderCollider;
    }(paper.BaseComponent));
    egret3d.CylinderCollider = CylinderCollider;
    __reflect(CylinderCollider.prototype, "egret3d.CylinderCollider", ["egret3d.ICylinderCollider", "egret3d.ICollider", "egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    var _indices = [];
    /**
     * 实体组件匹配器。
     */
    var Matcher = (function (_super) {
        __extends(Matcher, _super);
        function Matcher() {
            var _this = _super.call(this) || this;
            _this.componentEnabledFilter = true;
            _this._id = "";
            _this._components = [];
            _this._allOfComponents = [];
            _this._anyOfComponents = [];
            _this._noneOfComponents = [];
            _this._extraOfComponents = [];
            return _this;
        }
        Matcher.create = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var instance;
            if (this._instances.length > 0) {
                instance = this._instances.pop();
                instance._released = false;
            }
            else {
                instance = new Matcher();
            }
            instance.componentEnabledFilter = args[0] !== false;
            if (!instance.componentEnabledFilter) {
                args.shift();
            }
            instance._distinct(args, instance._allOfComponents);
            return instance;
        };
        Matcher.prototype._sortComponents = function (a, b) {
            return a.componentIndex - b.componentIndex;
        };
        Matcher.prototype._distinct = function (source, target) {
            if (source.length === 0) {
                return;
            }
            var index = 0;
            for (var _i = 0, source_1 = source; _i < source_1.length; _i++) {
                var component = source_1[_i];
                paper.registerClass(component); // TODO
                if (target.indexOf(component) < 0) {
                    target[index++] = component;
                }
            }
            if (target.length !== index) {
                target.length = index;
            }
            target.sort(this._sortComponents);
        };
        Matcher.prototype._merge = function () {
            if (this._allOfComponents.length > 0) {
                for (var _i = 0, _a = this._allOfComponents; _i < _a.length; _i++) {
                    var component = _a[_i];
                    this._components.push(component);
                }
            }
            if (this._anyOfComponents.length > 0) {
                for (var _b = 0, _c = this._anyOfComponents; _b < _c.length; _b++) {
                    var component = _c[_b];
                    this._components.push(component);
                }
            }
            if (this._noneOfComponents.length > 0) {
                for (var _d = 0, _e = this._noneOfComponents; _d < _e.length; _d++) {
                    var component = _e[_d];
                    this._components.push(component);
                }
            }
            if (this._extraOfComponents.length > 0) {
                for (var _f = 0, _g = this._extraOfComponents; _f < _g.length; _f++) {
                    var component = _g[_f];
                    this._components.push(component);
                }
            }
        };
        Matcher.prototype.onClear = function () {
            this._id = "";
            this._components.length = 0;
            this._allOfComponents.length = 0;
            this._anyOfComponents.length = 0;
            this._noneOfComponents.length = 0;
            this._extraOfComponents.length = 0;
        };
        Matcher.prototype.anyOf = function () {
            var components = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                components[_i] = arguments[_i];
            }
            if (this._id) {
                return this;
            }
            this._distinct(components, this._anyOfComponents);
            return this;
        };
        Matcher.prototype.noneOf = function () {
            var components = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                components[_i] = arguments[_i];
            }
            if (this._id) {
                return this;
            }
            this._distinct(components, this._noneOfComponents);
            return this;
        };
        Matcher.prototype.extraOf = function () {
            var components = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                components[_i] = arguments[_i];
            }
            if (this._id) {
                return this;
            }
            this._distinct(components, this._extraOfComponents);
            return this;
        };
        Matcher.prototype.matches = function (entity, component, isAdd, isAdded) {
            var _a = this, componentEnabledFilter = _a.componentEnabledFilter, _allOfComponents = _a._allOfComponents, _anyOfComponents = _a._anyOfComponents, _noneOfComponents = _a._noneOfComponents, _extraOfComponents = _a._extraOfComponents;
            if (component) {
                var isNoneOf = _noneOfComponents.length > 0 && _noneOfComponents.indexOf(component) >= 0;
                if (isNoneOf) {
                    if (isAdd === isAdded) {
                        if (isAdd) {
                            // remove
                            return -1;
                        }
                        else if ((_allOfComponents.length === 0 || entity.hasComponents(_allOfComponents, componentEnabledFilter)) &&
                            (_anyOfComponents.length === 0 || entity.hasAnyComponents(_anyOfComponents, componentEnabledFilter)) &&
                            !entity.hasAnyComponents(_noneOfComponents, componentEnabledFilter)) {
                            // add
                            return 1;
                        }
                    }
                }
                else if (isAdd) {
                    if (isAdded) {
                        if (_extraOfComponents.length > 0 && _extraOfComponents.indexOf(component) >= 0) {
                            // add extra
                            return 2;
                        }
                    }
                    else if ((_allOfComponents.length === 0 || entity.hasComponents(_allOfComponents, componentEnabledFilter)) &&
                        (_anyOfComponents.length === 0 || entity.hasAnyComponents(_anyOfComponents, componentEnabledFilter))) {
                        // add
                        return 1;
                    }
                }
                else if (isAdded) {
                    if (_extraOfComponents.length > 0 && _extraOfComponents.indexOf(component) >= 0) {
                        // remove extra
                        return -2;
                    }
                    else if ((_allOfComponents.length === 0 || entity.hasComponents(_allOfComponents, componentEnabledFilter)) &&
                        (_anyOfComponents.length === 0 || entity.hasAnyComponents(_anyOfComponents, componentEnabledFilter))) {
                    }
                    else {
                        // remove
                        return -1;
                    }
                }
            }
            else if (!isAdded) {
                if ((_allOfComponents.length === 0 || entity.hasComponents(_allOfComponents, componentEnabledFilter)) &&
                    (_anyOfComponents.length === 0 || entity.hasAnyComponents(_anyOfComponents, componentEnabledFilter)) &&
                    (_noneOfComponents.length === 0 || !entity.hasAnyComponents(_noneOfComponents, componentEnabledFilter))) {
                    if (isAdd) {
                        // add
                        return 1;
                    }
                    else {
                        // remove
                        return -1;
                    }
                }
            }
            return 0;
        };
        Object.defineProperty(Matcher.prototype, "id", {
            get: function () {
                if (!this._id) {
                    this._id = (this.componentEnabledFilter ? "E" : "C");
                    if (this._allOfComponents.length > 0) {
                        for (var _i = 0, _a = this._allOfComponents; _i < _a.length; _i++) {
                            var component = _a[_i];
                            _indices.push(component.componentIndex);
                        }
                        this._id += " All " + _indices.join(",");
                        _indices.length = 0;
                    }
                    if (this._anyOfComponents.length > 0) {
                        for (var _b = 0, _c = this._anyOfComponents; _b < _c.length; _b++) {
                            var component = _c[_b];
                            _indices.push(component.componentIndex);
                        }
                        this._id += " Any " + _indices.join(",");
                        _indices.length = 0;
                    }
                    if (this._noneOfComponents.length > 0) {
                        for (var _d = 0, _e = this._noneOfComponents; _d < _e.length; _d++) {
                            var component = _e[_d];
                            _indices.push(component.componentIndex);
                        }
                        this._id += " None " + _indices.join(",");
                        _indices.length = 0;
                    }
                    if (this._extraOfComponents.length > 0) {
                        for (var _f = 0, _g = this._extraOfComponents; _f < _g.length; _f++) {
                            var component = _g[_f];
                            _indices.push(component.componentIndex);
                        }
                        this._id += " Extra " + _indices.join(",");
                        _indices.length = 0;
                    }
                }
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matcher.prototype, "components", {
            get: function () {
                if (this._components.length === 0) {
                    this._merge();
                }
                return this._components;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matcher.prototype, "allOfComponents", {
            get: function () {
                return this._allOfComponents;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matcher.prototype, "anyOfComponents", {
            get: function () {
                return this._anyOfComponents;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matcher.prototype, "noneOfComponents", {
            get: function () {
                return this._noneOfComponents;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matcher.prototype, "extraOfComponents", {
            get: function () {
                return this._extraOfComponents;
            },
            enumerable: true,
            configurable: true
        });
        Matcher._instances = [];
        return Matcher;
    }(paper.BaseRelease));
    paper.Matcher = Matcher;
    __reflect(Matcher.prototype, "paper.Matcher", ["paper.IAllOfMatcher", "paper.IAnyOfMatcher", "paper.INoneOfMatcher", "paper.ICompoundMatcher", "paper.IMatcher"]);
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 网格碰撞组件。
     */
    var MeshCollider = (function (_super) {
        __extends(MeshCollider, _super);
        function MeshCollider() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.colliderType = egret3d.ColliderType.Mesh;
            _this._localBoundingBox = egret3d.Box.create();
            _this._mesh = null;
            return _this;
        }
        /**
         * @internal
         */
        MeshCollider.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            if (this._mesh) {
                this._mesh.release();
            }
            this._mesh = null;
        };
        MeshCollider.prototype.raycast = function (ray, raycastInfo) {
            if (raycastInfo === void 0) { raycastInfo = null; }
            var mesh = this._mesh;
            if (mesh) {
                return egret3d._colliderRaycast(this, mesh, this._localBoundingBox, ray, raycastInfo, true);
            }
            return false;
        };
        Object.defineProperty(MeshCollider.prototype, "mesh", {
            /**
             * 该组件的网格资源。
             */
            get: function () {
                return this._mesh;
            },
            set: function (value) {
                if (this._mesh === value) {
                    return;
                }
                if (this._mesh) {
                    this._mesh.release();
                }
                if (value) {
                    value.retain();
                }
                this._localBoundingBox.clear();
                if (value && !value.isDisposed) {
                    var vertices = value.getVertices();
                    var position = egret3d.helpVector3A;
                    for (var i = 0, l = vertices.length; i < l; i += 3) {
                        position.set(vertices[i], vertices[i + 1], vertices[i + 2]);
                        this._localBoundingBox.add(position);
                    }
                }
                this._mesh = value;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.editor.property("MESH" /* MESH */),
            paper.serializedField("_mesh")
        ], MeshCollider.prototype, "mesh", null);
        MeshCollider = __decorate([
            paper.allowMultiple
        ], MeshCollider);
        return MeshCollider;
    }(paper.BaseComponent));
    egret3d.MeshCollider = MeshCollider;
    __reflect(MeshCollider.prototype, "egret3d.MeshCollider", ["egret3d.IMeshCollider", "egret3d.ICollider", "egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3 = egret3d.Vector3.create();
    var _helpRaycastInfo = egret3d.RaycastInfo.create();
    function _raycastCollider(ray, collider, raycastInfo, hit) {
        var helpRaycastInfo = _helpRaycastInfo;
        var normal = raycastInfo.normal;
        helpRaycastInfo.backfaceCulling = raycastInfo.backfaceCulling;
        helpRaycastInfo.normal = normal ? _helpVector3 : null;
        if (collider.raycast(ray, helpRaycastInfo) &&
            (!hit || raycastInfo.distance > helpRaycastInfo.distance)) {
            var transform = collider.gameObject.transform;
            raycastInfo.distance = helpRaycastInfo.distance;
            raycastInfo.position.copy(helpRaycastInfo.position);
            raycastInfo.transform = transform;
            raycastInfo.collider = collider;
            if (normal) {
                normal.copy(_helpVector3);
            }
            return true;
        }
        return false;
    }
    function _raycastAll(ray, gameObject, maxDistance, cullingMask, raycastMesh, backfaceCulling, raycastInfos) {
        if ((gameObject.hideFlags & 2 /* NotTouchable */) ||
            !gameObject.activeInHierarchy) {
            return false;
        }
        var raycastInfo = egret3d.RaycastInfo.create();
        raycastInfo.backfaceCulling = backfaceCulling;
        if (gameObject.layer & cullingMask) {
            if (raycastMesh) {
                if (gameObject.renderer && gameObject.renderer.enabled &&
                    gameObject.renderer.raycast(ray, raycastInfo)) {
                    raycastInfo.transform = gameObject.transform;
                }
            }
            else {
                raycast(ray, gameObject, false, raycastInfo);
            }
        }
        if (raycastInfo.transform) {
            if (maxDistance <= 0.0 || raycastInfo.distance <= maxDistance) {
                raycastInfos.push(raycastInfo);
            }
            else {
                raycastInfo.transform = null;
                raycastInfo.release();
            }
        }
        else {
            raycastInfo.transform = null;
            raycastInfo.release();
        }
        if (!raycastInfo.transform) {
            for (var _i = 0, _a = gameObject.transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                _raycastAll(ray, child.gameObject, maxDistance, cullingMask, raycastMesh, backfaceCulling, raycastInfos);
            }
        }
        return true;
    }
    function _sortRaycastInfo(a, b) {
        // TODO renderQueue.
        return a.distance - b.distance;
    }
    function _colliderRaycast(collider, raycaster, preRaycaster, ray, raycastInfo, modifyNormal) {
        if (modifyNormal === void 0) { modifyNormal = false; }
        var transform = collider.gameObject.transform;
        var worldToLocalMatrix = transform.worldToLocalMatrix;
        var localRay = egret3d.helpRay.applyMatrix(worldToLocalMatrix, ray);
        if ((!preRaycaster || preRaycaster.raycast(localRay, null)) && raycaster.raycast(localRay, raycastInfo)) {
            if (raycastInfo) {
                var localToWorldMatrix = transform.localToWorldMatrix;
                raycastInfo.distance = ray.origin.getDistance(raycastInfo.position.applyMatrix(localToWorldMatrix));
                raycastInfo.transform = transform;
                raycastInfo.collider = collider;
                var normal = raycastInfo.normal;
                if (normal) {
                    if (modifyNormal && raycastInfo.modifyNormal) {
                        normal.applyMatrix3(egret3d.helpMatrix3A.fromMatrix4(worldToLocalMatrix).transpose()).normalize();
                    }
                    else {
                        normal.applyDirection(localToWorldMatrix);
                    }
                }
            }
            return true;
        }
        return false;
    }
    egret3d._colliderRaycast = _colliderRaycast;
    /**
     * 用世界空间坐标系的射线检测指定的实体。（不包含其子级）
     * @param ray 世界空间坐标系的射线。
     * @param gameObject 实体。
     * @param raycastMesh 是否检测网格。（需要消耗较多的 CPU 性能，尤其是蒙皮网格）
     * @param raycastInfo
     */
    function raycast(ray, gameObject, raycastMesh, raycastInfo) {
        if (raycastMesh === void 0) { raycastMesh = false; }
        if (raycastInfo === void 0) { raycastInfo = null; }
        if (raycastMesh) {
            if (gameObject.renderer && gameObject.renderer.enabled &&
                gameObject.renderer.raycast(ray, raycastInfo)) {
                if (raycastInfo) {
                    raycastInfo.transform = gameObject.transform;
                }
                return true;
            }
            return false;
        }
        else {
            // TODO 更快的查询所有碰撞组件的方式。extends ?
            var hit = false;
            var boxColliders = gameObject.getComponents(egret3d.BoxCollider);
            var sphereColliders = gameObject.getComponents(egret3d.SphereCollider);
            var cylinderColliders = gameObject.getComponents(egret3d.CylinderCollider);
            var capsuleColliders = gameObject.getComponents(egret3d.CapsuleCollider);
            var meshColliders = gameObject.getComponents(egret3d.MeshCollider);
            if (boxColliders.length > 0) {
                for (var _i = 0, boxColliders_1 = boxColliders; _i < boxColliders_1.length; _i++) {
                    var collider = boxColliders_1[_i];
                    if (!collider.enabled) {
                        continue;
                    }
                    if (raycastInfo) {
                        if (_raycastCollider(ray, collider, raycastInfo, hit)) {
                            hit = true;
                        }
                    }
                    else if (collider.raycast(ray)) {
                        return true;
                    }
                }
            }
            if (sphereColliders.length > 0) {
                for (var _a = 0, sphereColliders_1 = sphereColliders; _a < sphereColliders_1.length; _a++) {
                    var collider = sphereColliders_1[_a];
                    if (!collider.enabled) {
                        continue;
                    }
                    if (raycastInfo) {
                        if (_raycastCollider(ray, collider, raycastInfo, hit)) {
                            hit = true;
                        }
                    }
                    else if (collider.raycast(ray)) {
                        return true;
                    }
                }
            }
            if (cylinderColliders.length > 0) {
                for (var _b = 0, cylinderColliders_1 = cylinderColliders; _b < cylinderColliders_1.length; _b++) {
                    var collider = cylinderColliders_1[_b];
                    if (!collider.enabled) {
                        continue;
                    }
                    if (raycastInfo) {
                        if (_raycastCollider(ray, collider, raycastInfo, hit)) {
                            hit = true;
                        }
                    }
                    else if (collider.raycast(ray)) {
                        return true;
                    }
                }
            }
            if (capsuleColliders.length > 0) {
                for (var _c = 0, capsuleColliders_1 = capsuleColliders; _c < capsuleColliders_1.length; _c++) {
                    var collider = capsuleColliders_1[_c];
                    if (!collider.enabled) {
                        continue;
                    }
                    if (raycastInfo) {
                        if (_raycastCollider(ray, collider, raycastInfo, hit)) {
                            hit = true;
                        }
                    }
                    else if (collider.raycast(ray)) {
                        return true;
                    }
                }
            }
            if (meshColliders.length > 0) {
                for (var _d = 0, meshColliders_1 = meshColliders; _d < meshColliders_1.length; _d++) {
                    var collider = meshColliders_1[_d];
                    if (!collider.enabled) {
                        continue;
                    }
                    if (raycastInfo) {
                        if (_raycastCollider(ray, collider, raycastInfo, hit)) {
                            hit = true;
                        }
                    }
                    else if (collider.raycast(ray)) {
                        return true;
                    }
                }
            }
        }
        if (raycastInfo && raycastInfo.transform) {
            return true;
        }
        return false;
    }
    egret3d.raycast = raycast;
    /**
     * 用世界空间坐标系的射线检测指定的实体或组件列表。
     * @param ray 射线。
     * @param gameObjectsOrComponents 实体或组件列表。
     * @param maxDistance 最大相交点检测距离。
     * @param cullingMask 只对特定层的实体检测。
     * @param raycastMesh 是否检测网格。（需要消耗较多的 CPU 性能，尤其是蒙皮网格）
     */
    function raycastAll(ray, gameObjectsOrComponents, maxDistance, cullingMask, raycastMesh, backfaceCulling) {
        if (maxDistance === void 0) { maxDistance = 0.0; }
        if (cullingMask === void 0) { cullingMask = 4294967295 /* Everything */; }
        if (raycastMesh === void 0) { raycastMesh = false; }
        if (backfaceCulling === void 0) { backfaceCulling = true; }
        var raycastInfos = [];
        for (var _i = 0, gameObjectsOrComponents_1 = gameObjectsOrComponents; _i < gameObjectsOrComponents_1.length; _i++) {
            var gameObjectOrComponent = gameObjectsOrComponents_1[_i];
            _raycastAll(ray, gameObjectOrComponent instanceof paper.Entity ? gameObjectOrComponent : gameObjectOrComponent.gameObject, maxDistance, cullingMask, raycastMesh, backfaceCulling, raycastInfos);
        }
        raycastInfos.sort(_sortRaycastInfo);
        return raycastInfos;
    }
    egret3d.raycastAll = raycastAll;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3 = null;
    var _helpRaycastInfo = null;
    /**
     * 碰撞系统。
     */
    var CollisionSystem = (function (_super) {
        __extends(CollisionSystem, _super);
        function CollisionSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._contactCollecter = paper.Application.sceneManager.globalEntity.getComponent(egret3d.ContactCollecter);
            return _this;
        }
        CollisionSystem.prototype._raycast = function (ray, entity, cullingMask, maxDistance, raycastInfo) {
            if (cullingMask === void 0) { cullingMask = 1 /* Default */; }
            if (maxDistance === void 0) { maxDistance = 0.0; }
            if ((entity.hideFlags & 10 /* Hide */) !== 0 ||
                (entity.layer & cullingMask) === 0) {
                return false;
            }
            if (maxDistance > 0.0) {
                maxDistance *= maxDistance;
                if (entity.transform.position.getSquaredDistance(ray.origin) >= maxDistance) {
                    return false;
                }
            }
            var isHit = false;
            var boxColliders = entity.getComponents(egret3d.BoxCollider);
            if (boxColliders.length > 0) {
                for (var _i = 0, boxColliders_2 = boxColliders; _i < boxColliders_2.length; _i++) {
                    var collider = boxColliders_2[_i];
                    if (!collider.enabled) {
                        continue;
                    }
                    if (raycastInfo !== null) {
                        isHit = this._raycastCollider(ray, collider, raycastInfo) || isHit;
                    }
                    else if (collider.raycast(ray)) {
                        return true;
                    }
                }
            }
            var sphereColliders = entity.getComponents(egret3d.SphereCollider);
            if (sphereColliders.length > 0) {
                for (var _a = 0, sphereColliders_2 = sphereColliders; _a < sphereColliders_2.length; _a++) {
                    var collider = sphereColliders_2[_a];
                    if (!collider.enabled) {
                        continue;
                    }
                    if (raycastInfo !== null) {
                        isHit = this._raycastCollider(ray, collider, raycastInfo) || isHit;
                    }
                    else if (collider.raycast(ray)) {
                        return true;
                    }
                }
            }
            var cylinderColliders = entity.getComponents(egret3d.CylinderCollider);
            if (cylinderColliders.length > 0) {
                for (var _b = 0, cylinderColliders_2 = cylinderColliders; _b < cylinderColliders_2.length; _b++) {
                    var collider = cylinderColliders_2[_b];
                    if (!collider.enabled) {
                        continue;
                    }
                    if (raycastInfo !== null) {
                        isHit = this._raycastCollider(ray, collider, raycastInfo) || isHit;
                    }
                    else if (collider.raycast(ray)) {
                        return true;
                    }
                }
            }
            var capsuleColliders = entity.getComponents(egret3d.CapsuleCollider);
            if (capsuleColliders.length > 0) {
                for (var _c = 0, capsuleColliders_2 = capsuleColliders; _c < capsuleColliders_2.length; _c++) {
                    var collider = capsuleColliders_2[_c];
                    if (!collider.enabled) {
                        continue;
                    }
                    if (raycastInfo !== null) {
                        isHit = this._raycastCollider(ray, collider, raycastInfo) || isHit;
                    }
                    else if (collider.raycast(ray)) {
                        return true;
                    }
                }
            }
            var meshColliders = entity.getComponents(egret3d.MeshCollider);
            if (meshColliders.length > 0) {
                for (var _d = 0, meshColliders_2 = meshColliders; _d < meshColliders_2.length; _d++) {
                    var collider = meshColliders_2[_d];
                    if (!collider.enabled) {
                        continue;
                    }
                    if (raycastInfo !== null) {
                        isHit = this._raycastCollider(ray, collider, raycastInfo) || isHit;
                    }
                    else if (collider.raycast(ray)) {
                        return true;
                    }
                }
            }
            return isHit;
        };
        CollisionSystem.prototype._raycastCollider = function (ray, collider, raycastInfo) {
            var helpRaycastInfo = _helpRaycastInfo;
            helpRaycastInfo.backfaceCulling = raycastInfo.backfaceCulling;
            helpRaycastInfo.modifyNormal = raycastInfo.modifyNormal;
            helpRaycastInfo.normal = raycastInfo.normal ? _helpVector3 : null;
            if (collider.raycast(ray, helpRaycastInfo)) {
                if (raycastInfo.transform === null || raycastInfo.distance > helpRaycastInfo.distance) {
                    raycastInfo.copy(helpRaycastInfo);
                }
                return true;
            }
            return false;
        };
        CollisionSystem.prototype.raycast = function (ray, cullingMask, maxDistance, raycastInfo) {
            if (cullingMask === void 0) { cullingMask = 1 /* Default */; }
            if (maxDistance === void 0) { maxDistance = 0.0; }
            if (raycastInfo === void 0) { raycastInfo = null; }
            var entities = this.groups[0].entities;
            if (raycastInfo !== null) {
                var isHit = false;
                _helpVector3 = egret3d.Vector3.create().release();
                _helpRaycastInfo = egret3d.RaycastInfo.create().release();
                for (var _i = 0, entities_4 = entities; _i < entities_4.length; _i++) {
                    var entity = entities_4[_i];
                    isHit = this._raycast(ray, entity, cullingMask, maxDistance, raycastInfo) || isHit;
                }
                _helpVector3 = null;
                _helpRaycastInfo = null;
                return isHit;
            }
            for (var _a = 0, entities_5 = entities; _a < entities_5.length; _a++) {
                var entity = entities_5[_a];
                if (this._raycast(ray, entity, cullingMask, maxDistance, null)) {
                    return true;
                }
            }
            return false;
        };
        CollisionSystem.prototype.getMatchers = function () {
            return [
                paper.Matcher.create(egret3d.Transform)
                    .anyOf(egret3d.BoxCollider, egret3d.SphereCollider, egret3d.CylinderCollider, egret3d.CapsuleCollider, egret3d.MeshCollider),
            ];
        };
        CollisionSystem.prototype.onTickCleanup = function () {
            this._contactCollecter._update();
        };
        return CollisionSystem;
    }(paper.BaseSystem));
    egret3d.CollisionSystem = CollisionSystem;
    __reflect(CollisionSystem.prototype, "egret3d.CollisionSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var DirtyMask;
    (function (DirtyMask) {
        DirtyMask[DirtyMask["ProjectionMatrix"] = 1] = "ProjectionMatrix";
        DirtyMask[DirtyMask["TransformMatrix"] = 2] = "TransformMatrix";
        DirtyMask[DirtyMask["ClipToWorldMatrix"] = 4] = "ClipToWorldMatrix";
        DirtyMask[DirtyMask["WorldToClipMatrix"] = 8] = "WorldToClipMatrix";
        DirtyMask[DirtyMask["CullingMatrix"] = 16] = "CullingMatrix";
        DirtyMask[DirtyMask["PixelViewport"] = 32] = "PixelViewport";
        DirtyMask[DirtyMask["CullingFrustum"] = 64] = "CullingFrustum";
        DirtyMask[DirtyMask["ClipMatrix"] = 12] = "ClipMatrix";
        DirtyMask[DirtyMask["ProjectionAndClipMatrix"] = 13] = "ProjectionAndClipMatrix";
        DirtyMask[DirtyMask["Culling"] = 80] = "Culling";
        DirtyMask[DirtyMask["All"] = 125] = "All";
    })(DirtyMask || (DirtyMask = {}));
    /**
     * 相机组件。
     */
    var Camera = (function (_super) {
        __extends(Camera, _super);
        function Camera() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 该相机的绘制缓冲掩码。
             */
            _this.bufferMask = 16640 /* DepthAndColor */;
            /**
             * 该相机的渲染剔除掩码。
             * - 用来选择性的渲染部分实体。
             * - camera.cullingMask = paper.Layer.UI;
             * - camera.cullingMask |= paper.Layer.UI;
             * - camera.cullingMask &= ~paper.Layer.UI;
             */
            _this.cullingMask = 1 /* Default */ | 2 /* TransparentFX */ | 32 /* UI */;
            /**
             * 该相机渲染排序。
             * - 该值越低的相机优先绘制。
             */
            _this.order = 0;
            /**
             * 该相机的背景色。
             */
            _this.backgroundColor = egret3d.Color.create(0.15, 0.25, 0.5, 1.0);
            /**
             * 该相机的渲染上下文。
             */
            _this.context = egret3d.CameraRenderContext.create(_this);
            _this._nativeCulling = false;
            _this._nativeProjection = false;
            _this._nativeTransform = false;
            _this._dirtyMask = 125 /* All */;
            _this._opvalue = 1.0;
            _this._fov = 0.7853981633974483 /* PI_QUARTER */;
            _this._near = 0.3;
            _this._far = 1000.0;
            _this._size = 1.0;
            _this._viewport = egret3d.Rectangle.create(0.0, 0.0, 1.0, 1.0);
            _this._pixelViewport = egret3d.Rectangle.create(0.0, 0.0, 1.0, 1.0);
            _this._frustum = egret3d.Frustum.create();
            _this._viewportMatrix = egret3d.Matrix4.create();
            _this._cullingMatrix = egret3d.Matrix4.create();
            _this._projectionMatrix = egret3d.Matrix4.create();
            _this._cameraToWorldMatrix = egret3d.Matrix4.create();
            _this._worldToCameraMatrix = egret3d.Matrix4.create();
            _this._worldToClipMatrix = egret3d.Matrix4.create();
            _this._clipToWorldMatrix = egret3d.Matrix4.create();
            _this._readRenderTarget = null;
            _this._writeRenderTarget = null;
            _this._renderTarget = null;
            /**
             * @private
             */
            _this._previewRenderTarget = null;
            return _this;
        }
        Object.defineProperty(Camera, "main", {
            /**
             * 当前场景的主相机。
             * - 如果没有则创建一个。
             */
            get: function () {
                var activeScene = paper.Application.sceneManager.activeScene;
                var gameObject = activeScene.findWithTag("MainCamera" /* MainCamera */);
                if (!gameObject) {
                    gameObject = activeScene.findWithTag("Main Camera");
                    if (gameObject) {
                        gameObject.tag = "MainCamera" /* MainCamera */;
                    }
                }
                if (!gameObject) {
                    gameObject = paper.GameObject.create("Main Camera" /* MainCamera */, "MainCamera" /* MainCamera */);
                    gameObject.transform.setLocalPosition(0.0, 10.0, -10.0);
                    gameObject.transform.lookAt(egret3d.Vector3.ZERO);
                }
                return gameObject.getOrAddComponent(Camera);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera, "editor", {
            /**
             * 编辑相机。
             * - 如果没有则创建一个。
             */
            get: function () {
                var gameObject = paper.Application.sceneManager.editorScene.find("Editor Camera" /* EditorCamera */);
                if (!gameObject) {
                    gameObject = paper.GameObject.create("Editor Camera" /* EditorCamera */, "EditorOnly" /* EditorOnly */, paper.Application.sceneManager.editorScene);
                    gameObject.transform.setLocalPosition(0.0, 10.0, -10.0);
                    gameObject.transform.lookAt(egret3d.Vector3.ZERO);
                    var camera = gameObject.addComponent(Camera);
                    camera.cullingMask = 4294967295 /* Everything */;
                    camera.cullingMask &= ~(32 /* UI */ | 128 /* EditorUI */); // TODO 更明确的 UI 编辑方案。
                    camera.far = 30000.0;
                }
                return gameObject.getOrAddComponent(Camera);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera, "current", {
            /**
             *
             */
            get: function () {
                return egret3d.cameraAndLightCollecter.currentCamera;
            },
            set: function (value) {
                egret3d.cameraAndLightCollecter.currentCamera = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 该相机渲染前更新。
         * @internal
         */
        Camera.prototype._update = function () {
            this.context._update();
        };
        Camera.prototype._onStageResize = function () {
            this._dirtyMask |= 32 /* PixelViewport */;
            if (!this._nativeProjection) {
                this._dirtyMask |= 13 /* ProjectionAndClipMatrix */;
                if (!this._nativeCulling) {
                    this._dirtyMask |= 80 /* Culling */;
                }
            }
            var _a = egret3d.stage.viewport, w = _a.w, h = _a.h;
            var readRenderTarget = this._readRenderTarget;
            var writeRenderTarget = this._writeRenderTarget;
            if (readRenderTarget) {
                readRenderTarget.uploadTexture(w, h);
            }
            if (writeRenderTarget) {
                writeRenderTarget.uploadTexture(w, h);
            }
        };
        Camera.prototype._onViewportUpdate = function (value) {
            if (value === this._viewport) {
                this.viewport = value;
            }
            else {
                this.pixelViewport = value;
            }
        };
        Camera.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.transform.registerObserver(this);
            egret3d.stage.onScreenResize.add(this._onStageResize, this);
            egret3d.stage.onResize.add(this._onStageResize, this);
            this._viewport.onUpdateTarget = this._pixelViewport.onUpdateTarget = this;
            this._viewport.onUpdate = this._pixelViewport.onUpdate = this._onViewportUpdate;
            // TODO 兼容
            this.cullingMask = 4294967295 /* Everything */;
            this.cullingMask &= ~64 /* Editor */;
            this.cullingMask &= ~128 /* EditorUI */;
        };
        Camera.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            if (this._readRenderTarget) {
                this._readRenderTarget.release();
            }
            if (this._writeRenderTarget) {
                this._writeRenderTarget.release();
            }
            if (this._renderTarget) {
                this._renderTarget.release();
            }
            this._readRenderTarget = null;
            this._writeRenderTarget = null;
            this._previewRenderTarget = null;
            egret3d.stage.onScreenResize.remove(this._onStageResize, this);
            egret3d.stage.onResize.remove(this._onStageResize, this);
        };
        Camera.prototype.onTransformChange = function () {
            if (!this._nativeTransform) {
                this._dirtyMask |= 12 /* ClipMatrix */;
                if (!this._nativeCulling) {
                    this._dirtyMask |= 80 /* Culling */;
                }
            }
        };
        /**
         * 将舞台坐标基于该相机的视角转换为世界坐标。
         * @param stagePosition 舞台坐标。
         * @param worldPosition 世界坐标。
         */
        Camera.prototype.stageToWorld = function (stagePosition, worldPosition) {
            if (!worldPosition) {
                worldPosition = egret3d.Vector3.create();
            }
            var backupZ = stagePosition.z;
            var _a = this.renderTargetSize, w = _a.w, h = _a.h;
            var kX = 2.0 / w;
            var kY = 2.0 / h;
            var clipToWorldMatrix = this.clipToWorldMatrix;
            var cameraToWorldMatrix = this.cameraToWorldMatrix;
            worldPosition.set((stagePosition.x * kX - 1.0), (1.0 - stagePosition.y * kY), 0.95).applyMatrix(clipToWorldMatrix);
            var position = egret3d.Vector3.create().fromMatrixPosition(cameraToWorldMatrix).release();
            var forward = egret3d.Vector3.create().fromMatrixColumn(cameraToWorldMatrix, 2).multiplyScalar(-1.0).release();
            var distanceToPlane = worldPosition.subtract(position).dot(forward);
            if (distanceToPlane < -2.220446049250313e-16 /* EPSILON */ || 2.220446049250313e-16 /* EPSILON */ < distanceToPlane) {
                if (this._opvalue === 0.0) {
                    // TODO
                    // worldPosition.subtract(vppos, forward.multiplyScalar(distanceToPlane - stagePosition.z));
                }
                else {
                    worldPosition.multiplyScalar(-backupZ / distanceToPlane).add(position);
                }
            }
            return worldPosition;
        };
        /**
         * 将舞台坐标基于该相机的视角转换为世界坐标。
         * @param worldPosition 世界坐标。
         * @param stagePosition 舞台坐标。
         */
        Camera.prototype.worldToStage = function (worldPosition, stagePosition) {
            if (!stagePosition) {
                stagePosition = egret3d.Vector3.create();
            }
            var _a = this.renderTargetSize, w = _a.w, h = _a.h;
            var worldToClipMatrix = this.worldToClipMatrix;
            stagePosition.applyMatrix(worldToClipMatrix, worldPosition);
            stagePosition.x = (stagePosition.x + 1.0) * w * 0.5;
            stagePosition.y = (1.0 - stagePosition.y) * h * 0.5;
            // stagePosition.z = TODO
            return stagePosition;
        };
        /**
         * 将舞台坐标基于该相机的视角转换为世界射线。
         * @param stageX 舞台水平坐标。
         * @param stageY 舞台垂直坐标。
         * @param ray 射线。
         */
        Camera.prototype.stageToRay = function (stageX, stageY, ray) {
            if (!ray) {
                ray = egret3d.Ray.create();
            }
            var _a = this.renderTargetSize, w = _a.w, h = _a.h;
            var kX = 2.0 / w;
            var kY = 2.0 / h;
            var clipToWorldMatrix = this.clipToWorldMatrix;
            ray.origin.set(stageX * kX - 1.0, 1.0 - stageY * kY, 0.0).applyMatrix(clipToWorldMatrix);
            ray.direction.set(stageX * kX - 1.0, 1.0 - stageY * kY, 1.0).applyMatrix(clipToWorldMatrix).subtract(ray.origin).normalize();
            return ray;
        };
        /**
         *
         */
        Camera.prototype.resetCullingMatrix = function () {
            this._nativeCulling = false;
            return this;
        };
        /**
         *
         */
        Camera.prototype.resetProjectionMatrix = function () {
            this._nativeProjection = false;
            return this;
        };
        /**
         *
         */
        Camera.prototype.resetWorldToCameraMatrix = function () {
            this._nativeTransform = false;
            return this;
        };
        /**
         *
         */
        Camera.prototype.swapPostprocessingRenderTarget = function () {
            var temp = this._writeRenderTarget;
            this._readRenderTarget = this._writeRenderTarget;
            this._writeRenderTarget = temp;
            return this;
        };
        Object.defineProperty(Camera.prototype, "opvalue", {
            /**
             * 控制该相机从正交到透视的过渡的系数，0：正交，1：透视，中间值则在两种状态间插值。
             */
            get: function () {
                return this._opvalue;
            },
            set: function (value) {
                if (value !== value || value < 0.0) {
                    value = 0.0;
                }
                else if (value > 1.0) {
                    value = 1.0;
                }
                if (this._opvalue === value) {
                    return;
                }
                this._opvalue = value;
                if (!this._nativeProjection) {
                    this._dirtyMask |= 13 /* ProjectionAndClipMatrix */;
                    if (!this._nativeCulling) {
                        this._dirtyMask |= 80 /* Culling */;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "near", {
            /**
             * 该相机的视点到近裁剪面距离。
             * - 该值过小会引起深度冲突。
             */
            get: function () {
                return this._near;
            },
            set: function (value) {
                if (value >= this._far) {
                    value = this._far - 0.01;
                }
                if (value < 0.01) {
                    value = 0.01;
                }
                if (this._near === value) {
                    return;
                }
                this._near = value;
                if (!this._nativeProjection) {
                    this._dirtyMask |= 13 /* ProjectionAndClipMatrix */;
                    if (!this._nativeCulling) {
                        this._dirtyMask |= 80 /* Culling */;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "far", {
            /**
             * 该相机的视点到远裁剪面距离。
             */
            get: function () {
                return this._far;
            },
            set: function (value) {
                if (value <= this._near) {
                    value = this._near + 0.01;
                }
                if (this._far === value) {
                    return;
                }
                this._far = value;
                if (!this._nativeProjection) {
                    this._dirtyMask |= 13 /* ProjectionAndClipMatrix */;
                    if (!this._nativeCulling) {
                        this._dirtyMask |= 80 /* Culling */;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "fov", {
            /**
             * 透视投影的视野。
             */
            get: function () {
                return this._fov;
            },
            set: function (value) {
                if (value !== value || value < 0.01) {
                    value = 0.01;
                }
                else if (value > 3.141592653589793 /* PI */ - 0.01) {
                    value = 3.141592653589793 /* PI */ - 0.01;
                }
                if (this._fov === value) {
                    return;
                }
                this._fov = value;
                if (!this._nativeProjection) {
                    this._dirtyMask |= 13 /* ProjectionAndClipMatrix */;
                    if (!this._nativeCulling) {
                        this._dirtyMask |= 80 /* Culling */;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "size", {
            /**
             * 该相机的正交投影的尺寸。
             */
            get: function () {
                return this._size;
            },
            set: function (value) {
                if (value !== value || value < 0.01) {
                    value = 0.01;
                }
                if (this._size === value) {
                    return;
                }
                this._size = value;
                if (!this._nativeProjection) {
                    this._dirtyMask |= 13 /* ProjectionAndClipMatrix */;
                    if (!this._nativeCulling) {
                        this._dirtyMask |= 80 /* Culling */;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "aspect", {
            /**
             * 该相机视口的宽高比。
             */
            get: function () {
                var _a = this.pixelViewport, w = _a.w, h = _a.h;
                return w / h;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "renderTargetSize", {
            /**
             * 该相机渲染目标的尺寸。
             */
            get: function () {
                var w;
                var h;
                var renderTarget = this._renderTarget;
                if (renderTarget) {
                    w = renderTarget.width;
                    h = renderTarget.height;
                }
                else {
                    var stageViewport = egret3d.stage.viewport;
                    w = stageViewport.w;
                    h = stageViewport.h;
                }
                return { w: w, h: h };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "viewport", {
            /**
             * 该相机归一化的渲染视口。
             */
            get: function () {
                return this._viewport;
            },
            set: function (value) {
                var viewport = this._viewport;
                if (viewport !== value) {
                    viewport.copy(value);
                }
                viewport.w = viewport.w || 1.0;
                viewport.h = viewport.h || 1.0;
                this._dirtyMask |= 32 /* PixelViewport */;
                if (!this._nativeProjection) {
                    this._dirtyMask |= 13 /* ProjectionAndClipMatrix */;
                    if (!this._nativeCulling) {
                        this._dirtyMask |= 80 /* Culling */;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "pixelViewport", {
            /**
             * 该相机像素化的渲染视口。
             */
            get: function () {
                var pixelViewport = this._pixelViewport;
                if (this._dirtyMask & 32 /* PixelViewport */) {
                    var _a = this.renderTargetSize, w = _a.w, h = _a.h;
                    var viewport = this._viewport;
                    pixelViewport.x = w * viewport.x;
                    pixelViewport.y = h * viewport.y;
                    pixelViewport.w = w * viewport.w;
                    pixelViewport.h = h * viewport.h;
                    this._dirtyMask &= ~32 /* PixelViewport */;
                }
                return pixelViewport;
            },
            set: function (value) {
                var pixelViewport = this._pixelViewport;
                if (pixelViewport !== value) {
                    pixelViewport.copy(value);
                }
                pixelViewport.w = pixelViewport.w || 1.0;
                pixelViewport.h = pixelViewport.h || 1.0;
                var _a = this.renderTargetSize, w = _a.w, h = _a.h;
                this._viewport.set(pixelViewport.x / w, pixelViewport.y / h, (pixelViewport.w || 1.0) / w, (pixelViewport.h || 1.0) / h);
                if (!this._nativeProjection) {
                    this._dirtyMask |= 13 /* ProjectionAndClipMatrix */;
                    if (!this._nativeCulling) {
                        this._dirtyMask |= 80 /* Culling */;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "frustum", {
            /**
             * 该相机的截头锥体。
             */
            get: function () {
                if (this._dirtyMask & 64 /* CullingFrustum */) {
                    this._frustum.fromMatrix(this.cullingMatrix);
                    this._dirtyMask &= ~64 /* CullingFrustum */;
                }
                return this._frustum;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "cullingMatrix", {
            /**
             * 该相机在世界空间坐标系的裁切矩阵。
             */
            get: function () {
                if (!this._nativeCulling) {
                    if (this._dirtyMask & 16 /* CullingMatrix */) {
                        this._cullingMatrix.multiply(this.projectionMatrix, this.worldToCameraMatrix);
                        this._dirtyMask &= ~16 /* CullingMatrix */;
                    }
                }
                return this._cullingMatrix;
            },
            set: function (value) {
                var cullingMatrix = this._cullingMatrix;
                if (cullingMatrix !== value) {
                    cullingMatrix.copy(value);
                }
                this._nativeCulling = true;
                this._dirtyMask |= 64 /* CullingFrustum */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "projectionMatrix", {
            /**
             * 该相机的投影矩阵。
             */
            get: function () {
                if (this._nativeProjection) {
                    return this._projectionMatrix;
                }
                var viewportMatrix = this._viewportMatrix;
                if (this._dirtyMask & 1 /* ProjectionMatrix */) {
                    viewportMatrix.fromProjection(this._near, this._far, this._fov, this._size, this._opvalue, this.aspect, egret3d.stage.matchFactor);
                    this._dirtyMask &= ~1 /* ProjectionMatrix */;
                }
                return viewportMatrix;
            },
            set: function (value) {
                var projectionMatrix = this._projectionMatrix;
                if (projectionMatrix !== value) {
                    projectionMatrix.copy(value);
                }
                this._nativeProjection = true;
                this._dirtyMask |= 12 /* ClipMatrix */;
                if (!this._nativeCulling) {
                    this._dirtyMask |= 80 /* Culling */;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "cameraToWorldMatrix", {
            /**
             * 从该相机空间坐标系到世界空间坐标系的变换矩阵。
             */
            get: function () {
                if (this._nativeTransform) {
                    if (this._dirtyMask & 2 /* TransformMatrix */) {
                        this._cameraToWorldMatrix.inverse(this._worldToCameraMatrix);
                    }
                    return this._cameraToWorldMatrix;
                }
                return this.gameObject.transform.localToWorldMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "worldToCameraMatrix", {
            /**
             * 从世界空间坐标系到该相机空间坐标系的变换矩阵。
             * - 当设置该矩阵时，该相机将使用设置值代替变换组件的矩阵进行渲染。
             */
            get: function () {
                if (this._nativeTransform) {
                    return this._worldToCameraMatrix;
                }
                return this.gameObject.transform.worldToLocalMatrix;
            },
            set: function (value) {
                var worldToCameraMatrix = this._worldToCameraMatrix;
                if (worldToCameraMatrix !== value) {
                    worldToCameraMatrix.copy(value);
                }
                this._nativeTransform = true;
                this._dirtyMask |= 2 /* TransformMatrix */;
                if (!this._nativeProjection) {
                    this._dirtyMask |= 13 /* ProjectionAndClipMatrix */;
                    if (!this._nativeCulling) {
                        this._dirtyMask |= 80 /* Culling */;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "worldToClipMatrix", {
            /**
             * 从世界变换到该相机裁切空间的矩阵。
             */
            get: function () {
                if (this._dirtyMask & 8 /* WorldToClipMatrix */) {
                    this._worldToClipMatrix.multiply(this.projectionMatrix, this.worldToCameraMatrix);
                    this._dirtyMask &= ~8 /* WorldToClipMatrix */;
                }
                return this._worldToClipMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "clipToWorldMatrix", {
            /**
             * 从该相机裁切空间变换到世界的矩阵。
             */
            get: function () {
                if (this._dirtyMask & 4 /* ClipToWorldMatrix */) {
                    this._clipToWorldMatrix.inverse(this.worldToClipMatrix);
                    this._dirtyMask &= ~4 /* ClipToWorldMatrix */;
                }
                return this._clipToWorldMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "renderTarget", {
            /**
             * 该相机的渲染目标。
             * - 未设置该值则直接绘制到舞台。
             */
            get: function () {
                return this._renderTarget;
            },
            set: function (value) {
                if (this._renderTarget === value) {
                    return;
                }
                if (this._renderTarget) {
                    this._renderTarget.release();
                }
                if (value) {
                    value.retain();
                }
                this._renderTarget = value;
                this._dirtyMask |= 32 /* PixelViewport */;
                if (!this._nativeProjection) {
                    this._dirtyMask |= 13 /* ProjectionAndClipMatrix */;
                    if (!this._nativeCulling) {
                        this._dirtyMask |= 80 /* Culling */;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "postprocessingRenderTarget", {
            /**
             *
             */
            get: function () {
                if (!this._readRenderTarget) {
                    this._readRenderTarget = egret3d.RenderTexture.create({ width: egret3d.stage.viewport.w, height: egret3d.stage.viewport.h }).setLiner(1 /* Bilinear */).setRepeat(false).retain();
                }
                if (!this._writeRenderTarget) {
                    this._writeRenderTarget = egret3d.RenderTexture.create({ width: egret3d.stage.viewport.w, height: egret3d.stage.viewport.h }).setLiner(1 /* Bilinear */).setRepeat(false).retain();
                }
                return this._readRenderTarget;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        Camera.prototype.getPosAtXPanelInViewCoordinateByScreenPos = function (screenPos, z, out) {
            var _a = this.renderTargetSize, w = _a.w, h = _a.h;
            var nearpos = egret3d.helpVector3A;
            nearpos.z = -this.near;
            nearpos.x = screenPos.x - w * 0.5;
            nearpos.y = h * 0.5 - screenPos.y;
            var farpos = egret3d.helpVector3B;
            farpos.z = -this.far;
            farpos.x = this.far * nearpos.x / this.near;
            farpos.y = this.far * nearpos.y / this.near;
            var rate = (nearpos.z - z) / (nearpos.z - farpos.z);
            out.x = nearpos.x - (nearpos.x - farpos.x) * rate;
            out.y = nearpos.y - (nearpos.y - farpos.y) * rate;
        };
        /**
         * @deprecated
         */
        Camera.prototype.calcScreenPosFromWorldPos = function (worldPos, outScreenPos) {
            var _a = this.renderTargetSize, w = _a.w, h = _a.h;
            var worldToClipMatrix = this.worldToClipMatrix;
            var ndcPos = egret3d.helpVector3A;
            ndcPos.applyMatrix(worldToClipMatrix, worldPos);
            outScreenPos.x = (ndcPos.x + 1.0) * w * 0.5;
            outScreenPos.y = (1.0 - ndcPos.y) * h * 0.5;
        };
        /**
         * @deprecated
         */
        Camera.prototype.calcWorldPosFromScreenPos = function (screenPos, outWorldPos) {
            this.stageToWorld(screenPos, outWorldPos);
        };
        /**
         * @deprecated
         */
        Camera.prototype.createRayByScreen = function (screenPosX, screenPosY, ray) {
            return this.stageToRay(screenPosX, screenPosY, ray);
        };
        Object.defineProperty(Camera.prototype, "clearOption_Color", {
            /**
             * @deprecated
             */
            get: function () {
                return (this.bufferMask & 16384 /* Color */) !== 0;
            },
            set: function (value) {
                if (value) {
                    this.bufferMask |= 16384 /* Color */;
                }
                else {
                    this.bufferMask &= ~16384 /* Color */;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "clearOption_Depth", {
            /**
             * @deprecated
             */
            get: function () {
                return (this.bufferMask & 256 /* Depth */) !== 0;
            },
            set: function (value) {
                if (value) {
                    this.bufferMask |= 256 /* Depth */;
                }
                else {
                    this.bufferMask &= ~256 /* Depth */;
                }
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField,
            paper.editor.property("LIST" /* LIST */, { listItems: paper.editor.getItemsFromEnum(gltf.BufferMask) }) // TODO
        ], Camera.prototype, "bufferMask", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("LIST" /* LIST */, { listItems: paper.editor.getItemsFromEnum(paper.Layer) }) // TODO
        ], Camera.prototype, "cullingMask", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("INT" /* INT */)
        ], Camera.prototype, "order", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("COLOR" /* COLOR */)
        ], Camera.prototype, "backgroundColor", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0, maximum: 1.0, step: 0.01 })
        ], Camera.prototype, "opvalue", null);
        __decorate([
            paper.serializedField("_near"),
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.01, maximum: 3000.0 - 0.01, step: 1 })
        ], Camera.prototype, "near", null);
        __decorate([
            paper.serializedField("_far"),
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.02, maximum: 3000.0, step: 1 })
        ], Camera.prototype, "far", null);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.01, maximum: 3.141592653589793 /* PI */ - 0.01, step: 0.01 })
        ], Camera.prototype, "fov", null);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.01 })
        ], Camera.prototype, "size", null);
        __decorate([
            paper.serializedField,
            paper.editor.property("RECT" /* RECT */, { step: 0.01 })
        ], Camera.prototype, "viewport", null);
        __decorate([
            paper.editor.property("RECT" /* RECT */, { step: 1 })
        ], Camera.prototype, "pixelViewport", null);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "renderTarget", null);
        return Camera;
    }(paper.BaseComponent));
    egret3d.Camera = Camera;
    __reflect(Camera.prototype, "egret3d.Camera", ["egret3d.ITransformObserver"]);
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var Collector = (function () {
        function Collector(group) {
            this.addedEntities = [];
            this.removedEntities = [];
            this.addedComponentes = [];
            this.removedComponentes = [];
            this._group = group;
            paper.Group.onEntityAdded.add(this._onEntityAdded, this);
            paper.Group.onEntityRemoved.add(this._onEntityRemoved, this);
            paper.Group.onComponentEnabled.add(this._onComponentEnabled, this);
            paper.Group.onComponentDisabled.add(this._onComponentDisabled, this);
        }
        /**
         * @internal
         */
        Collector.create = function (group) {
            var collector = new Collector(group);
            return collector;
        };
        Collector.prototype._onEntityAdded = function (_a) {
            var group = _a[0], entity = _a[1];
            if (this._group !== group) {
                return;
            }
            var index = this.removedEntities.indexOf(entity);
            if (index >= 0) {
                this.removedEntities[index] = null;
            }
            this.addedEntities.push(entity);
        };
        Collector.prototype._onEntityRemoved = function (_a) {
            var group = _a[0], entity = _a[1];
            if (this._group !== group) {
                return;
            }
            var index = this.addedEntities.indexOf(entity);
            if (index >= 0) {
                this.addedEntities[index] = null;
            }
            this.removedEntities.push(entity);
        };
        Collector.prototype._onComponentEnabled = function (_a) {
            var group = _a[0], component = _a[1];
            if (this._group !== group) {
                return;
            }
            var index = this.removedComponentes.indexOf(component);
            if (index >= 0) {
                this.removedComponentes[index] = null;
            }
            this.addedComponentes.push(component);
        };
        Collector.prototype._onComponentDisabled = function (_a) {
            var group = _a[0], component = _a[1];
            if (this._group !== group) {
                return;
            }
            var index = this.addedComponentes.indexOf(component);
            if (index >= 0) {
                this.addedComponentes[index] = null;
            }
            this.removedComponentes.push(component);
        };
        Collector.prototype.clear = function () {
            if (this.addedEntities.length > 0) {
                this.addedEntities.length = 0;
            }
            if (this.removedEntities.length > 0) {
                this.removedEntities.length = 0;
            }
            if (this.addedComponentes.length > 0) {
                this.addedComponentes.length = 0;
            }
            if (this.removedComponentes.length > 0) {
                this.removedComponentes.length = 0;
            }
        };
        Object.defineProperty(Collector.prototype, "group", {
            get: function () {
                return this._group;
            },
            enumerable: true,
            configurable: true
        });
        return Collector;
    }());
    paper.Collector = Collector;
    __reflect(Collector.prototype, "paper.Collector");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var LightSize;
    (function (LightSize) {
        LightSize[LightSize["Directional"] = 11] = "Directional";
        LightSize[LightSize["Spot"] = 18] = "Spot";
        LightSize[LightSize["RectangleArea"] = 12] = "RectangleArea";
        LightSize[LightSize["Point"] = 15] = "Point";
        LightSize[LightSize["Hemisphere"] = 9] = "Hemisphere";
    })(LightSize || (LightSize = {}));
    var ShadowSize;
    (function (ShadowSize) {
        ShadowSize[ShadowSize["Directional"] = 16] = "Directional";
        ShadowSize[ShadowSize["Spot"] = 16] = "Spot";
        ShadowSize[ShadowSize["Point"] = 16] = "Point";
    })(ShadowSize || (ShadowSize = {}));
    /**
     * 相机渲染上下文。
     */
    var CameraRenderContext = (function () {
        /**
         * 禁止实例化。
         */
        function CameraRenderContext(camera) {
            /**
             *
             */
            this.logDepthBufFC = 0.0;
            /**
             * 12: dirX, dirY, dirZ, colorR, colorG, colorB, shadow, shadowBias, shadowRadius, shadowMapSizeX, shadowMapSizeY
             * @internal
             */
            this.directLightBuffer = new Float32Array(0);
            /**
             * 18: x, y, z, dirX, dirY, dirZ, colorR, colorG, colorB, distance, decay, coneCos, penumbraCos, shadow, shadowBias, shadowRadius, shadowMapSizeX, shadowMapSizeY
             * @internal
             */
            this.spotLightBuffer = new Float32Array(0);
            /**
             * @internal
             */
            this.rectangleAreaLightBuffer = new Float32Array(0);
            /**
             * 16: x, y, z, colorR, colorG, colorB, distance, decay, shadow, shadowBias, shadowRadius, shadowMapSizeX, shadowMapSizeY, shadowCameraNear, shadowCameraFar,
             * @internal
             */
            this.pointLightBuffer = new Float32Array(0);
            /**
             * @internal
             */
            this.hemisphereLightBuffer = new Float32Array(0);
            /**
             * @internal
             */
            this.directShadowMatrix = new Float32Array(0);
            /**
             * @internal
             */
            this.spotShadowMatrix = new Float32Array(0);
            /**
             * @internal
             */
            this.pointShadowMatrix = new Float32Array(0);
            /**
             * @internal
             */
            this.directShadowMaps = [];
            /**
             * @internal
             */
            this.spotShadowMaps = [];
            /**
             * @internal
             */
            this.pointShadowMaps = [];
            /**
             * 此帧的非透明绘制信息列表。
             * - 已进行视锥剔除的。
             * TODO
             */
            this.opaqueCalls = [];
            /**
             * 此帧的透明绘制信息列表。
             * - 已进行视锥剔除的。
             * TODO
             */
            this.transparentCalls = [];
            /**
             * 此帧的阴影绘制信息列表。
             * - 已进行视锥剔除的。
             * @internal
             */
            this.shadowCalls = [];
            this._drawCallCollecter = paper.Application.sceneManager.globalEntity.getComponent(egret3d.DrawCallCollecter);
            this._cameraAndLightCollecter = paper.Application.sceneManager.globalEntity.getComponent(egret3d.CameraAndLightCollecter);
            this._camera = null;
            this._camera = camera;
        }
        /**
         * @internal
         */
        CameraRenderContext.create = function (camera) {
            return new CameraRenderContext(camera);
        };
        /**
         * 所有非透明的, 按照从近到远排序
         */
        CameraRenderContext.prototype._sortOpaque = function (a, b) {
            var materialA = a.material;
            var materialB = b.material;
            if (materialA._renderQueue !== materialB._renderQueue) {
                return materialA._renderQueue - materialB._renderQueue;
            }
            else if (materialA._technique.program !== materialB._technique.program) {
                return materialA._technique.program - materialB._technique.program;
            }
            else if (materialA._id !== materialB._id) {
                return materialA._id - materialB._id;
            }
            else {
                return a.zdist - b.zdist;
            }
        };
        /**
         * 所有透明的，按照从远到近排序
         */
        CameraRenderContext.prototype._sortFromFarToNear = function (a, b) {
            var materialA = a.material;
            var materialB = b.material;
            if (materialA._renderQueue === materialB._renderQueue) {
                return b.zdist - a.zdist;
            }
            else {
                return materialA._renderQueue - materialB._renderQueue;
            }
        };
        CameraRenderContext.prototype._shadowFrustumCulling = function () {
            var cullingMask = egret3d.cameraAndLightCollecter.currentCamera.cullingMask; // TODO 全局相机
            var camera = this._camera;
            var cameraFrustum = camera.frustum;
            var shadowCalls = this.shadowCalls;
            var shadowIndex = 0;
            for (var _i = 0, _a = this._drawCallCollecter.drawCalls; _i < _a.length; _i++) {
                var drawCall = _a[_i];
                var renderer = drawCall.renderer;
                if (!renderer.castShadows) {
                    continue;
                }
                var layer = renderer.gameObject.layer;
                if (renderer.castShadows &&
                    (cullingMask & layer) !== 0 &&
                    // (camera.cullingMask & layer) !== 0 && TODO light cullingMask
                    (!renderer.frustumCulled || egret3d.math.frustumIntersectsSphere(cameraFrustum, renderer.boundingSphere))) {
                    shadowCalls[shadowIndex++] = drawCall;
                }
            }
            if (shadowCalls.length !== shadowIndex) {
                shadowCalls.length = shadowIndex;
            }
            shadowCalls.sort(this._sortFromFarToNear);
        };
        CameraRenderContext.prototype._frustumCulling = function () {
            var camera = this._camera;
            var cameraPosition = camera.gameObject.transform.position;
            var cameraFrustum = camera.frustum;
            var opaqueCalls = this.opaqueCalls;
            var transparentCalls = this.transparentCalls;
            var opaqueIndex = 0;
            var transparentIndex = 0;
            for (var _i = 0, _a = this._drawCallCollecter.drawCalls; _i < _a.length; _i++) {
                var drawCall = _a[_i];
                var renderer = drawCall.renderer;
                if ((camera.cullingMask & renderer.gameObject.layer) !== 0 &&
                    (!renderer.frustumCulled || egret3d.math.frustumIntersectsSphere(cameraFrustum, renderer.boundingSphere))) {
                    // if (drawCall.material.renderQueue >= paper.RenderQueue.Transparent && drawCall.material.renderQueue <= paper.RenderQueue.Overlay) {
                    if (drawCall.material._renderQueue >= 2450 /* Mask */) {
                        transparentCalls[transparentIndex++] = drawCall;
                    }
                    else {
                        opaqueCalls[opaqueIndex++] = drawCall;
                    }
                    drawCall.zdist = egret3d.Vector3.create().fromMatrixPosition(drawCall.matrix).getSquaredDistance(cameraPosition);
                }
            }
            if (opaqueCalls.length !== opaqueIndex) {
                opaqueCalls.length = opaqueIndex;
            }
            if (transparentCalls.length !== transparentIndex) {
                transparentCalls.length = transparentIndex;
            }
            opaqueCalls.sort(this._sortOpaque); // TODO 优化，没必要一定每帧排序。
            transparentCalls.sort(this._sortFromFarToNear);
        };
        CameraRenderContext.prototype._updateLights = function () {
            var _a = this._cameraAndLightCollecter, directionalLights = _a.directionalLights, spotLights = _a.spotLights, rectangleAreaLights = _a.rectangleAreaLights, pointLights = _a.pointLights, hemisphereLights = _a.hemisphereLights;
            var directLightCount = directionalLights.length;
            var spotLightCount = spotLights.length;
            var rectangleAreaLightCount = rectangleAreaLights.length;
            var pointLightCount = pointLights.length;
            var hemisphereLightCount = hemisphereLights.length;
            var renderStateCaches = egret3d.renderState.caches;
            renderStateCaches.castShadows = false;
            //
            if (this.directLightBuffer.length !== directLightCount * 11 /* Directional */) {
                this.directLightBuffer = new Float32Array(directLightCount * 11 /* Directional */);
            }
            if (this.spotLightBuffer.length !== spotLightCount * 18 /* Spot */) {
                this.spotLightBuffer = new Float32Array(spotLightCount * 18 /* Spot */);
            }
            if (this.rectangleAreaLightBuffer.length !== rectangleAreaLightCount * 12 /* RectangleArea */) {
                this.rectangleAreaLightBuffer = new Float32Array(rectangleAreaLightCount * 12 /* RectangleArea */);
            }
            if (this.pointLightBuffer.length !== pointLightCount * 15 /* Point */) {
                this.pointLightBuffer = new Float32Array(pointLightCount * 15 /* Point */);
            }
            if (this.hemisphereLightBuffer.length !== hemisphereLightCount * 9 /* Hemisphere */) {
                this.hemisphereLightBuffer = new Float32Array(hemisphereLightCount * 9 /* Hemisphere */);
            }
            //
            if (this.directShadowMatrix.length !== directLightCount * 16 /* Directional */) {
                this.directShadowMatrix = new Float32Array(directLightCount * 16 /* Directional */);
            }
            if (this.spotShadowMatrix.length !== spotLightCount * 16 /* Spot */) {
                this.spotShadowMatrix = new Float32Array(spotLightCount * 16 /* Spot */);
            }
            if (this.pointShadowMatrix.length !== pointLightCount * 16 /* Point */) {
                this.pointShadowMatrix = new Float32Array(pointLightCount * 16 /* Point */);
            }
            //
            var _b = this, directLightBuffer = _b.directLightBuffer, spotLightBuffer = _b.spotLightBuffer, rectangleAreaLightBuffer = _b.rectangleAreaLightBuffer, pointLightBuffer = _b.pointLightBuffer, hemisphereLightBuffer = _b.hemisphereLightBuffer, directShadowMatrix = _b.directShadowMatrix, spotShadowMatrix = _b.spotShadowMatrix, pointShadowMatrix = _b.pointShadowMatrix, directShadowMaps = _b.directShadowMaps, spotShadowMaps = _b.spotShadowMaps, pointShadowMaps = _b.pointShadowMaps;
            if (directShadowMaps.length !== directLightCount) {
                directShadowMaps.length = directLightCount;
            }
            if (spotShadowMaps.length !== spotLightCount) {
                spotShadowMaps.length = spotLightCount;
            }
            if (pointShadowMaps.length !== pointLightCount) {
                pointShadowMaps.length = pointLightCount;
            }
            var index = 0, shadowIndex = 0, offset = 0;
            var helpVector3 = egret3d.Vector3.create().release();
            var worldToCameraMatrix = this._camera.worldToCameraMatrix;
            for (var _i = 0, directionalLights_1 = directionalLights; _i < directionalLights_1.length; _i++) {
                var light = directionalLights_1[_i];
                var intensity = light.intensity;
                var color = light.color;
                offset = (index++) * 11 /* Directional */;
                //
                light.gameObject.transform.getForward(helpVector3).applyDirection(worldToCameraMatrix);
                directLightBuffer[offset++] = -helpVector3.x; // Left-hand.
                directLightBuffer[offset++] = -helpVector3.y;
                directLightBuffer[offset++] = -helpVector3.z;
                //
                directLightBuffer[offset++] = color.r * intensity;
                directLightBuffer[offset++] = color.g * intensity;
                directLightBuffer[offset++] = color.b * intensity;
                //
                if (light.castShadows) {
                    var shadow = light.shadow;
                    directLightBuffer[offset++] = 1;
                    directLightBuffer[offset++] = shadow.bias;
                    directLightBuffer[offset++] = shadow.radius;
                    directLightBuffer[offset++] = shadow.mapSize;
                    directLightBuffer[offset++] = shadow.mapSize;
                    directShadowMatrix.set(shadow._matrix.rawData, shadowIndex * 16 /* Directional */);
                    directShadowMaps[shadowIndex++] = shadow._renderTarget;
                    renderStateCaches.castShadows = true;
                }
                else {
                    directLightBuffer[offset++] = 0;
                }
            }
            index = shadowIndex = 0;
            for (var _c = 0, spotLights_1 = spotLights; _c < spotLights_1.length; _c++) {
                var light = spotLights_1[_c];
                var intensity = light.intensity;
                var distance = light.distance;
                var color = light.color;
                offset = (index++) * 18 /* Spot */;
                //
                helpVector3.applyMatrix(worldToCameraMatrix, light.gameObject.transform.position);
                spotLightBuffer[offset++] = helpVector3.x;
                spotLightBuffer[offset++] = helpVector3.y;
                spotLightBuffer[offset++] = helpVector3.z;
                //
                light.gameObject.transform.getForward(helpVector3).applyDirection(worldToCameraMatrix);
                spotLightBuffer[offset++] = -helpVector3.x; // Left-hand.
                spotLightBuffer[offset++] = -helpVector3.y;
                spotLightBuffer[offset++] = -helpVector3.z;
                //
                spotLightBuffer[offset++] = color.r * intensity;
                spotLightBuffer[offset++] = color.g * intensity;
                spotLightBuffer[offset++] = color.b * intensity;
                //
                spotLightBuffer[offset++] = distance;
                spotLightBuffer[offset++] = distance === 0 ? 0 : light.decay;
                spotLightBuffer[offset++] = Math.cos(light.angle);
                spotLightBuffer[offset++] = Math.cos(light.angle * (1.0 - light.penumbra));
                //
                if (light.castShadows) {
                    var shadow = light.shadow;
                    spotLightBuffer[offset++] = 1;
                    spotLightBuffer[offset++] = shadow.bias;
                    spotLightBuffer[offset++] = shadow.radius;
                    spotLightBuffer[offset++] = shadow.mapSize;
                    spotLightBuffer[offset++] = shadow.mapSize;
                    spotShadowMatrix.set(shadow._matrix.rawData, shadowIndex * 16 /* Spot */);
                    spotShadowMaps[shadowIndex++] = shadow._renderTarget;
                    renderStateCaches.castShadows = true;
                }
                else {
                    spotLightBuffer[offset++] = 0;
                }
            }
            index = shadowIndex = 0;
            for (var _d = 0, rectangleAreaLights_1 = rectangleAreaLights; _d < rectangleAreaLights_1.length; _d++) {
                var light = rectangleAreaLights_1[_d];
                var intensity = light.intensity;
                var color = light.color;
                offset = (index++) * 12 /* RectangleArea */;
                //
                helpVector3.applyMatrix(worldToCameraMatrix, light.gameObject.transform.position);
                rectangleAreaLightBuffer[offset++] = helpVector3.x;
                rectangleAreaLightBuffer[offset++] = helpVector3.y;
                rectangleAreaLightBuffer[offset++] = helpVector3.z;
                //
                rectangleAreaLightBuffer[offset++] = color.r * intensity;
                rectangleAreaLightBuffer[offset++] = color.g * intensity;
                rectangleAreaLightBuffer[offset++] = color.b * intensity;
                // TODO 不支持阴影，防止贴图报错
                light.castShadows = false;
            }
            index = shadowIndex = 0;
            for (var _e = 0, pointLights_1 = pointLights; _e < pointLights_1.length; _e++) {
                var light = pointLights_1[_e];
                var intensity = light.intensity;
                var distance = light.distance;
                var color = light.color;
                offset = (index++) * 15 /* Point */;
                //
                helpVector3.applyMatrix(worldToCameraMatrix, light.gameObject.transform.position);
                pointLightBuffer[offset++] = helpVector3.x;
                pointLightBuffer[offset++] = helpVector3.y;
                pointLightBuffer[offset++] = helpVector3.z;
                //
                pointLightBuffer[offset++] = color.r * intensity;
                pointLightBuffer[offset++] = color.g * intensity;
                pointLightBuffer[offset++] = color.b * intensity;
                //
                pointLightBuffer[offset++] = distance;
                pointLightBuffer[offset++] = distance === 0.0 ? 0.0 : light.decay;
                //
                if (light.castShadows) {
                    var shadow = light.shadow;
                    pointLightBuffer[offset++] = 1;
                    pointLightBuffer[offset++] = shadow.bias;
                    pointLightBuffer[offset++] = shadow.radius;
                    pointLightBuffer[offset++] = shadow.mapSize;
                    pointLightBuffer[offset++] = shadow.mapSize;
                    pointLightBuffer[offset++] = shadow.near;
                    pointLightBuffer[offset++] = shadow.far;
                    pointShadowMatrix.set(shadow._matrix.rawData, shadowIndex * 16 /* Point */);
                    pointShadowMaps[shadowIndex++] = shadow._renderTarget;
                    renderStateCaches.castShadows = true;
                }
                else {
                    pointLightBuffer[offset++] = 0;
                }
            }
            index = shadowIndex = 0;
            for (var _f = 0, hemisphereLights_1 = hemisphereLights; _f < hemisphereLights_1.length; _f++) {
                var light = hemisphereLights_1[_f];
                var intensity = light.intensity;
                var color = light.color;
                var groundColor = light.groundColor;
                offset = (index++) * 9 /* Hemisphere */;
                //
                light.gameObject.transform.getForward(helpVector3).applyDirection(worldToCameraMatrix);
                hemisphereLightBuffer[offset++] = -helpVector3.x; // Left-hand.
                hemisphereLightBuffer[offset++] = -helpVector3.y;
                hemisphereLightBuffer[offset++] = -helpVector3.z;
                //
                hemisphereLightBuffer[offset++] = color.r * intensity;
                hemisphereLightBuffer[offset++] = color.g * intensity;
                hemisphereLightBuffer[offset++] = color.b * intensity;
                //
                hemisphereLightBuffer[offset++] = groundColor.r * intensity;
                hemisphereLightBuffer[offset++] = groundColor.g * intensity;
                hemisphereLightBuffer[offset++] = groundColor.b * intensity;
                light.castShadows = false; //TODO 不支持阴影，防止贴图报错
            }
        };
        /**
         * @internal
         */
        CameraRenderContext.prototype._update = function () {
            this.logDepthBufFC = 2.0 / (Math.log(this._camera.far + 1.0) / Math.LN2);
            if (this._cameraAndLightCollecter.currentShadowLight) {
                this._shadowFrustumCulling();
            }
            else {
                this._frustumCulling();
                this._updateLights();
            }
        };
        return CameraRenderContext;
    }());
    egret3d.CameraRenderContext = CameraRenderContext;
    __reflect(CameraRenderContext.prototype, "egret3d.CameraRenderContext");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @internal
     */
    var CameraAndLightSystem = (function (_super) {
        __extends(CameraAndLightSystem, _super);
        function CameraAndLightSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._cameraAndLightCollecter = paper.Application.sceneManager.globalEntity.getComponent(egret3d.CameraAndLightCollecter);
            return _this;
        }
        CameraAndLightSystem.prototype.getMatchers = function () {
            return [
                paper.Matcher.create(egret3d.Transform, egret3d.Camera),
                paper.Matcher.create(egret3d.Transform).anyOf(egret3d.DirectionalLight, egret3d.SpotLight, egret3d.PointLight, egret3d.HemisphereLight),
            ];
        };
        CameraAndLightSystem.prototype.onEntityAdded = function (_entity, group) {
            var groups = this.groups;
            var cameraAndLightCollecter = this._cameraAndLightCollecter;
            if (group === groups[0]) {
                cameraAndLightCollecter.updateCameras(groups[0].entities);
            }
            else if (group === groups[1]) {
                cameraAndLightCollecter.updateLights(groups[1].entities);
            }
        };
        CameraAndLightSystem.prototype.onEntityRemoved = function (_entity, group) {
            var groups = this.groups;
            var cameraAndLightCollecter = this._cameraAndLightCollecter;
            if (group === groups[0]) {
                cameraAndLightCollecter.updateCameras(groups[0].entities);
            }
            else if (group === groups[1]) {
                cameraAndLightCollecter.updateLights(groups[1].entities);
            }
        };
        CameraAndLightSystem.prototype.onFrame = function () {
            var cameraAndLightCollecter = this._cameraAndLightCollecter;
            if (cameraAndLightCollecter.cameras.length > 0) {
                cameraAndLightCollecter.sortCameras();
            }
        };
        CameraAndLightSystem.prototype.onFrameCleanup = function () {
            this._cameraAndLightCollecter.lightCountDirty = egret3d.LightCountDirty.None;
        };
        return CameraAndLightSystem;
    }(paper.BaseSystem));
    egret3d.CameraAndLightSystem = CameraAndLightSystem;
    __reflect(CameraAndLightSystem.prototype, "egret3d.CameraAndLightSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 天空盒组件。
     */
    var SkyBox = (function (_super) {
        __extends(SkyBox, _super);
        function SkyBox() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._materials = [];
            return _this;
        }
        SkyBox.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            for (var _i = 0, _a = this._materials; _i < _a.length; _i++) {
                var material = _a[_i];
                if (material) {
                    material.release();
                }
            }
            this._materials.length = 0;
        };
        Object.defineProperty(SkyBox.prototype, "materials", {
            /**
             * 该组件的材质列表。
             */
            get: function () {
                return this._materials;
            },
            set: function (value) {
                var materials = this._materials;
                for (var _i = 0, materials_3 = materials; _i < materials_3.length; _i++) {
                    var material = materials_3[_i];
                    if (material) {
                        material.release();
                    }
                }
                if (value !== materials) {
                    materials.length = 0;
                    for (var _a = 0, value_2 = value; _a < value_2.length; _a++) {
                        var material = value_2[_a];
                        materials.push(material);
                    }
                }
                for (var _b = 0, materials_4 = materials; _b < materials_4.length; _b++) {
                    var material = materials_4[_b];
                    if (material) {
                        material.retain();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkyBox.prototype, "material", {
            /**
             * 该组件材质列表中的第一个材质。
             */
            get: function () {
                var materials = this._materials;
                return materials.length > 0 ? materials[0] : null;
            },
            set: function (value) {
                var dirty = false;
                var materials = this._materials;
                var existingMaterial = null;
                if (materials.length > 0) {
                    existingMaterial = materials[0];
                    if (existingMaterial !== value) {
                        dirty = true;
                    }
                }
                else if (value) {
                    dirty = true;
                }
                if (dirty) {
                    if (existingMaterial) {
                        existingMaterial.release();
                    }
                    if (value) {
                        value.retain();
                    }
                    materials[0] = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.editor.property("MATERIAL_ARRAY" /* MATERIAL_ARRAY */),
            paper.serializedField
        ], SkyBox.prototype, "materials", null);
        return SkyBox;
    }(paper.BaseComponent));
    egret3d.SkyBox = SkyBox;
    __reflect(SkyBox.prototype, "egret3d.SkyBox");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var postprocess;
    (function (postprocess) {
        var FXAAPostProcess = (function (_super) {
            __extends(FXAAPostProcess, _super);
            function FXAAPostProcess() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            FXAAPostProcess.prototype.onRender = function (camera) {
                egret3d.DefaultMaterials.FXAA.setTexture(camera.postprocessingRenderTarget);
                this.blit(camera.postprocessingRenderTarget, egret3d.DefaultMaterials.FXAA);
            };
            return FXAAPostProcess;
        }(egret3d.CameraPostprocessing));
        postprocess.FXAAPostProcess = FXAAPostProcess;
        __reflect(FXAAPostProcess.prototype, "egret3d.postprocess.FXAAPostProcess");
    })(postprocess = egret3d.postprocess || (egret3d.postprocess = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    // export const enum ShadowFilteringType {
    //     None,
    //     PCF,
    //     PCF_SOFT
    // }
    /**
     * 灯光的阴影。
     */
    var LightShadow = (function () {
        function LightShadow(light) {
            /**
             * 该阴影的边缘模糊。
             */
            this.radius = 1.0;
            /**
             * 该阴影的贴图偏差。
             */
            this.bias = 0.0; // TODO
            /**
             * 产生该阴影的灯光位置到近裁剪面距离。
             */
            this.near = 0.5;
            /**
             * 产生该阴影的灯光位置到远裁剪面距离。
             */
            this.far = 500.0;
            /**
             * 该阴影的范围。（仅用于平行光产生的阴影）
             */
            this.size = 10.0;
            /**
             *
             */
            // public filteringType: ShadowFilteringType = ShadowFilteringType.PCF;//TODO
            /**
             *
             */
            // public rgbaDepthPacking: boolean = true;
            this._mapSize = 512;
            /**
             * @internal
             */
            this._matrix = egret3d.Matrix4.create();
            /**
             * @internal
             */
            this._renderTarget = egret3d.RenderTexture.create({ width: 512, height: 512 });
            this._light = null;
            /**
             * @internal
             */
            this._onUpdate = null;
            this._light = light;
        }
        /**
         * @internal
         */
        LightShadow.create = function (light) {
            return new LightShadow(light);
        };
        LightShadow.prototype.serialize = function () {
            return [this.radius, this.bias, this._mapSize, this.near, this.far, this.size];
        };
        LightShadow.prototype.deserialize = function (data) {
            this.radius = data[0];
            this.bias = data[1];
            this.mapSize = data[2];
            this.near = data[3];
            this.far = data[4];
            this.size = data[5];
            return this;
        };
        Object.defineProperty(LightShadow.prototype, "mapSize", {
            /**
             * 该阴影的贴图尺寸。
             */
            get: function () {
                return this._mapSize;
            },
            set: function (value) {
                value = Math.min(value, egret3d.renderState.maxTextureSize);
                if (this._mapSize === value) {
                    return;
                }
                if (this._light.constructor === egret3d.PointLight) {
                    this._renderTarget.uploadTexture(value * 4.0, value * 2.0);
                }
                else {
                    this._renderTarget.uploadTexture(value, value);
                }
                this._mapSize = value;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], LightShadow.prototype, "radius", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: -0.0002, maximum: 0.0002, step: 0.000001 })
        ], LightShadow.prototype, "bias", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.01, maximum: 9999 })
        ], LightShadow.prototype, "near", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.02, maximum: 10000 })
        ], LightShadow.prototype, "far", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.01 })
        ], LightShadow.prototype, "size", void 0);
        __decorate([
            paper.editor.property("UINT" /* UINT */)
        ], LightShadow.prototype, "mapSize", null);
        return LightShadow;
    }());
    egret3d.LightShadow = LightShadow;
    __reflect(LightShadow.prototype, "egret3d.LightShadow", ["paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 几何圆柱（椎）体。
     * - 与 Y 轴对齐。
     */
    var Cylinder = (function (_super) {
        __extends(Cylinder, _super);
        /**
         * 请使用 `egret3d.Cylinder.create()` 创建实例。
         * @see egret3d.Cylinder.create()
         */
        function Cylinder() {
            var _this = _super.call(this) || this;
            /**
             * 该圆柱（锥）体的顶部半径。
             */
            _this.topRadius = 0.0;
            /**
             * 该圆柱（锥）体的底部半径。
             */
            _this.bottomRadius = 0.0;
            /**
             * 该圆柱（锥）体的高度。
             */
            _this.height = 0.0;
            /**
             * 该圆柱（锥）体的中心点。
             */
            _this.center = egret3d.Vector3.create();
            return _this;
        }
        /**
         * 创建一个几何圆柱（椎）体。
         * @param center 中心点。
         * @param radius 半径。
         */
        Cylinder.create = function (center, topRadius, bottomRadius, height) {
            if (center === void 0) { center = egret3d.Vector3.ZERO; }
            if (topRadius === void 0) { topRadius = 0.0; }
            if (bottomRadius === void 0) { bottomRadius = 0.0; }
            if (height === void 0) { height = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(center, topRadius, bottomRadius, height);
                instance._released = false;
                return instance;
            }
            return new Cylinder().set(center, topRadius, bottomRadius, height);
        };
        Cylinder.prototype.serialize = function () {
            return [this.center.x, this.center.y, this.center.z, this.topRadius, this.bottomRadius, this.height];
        };
        Cylinder.prototype.deserialize = function (value) {
            this.topRadius = value[3];
            this.bottomRadius = value[4];
            this.height = value[5];
            this.center.fromArray(value);
            return this;
        };
        Cylinder.prototype.clone = function () {
            return Cylinder.create(this.center, this.topRadius, this.bottomRadius, this.height);
        };
        Cylinder.prototype.copy = function (value) {
            return this.set(value.center, value.topRadius, value.bottomRadius, value.height);
        };
        Cylinder.prototype.set = function (center, topRadius, bottomRadius, height) {
            this.topRadius = topRadius;
            this.bottomRadius = bottomRadius;
            this.height = height;
            this.center.copy(center);
            return this;
        };
        /**
         * 该几何体是否包含指定的点。
         * @param point 一个点。
         */
        Cylinder.prototype.contains = function (point) {
            var x = point.x, y = point.y, z = point.z;
            var _a = this, topRadius = _a.topRadius, bottomRadius = _a.bottomRadius, height = _a.height, center = _a.center;
            var halfHeight = height * 0.5;
            if (y < center.y - halfHeight || center.y + halfHeight < y) {
                return false;
            }
            var maxRadius = topRadius < bottomRadius ? bottomRadius : topRadius;
            if (x < center.x - maxRadius || center.x + maxRadius < x) {
                return false;
            }
            if (z < center.z - maxRadius || center.z + maxRadius < z) {
                return false;
            }
            var dX = x - center.x;
            var dY = y - (center.y + halfHeight);
            var dZ = z - center.z;
            var dRadius = egret3d.math.lerp(topRadius, bottomRadius, dY / height);
            return (dX * dX + dZ * dZ) <= dRadius * dRadius;
        };
        Cylinder.prototype.raycast = function (ray, raycastInfo) {
            if (raycastInfo === void 0) { raycastInfo = null; }
            var _a = this, topRadius = _a.topRadius, bottomRadius = _a.bottomRadius, height = _a.height, center = _a.center;
            var begin = egret3d.helpVector3A.copy(ray.origin).subtract(center);
            var end = egret3d.helpVector3B.multiplyScalar(100000.0, ray.direction).add(begin); // TODO 精度问题。
            var isCone = topRadius !== bottomRadius;
            var p1x = begin.x;
            var p1y = begin.y;
            var p1z = begin.z;
            var p2x = end.x;
            var p2y = end.y;
            var p2z = end.z;
            var halfHeight = height * 0.5;
            var dx = p2x - p1x;
            var dy = p2y - p1y;
            var dz = p2z - p1z;
            // Y
            var tminy = 0.0;
            var tmaxy = 1.0;
            if (-2.220446049250313e-16 /* EPSILON */ < dy && dy < 2.220446049250313e-16 /* EPSILON */) {
                if (p1y <= -halfHeight || halfHeight <= p1y) {
                    return false;
                }
            }
            else {
                var invDy = 1.0 / dy;
                var t1 = (-halfHeight - p1y) * invDy;
                var t2 = (halfHeight - p1y) * invDy;
                if (t1 > t2) {
                    var tmp = t1;
                    t1 = t2;
                    t2 = tmp;
                }
                if (t1 > 0.0)
                    tminy = t1;
                if (t2 < 1.0)
                    tmaxy = t2;
            }
            if (tminy >= 1.0 || tmaxy <= 0.0)
                return false;
            // XZ
            var tminxz = 0.0;
            var tmaxxz = 1.0;
            var sinTheta = 0.0;
            var cosTheta = 0.0;
            if (isCone) {
                var dRadius = bottomRadius - topRadius;
                var cc = Math.sqrt(dRadius * dRadius + height * height);
                var offsetY = height / dRadius * bottomRadius - halfHeight;
                p1y -= offsetY; // translate so that the new origin be (0, -offsetY, 0)
                sinTheta = dRadius / cc;
                cosTheta = height / cc;
                var cos2 = cosTheta * cosTheta;
                var a = cos2 * (dx * dx + dy * dy + dz * dz) - dy * dy;
                var b = cos2 * (p1x * dx + p1y * dy + p1z * dz) - p1y * dy;
                var c = cos2 * (p1x * p1x + p1y * p1y + p1z * p1z) - p1y * p1y;
                var d = b * b - a * c;
                if (a !== 0.0) {
                    if (d < 0.0)
                        return false;
                    var sqrtD = Math.sqrt(d);
                    var ia = 1.0 / a;
                    if (a < 0.0) {
                        if (dy > 0.0) {
                            tminxz = 0.0;
                            tmaxxz = (-b + sqrtD) * ia;
                            if (tmaxxz <= 0.0)
                                return false;
                        }
                        else {
                            tminxz = (-b - sqrtD) * ia;
                            tmaxxz = 1.0;
                            if (tminxz >= 1.0)
                                return false;
                        }
                    }
                    else {
                        tminxz = (-b - sqrtD) * ia;
                        tmaxxz = (-b + sqrtD) * ia;
                        if (tminxz >= 1.0 || tmaxxz <= 0.0)
                            return false;
                    }
                }
                else {
                    var t = -c / (2.0 * b);
                    if (b > 0.0) {
                        tminxz = 0.0;
                        tmaxxz = t;
                        if (t <= 0.0)
                            return false;
                    }
                    else {
                        tminxz = t;
                        tmaxxz = 1.0;
                        if (t >= 1.0)
                            return false;
                    }
                }
                p1y += offsetY; // revert translation
            }
            else {
                var a = dx * dx + dz * dz;
                var b = p1x * dx + p1z * dz;
                var c = (p1x * p1x + p1z * p1z) - bottomRadius * bottomRadius;
                var d = b * b - a * c;
                if (d < 0.0)
                    return false;
                if (a > 0.0) {
                    var sqrtD = Math.sqrt(d);
                    tminxz = (-b - sqrtD) / a;
                    tmaxxz = (-b + sqrtD) / a;
                    if (tminxz >= 1.0 || tmaxxz <= 0.0)
                        return false;
                }
                else {
                    if (c >= 0.0)
                        return false;
                    tminxz = 0.0;
                    tmaxxz = 1.0;
                }
            }
            var min;
            if (tmaxxz <= tminy || tmaxy <= tminxz)
                return false;
            if (tminxz < tminy) {
                min = tminy;
                if (min === 0.0)
                    return false; // the ray starts from inside
                if (raycastInfo && raycastInfo.normal) {
                    raycastInfo.normal.set(0.0, dy > 0.0 ? -1.0 : 1.0, 0.0);
                }
            }
            else {
                min = tminxz;
                if (min === 0.0)
                    return false; // the ray starts from inside
                if (raycastInfo && raycastInfo.normal) {
                    raycastInfo.normal.set(p1x + dx * min, 0.0, p1z + dz * min).normalize();
                    if (isCone) {
                        raycastInfo.normal.multiplyScalar(cosTheta);
                        raycastInfo.normal.y += sinTheta;
                    }
                }
            }
            if (raycastInfo) {
                raycastInfo.distance = min;
                raycastInfo.position
                    .set(p1x + min * dx, p1y + min * dy, p1z + min * dz)
                    .add(center);
            }
            return true;
        };
        Cylinder._instances = [];
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], Cylinder.prototype, "topRadius", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], Cylinder.prototype, "bottomRadius", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], Cylinder.prototype, "height", void 0);
        __decorate([
            paper.editor.property("VECTOR3" /* VECTOR3 */)
        ], Cylinder.prototype, "center", void 0);
        return Cylinder;
    }(paper.BaseRelease));
    egret3d.Cylinder = Cylinder;
    __reflect(Cylinder.prototype, "egret3d.Cylinder", ["paper.ICCS", "paper.ISerializable", "egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 平行光组件。
     */
    var DirectionalLight = (function (_super) {
        __extends(DirectionalLight, _super);
        function DirectionalLight() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DirectionalLight.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.shadow._onUpdate = this._updateShadow.bind(this);
        };
        DirectionalLight.prototype._updateShadow = function () {
            var shadowCamera = egret3d.cameraAndLightCollecter.shadowCamera;
            var shadow = this.shadow;
            var shadowMatrix = shadow._matrix;
            var transform = this.gameObject.transform;
            //
            shadowCamera.viewport.set(0.0, 0.0, 1, 1);
            shadowCamera.projectionMatrix = egret3d.Matrix4.create().fromProjection(shadow.near, shadow.far, 0.0, shadow.size, 0.0, 1.0, 0.0).release();
            shadowCamera.transform
                .setLocalPosition(transform.position)
                .setLocalRotation(transform.rotation); // TODO
            // matrix * 0.5 + 0.5, after identity, range is 0 ~ 1 instead of -1 ~ 1
            shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0).multiply(shadowCamera.projectionMatrix).multiply(shadowCamera.worldToCameraMatrix);
        };
        return DirectionalLight;
    }(egret3d.BaseLight));
    egret3d.DirectionalLight = DirectionalLight;
    __reflect(DirectionalLight.prototype, "egret3d.DirectionalLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 聚光组件。
     */
    var SpotLight = (function (_super) {
        __extends(SpotLight, _super);
        function SpotLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 该灯光组件光照强度线性衰减的速度。
             * - 0 不衰减。
             */
            _this.decay = 1.0;
            /**
             * 该灯光组件光照强度线性衰减的距离。
             * - 0 不衰减。
             */
            _this.distance = 0.0;
            /**
             * 该聚光灯产生的光锥夹角范围。（弧度制）
             */
            _this.angle = 3.141592653589793 /* PI */ / 0.3;
            /**
             * 该聚光灯产生的光锥半影。
             */
            _this.penumbra = 0.0;
            return _this;
        }
        SpotLight.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.shadow._onUpdate = this._updateShadow.bind(this);
        };
        SpotLight.prototype._updateShadow = function () {
            var shadowCamera = egret3d.cameraAndLightCollecter.shadowCamera;
            var shadow = this.shadow;
            var shadowMatrix = shadow._matrix;
            var transform = this.gameObject.transform;
            //
            shadowCamera.viewport.set(0.0, 0.0, 1, 1);
            shadowCamera.projectionMatrix = egret3d.Matrix4.create().fromProjection(shadow.near, shadow.far, this.angle * 2.0, 0.0, 1.0, 1.0, 0.0).release();
            shadowCamera.transform
                .setLocalPosition(transform.position)
                .setLocalRotation(transform.rotation); // TODO
            // matrix * 0.5 + 0.5, after identity, range is 0 ~ 1 instead of -1 ~ 1
            shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0).multiply(shadowCamera.projectionMatrix).multiply(shadowCamera.worldToCameraMatrix);
        };
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], SpotLight.prototype, "decay", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], SpotLight.prototype, "distance", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.01, maximum: 3.141592653589793 /* PI */ - 0.01 })
        ], SpotLight.prototype, "angle", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0, maximum: 1.0 })
        ], SpotLight.prototype, "penumbra", void 0);
        return SpotLight;
    }(egret3d.BaseLight));
    egret3d.SpotLight = SpotLight;
    __reflect(SpotLight.prototype, "egret3d.SpotLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 矩形区域光组件。
     */
    var RectangleAreaLight = (function (_super) {
        __extends(RectangleAreaLight, _super);
        function RectangleAreaLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             *
             */
            _this.width = 1.0;
            /**
             *
             */
            _this.height = 1.0;
            return _this;
        }
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], RectangleAreaLight.prototype, "width", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], RectangleAreaLight.prototype, "height", void 0);
        return RectangleAreaLight;
    }(egret3d.BaseLight));
    egret3d.RectangleAreaLight = RectangleAreaLight;
    __reflect(RectangleAreaLight.prototype, "egret3d.RectangleAreaLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _targets = [
        egret3d.Vector3.RIGHT, egret3d.Vector3.LEFT,
        egret3d.Vector3.FORWARD, egret3d.Vector3.BACK,
        egret3d.Vector3.UP, egret3d.Vector3.DOWN,
    ];
    var _ups = [
        egret3d.Vector3.UP, egret3d.Vector3.UP,
        egret3d.Vector3.UP, egret3d.Vector3.UP,
        egret3d.Vector3.FORWARD, egret3d.Vector3.BACK,
    ];
    //  xzXZ
    //   y Y
    //
    // X - Positive x direction
    // x - Negative x direction
    // Y - Positive y direction
    // y - Negative y direction
    // Z - Positive z direction
    // z - Negative z direction
    var _viewPortsScale = [
        new egret3d.Rectangle(2, 1, 1, 1), new egret3d.Rectangle(0, 1, 1, 1), new egret3d.Rectangle(3, 1, 1, 1),
        new egret3d.Rectangle(1, 1, 1, 1), new egret3d.Rectangle(3, 0, 1, 1), new egret3d.Rectangle(1, 0, 1, 1)
    ];
    /**
     * 点光组件。
     */
    var PointLight = (function (_super) {
        __extends(PointLight, _super);
        function PointLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 该灯光组件光照强度线性衰减的速度。
             * - 0 不衰减。
             */
            _this.decay = 1.0;
            /**
             * 该灯光组件光照强度线性衰减的距离。
             * - 0 不衰减。
             */
            _this.distance = 0.0;
            return _this;
        }
        PointLight.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.shadow._onUpdate = this._updateShadow.bind(this);
            // TODO
            var mapSize = this.shadow.mapSize;
            this.shadow._renderTarget.uploadTexture(mapSize * 4.0, mapSize * 2.0);
        };
        PointLight.prototype._updateShadow = function (face) {
            var shadowCamera = egret3d.cameraAndLightCollecter.shadowCamera;
            var shadow = this.shadow;
            var shadowMatrix = shadow._matrix;
            var lightPosition = this.gameObject.transform.position;
            //
            shadowCamera.viewport.copy(_viewPortsScale[face]);
            shadowCamera.projectionMatrix = egret3d.Matrix4.create().fromProjection(shadow.near, shadow.far, 1.5707963267948966 /* PI_HALF */, 0.0, 1.0, 1.0, 0.0).release();
            shadowCamera.transform
                .setLocalPosition(lightPosition)
                .lookAt(lightPosition.clone().add(_targets[face]).release(), _ups[face]);
            //
            shadowMatrix.fromTranslate(lightPosition.clone().multiplyScalar(-1.0).release());
        };
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], PointLight.prototype, "decay", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], PointLight.prototype, "distance", void 0);
        return PointLight;
    }(egret3d.BaseLight));
    egret3d.PointLight = PointLight;
    __reflect(PointLight.prototype, "egret3d.PointLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 半球光组件。
     */
    var HemisphereLight = (function (_super) {
        __extends(HemisphereLight, _super);
        function HemisphereLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 该灯光的背景颜色。
             */
            _this.groundColor = egret3d.Color.create(0.0, 0.0, 0.0, 1.0);
            return _this;
        }
        __decorate([
            paper.serializedField,
            paper.editor.property("COLOR" /* COLOR */)
        ], HemisphereLight.prototype, "groundColor", void 0);
        return HemisphereLight;
    }(egret3d.BaseLight));
    egret3d.HemisphereLight = HemisphereLight;
    __reflect(HemisphereLight.prototype, "egret3d.HemisphereLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 绘制信息。
     */
    var DrawCall = (function (_super) {
        __extends(DrawCall, _super);
        function DrawCall() {
            var _this = _super.call(this) || this;
            /**
             * 绘制次数。
             * - 用于调试模式下检测重复绘制的情况。
             */
            _this.drawCount = -1;
            /**
             *
             */
            _this.entity = null;
            /**
             * 此次绘制的渲染组件。
             */
            _this.renderer = null;
            /**
             * 此次绘制的世界矩阵。
             */
            _this.matrix = null;
            /**
             * 此次绘制的子网格索引。
             */
            _this.subMeshIndex = -1;
            /**
             * 此次绘制的网格资源。
             */
            _this.mesh = null;
            /**
             * 此次绘制的材质资源。
             */
            _this.material = null;
            /**
             *
             */
            _this.zdist = -1.0;
            /**
             * TODO
             */
            _this.count = 0;
            return _this;
        }
        /**
         * 创建一个绘制信息。
         * - 只有在扩展渲染系统时才需要手动创建绘制信息。
         */
        DrawCall.create = function () {
            if (this._instances.length > 0) {
                var instance = this._instances.pop();
                instance._released = false;
                return instance;
            }
            return new DrawCall();
        };
        DrawCall.prototype.onClear = function () {
            this.drawCount = -1;
            this.entity = null;
            this.renderer = null;
            this.matrix = null;
            this.subMeshIndex = -1;
            this.mesh = null;
            this.material = null;
            this.zdist = -1.0;
        };
        DrawCall._instances = [];
        return DrawCall;
    }(paper.BaseRelease));
    egret3d.DrawCall = DrawCall;
    __reflect(DrawCall.prototype, "egret3d.DrawCall");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 雾的模式。
     */
    var FogMode;
    (function (FogMode) {
        FogMode[FogMode["None"] = 0] = "None";
        FogMode[FogMode["Fog"] = 1] = "Fog";
        FogMode[FogMode["FogEXP2"] = 2] = "FogEXP2";
    })(FogMode = egret3d.FogMode || (egret3d.FogMode = {}));
    /**
     * 雾。
     */
    var Fog = (function () {
        function Fog(scene) {
            /**
             * 雾的强度。
             */
            this.density = 0.01;
            /**
             * 雾的近平面。
             * - 最小值 0.01。
             */
            this.near = 0.01;
            /**
             * 雾的远平面。
             * - 最小值 0.02。
             */
            this.far = 100.0;
            /**
             * 雾的颜色。
             */
            this.color = egret3d.Color.create(0.5, 0.5, 0.5, 1);
            this._mode = 0 /* None */;
            this._scene = scene;
        }
        /**
         * @internal
         */
        Fog.create = function (scene) {
            return new Fog(scene);
        };
        Fog.prototype.serialize = function () {
            return [this.mode, this.density, this.near, this.far]
                .concat(this.color.serialize());
        };
        Fog.prototype.deserialize = function (data) {
            this.mode = data[0];
            this.density = data[1];
            this.near = data[2];
            this.far = data[3];
            this.color.fromArray(data, 4);
            return this;
        };
        Object.defineProperty(Fog.prototype, "mode", {
            /**
             * 雾的模式。
             */
            get: function () {
                return this._mode;
            },
            set: function (value) {
                if (this._mode === value) {
                    return;
                }
                var scene = this._scene;
                this._mode = value;
                switch (value) {
                    case 1 /* Fog */:
                        scene.defines.addDefine("USE_FOG" /* USE_FOG */);
                        scene.defines.removeDefine("FOG_EXP2" /* FOG_EXP2 */);
                        break;
                    case 2 /* FogEXP2 */:
                        scene.defines.addDefine("USE_FOG" /* USE_FOG */);
                        scene.defines.addDefine("FOG_EXP2" /* FOG_EXP2 */);
                        break;
                    case 0 /* None */:
                        scene.defines.removeDefine("USE_FOG" /* USE_FOG */);
                        scene.defines.removeDefine("FOG_EXP2" /* FOG_EXP2 */);
                        break;
                }
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], Fog.prototype, "density", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.01, step: 1.0 })
        ], Fog.prototype, "near", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.02, step: 1.0 })
        ], Fog.prototype, "far", void 0);
        __decorate([
            paper.editor.property("COLOR" /* COLOR */)
        ], Fog.prototype, "color", void 0);
        __decorate([
            paper.editor.property("LIST" /* LIST */, { listItems: paper.editor.getItemsFromEnum(egret3d.FogMode) }) // TODO
        ], Fog.prototype, "mode", null);
        return Fog;
    }());
    egret3d.Fog = Fog;
    __reflect(Fog.prototype, "egret3d.Fog", ["paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 场景。
     */
    var Scene = (function (_super) {
        __extends(Scene, _super);
        function Scene() {
            var _this = _super.call(this) || this;
            /**
             * 该场景的名称。
             */
            _this.name = "";
            /**
             * 额外数据，仅保存在编辑器环境，项目发布时该数据将被移除。
             */
            _this.extras = paper.Application.playerMode === 4 /* Editor */ ? {} : undefined;
            _this._isDestroyed = true;
            /**
             * @internal
             */
            _this._rootEntitiesDirty = false;
            _this._entities = [];
            _this._rootEntities = [];
            //#ifdef EGRET_3D
            /**
             * 该场景使用光照贴图时的光照强度。
             */
            _this.lightmapIntensity = 1.0;
            /**
             * 该场景的环境光。
             */
            _this.ambientColor = egret3d.Color.create(0.20, 0.20, 0.25, 1.0);
            /**
             * 该场景的雾。
             */
            _this.fog = egret3d.Fog.create(_this);
            /**
             *
             */
            _this.defines = new egret3d.Defines();
            _this._lightmaps = [];
            return _this;
        }
        /**
         * 创建一个空场景。
         * @param name 场景的名称。
         */
        Scene.createEmpty = function (name, isActive) {
            if (name === void 0) { name = "NoName" /* NoName */; }
            if (isActive === void 0) { isActive = true; }
            var scene = new paper.Scene();
            scene._isDestroyed = false;
            scene.name = name;
            this.onSceneCreated.dispatch([scene, isActive]);
            return scene;
        };
        /**
         * 通过指定的场景资源创建一个场景。
         * @param name 场景资源的名称。
         */
        Scene.create = function (name, combineStaticObjects) {
            if (combineStaticObjects === void 0) { combineStaticObjects = true; }
            var rawScene = paper.Asset.find(name);
            if (rawScene && rawScene instanceof paper.RawScene) {
                if (rawScene) {
                    var existedScene = paper.Application.sceneManager.getScene(rawScene.sceneName);
                    if (existedScene) {
                        console.warn("The scene with the same name already exists.");
                        return existedScene;
                    }
                }
                var scene = rawScene.createInstance();
                if (scene) {
                    //#ifdef EGRET_3D
                    if (combineStaticObjects && paper.Application.playerMode !== 4 /* Editor */) {
                        egret3d.combine(scene.gameObjects); // TODO
                    }
                    //#endif
                    return scene;
                }
            }
            else {
                console.warn("The scene don't exists.", name);
            }
            return null;
        };
        Object.defineProperty(Scene, "globalScene", {
            /**
             * 全局静态的场景。
             * - 全局场景无法被销毁。
             */
            get: function () {
                return paper.Application.sceneManager.globalScene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene, "editorScene", {
            /**
             * 全局静态编辑器的场景。
             */
            get: function () {
                return paper.Application.sceneManager.editorScene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene, "activeScene", {
            /**
             * 当前激活的场景。
             */
            get: function () {
                return paper.Application.sceneManager.activeScene;
            },
            set: function (value) {
                paper.Application.sceneManager.activeScene = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @internal
         */
        Scene.prototype._addEntity = function (entity) {
            var entities = this._entities;
            if (entities.indexOf(entity) < 0) {
                entities.push(entity);
                this._rootEntitiesDirty = true;
                return true;
            }
            return false;
        };
        /**
         * @internal
         */
        Scene.prototype._removeEntity = function (entity) {
            var entities = this._entities;
            var index = entities.indexOf(entity);
            if (index >= 0) {
                entities.splice(index, 1);
                this._rootEntitiesDirty = true;
                return true;
            }
            return false;
        };
        Scene.prototype.initialize = function () {
        };
        Scene.prototype.uninitialize = function () {
            this.name = "";
            if (this.extras) {
                this.extras = {};
            }
            this._rootEntitiesDirty = false;
            this._entities.length = 0;
            this._rootEntities.length = 0;
            //#ifdef EGRET_3D
            for (var _i = 0, _a = this._lightmaps; _i < _a.length; _i++) {
                var lightmap = _a[_i];
                if (lightmap) {
                    lightmap.release();
                }
            }
            this.lightmapIntensity = 1.0;
            this.ambientColor.set(0.20, 0.20, 0.25, 1.0);
            // this.fog.clear();
            this._lightmaps.length = 0;
            //#endif
        };
        Scene.prototype.destroy = function () {
            var sceneManager = paper.Application.sceneManager;
            if (this._isDestroyed) {
                console.warn("The scene has been destroyed.");
                return false;
            }
            if (this === sceneManager.globalScene || this === sceneManager.editorScene) {
                // console.warn("The scene has been destroyed.");
                return false;
            }
            var entities = this._entities;
            Scene.onSceneDestroy.dispatch(this);
            var i = entities.length;
            while (i--) {
                var entity = entities[i];
                if (!entity || entity.isDestroyed) {
                    continue;
                }
                entity.destroy();
            }
            this._isDestroyed = true;
            this._rootEntitiesDirty = true;
            entities.length = 0;
            Scene.onSceneDestroyed.dispatch(this);
            return true;
        };
        Scene.prototype.containsEntity = function (entity) {
            return this._entities.indexOf(entity) >= 0;
        };
        Scene.prototype.find = function (name) {
            for (var _i = 0, _a = this._entities; _i < _a.length; _i++) {
                var entity = _a[_i];
                if (entity.name === name) {
                    return entity;
                }
            }
            return null;
        };
        /**
         * 获取该场景指定标识的第一个实体。
         * - 仅返回第一个符合条件的实体。
         * @param tag 标识。
         */
        Scene.prototype.findWithTag = function (tag) {
            for (var _i = 0, _a = this._entities; _i < _a.length; _i++) {
                var entity = _a[_i];
                if (entity.tag === tag) {
                    return entity;
                }
            }
            return null;
        };
        /**
         * 获取该场景指定标识的全部实体。
         * - 返回符合条件的全部实体。
         * @param tag 标识。
         */
        Scene.prototype.findEntitiesWithTag = function (tag) {
            var entities = [];
            for (var _i = 0, _a = this._entities; _i < _a.length; _i++) {
                var entity = _a[_i];
                if (entity.tag === tag) {
                    entities.push(entity);
                }
            }
            return entities;
        };
        Object.defineProperty(Scene.prototype, "isDestroyed", {
            get: function () {
                return this._isDestroyed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene.prototype, "entityCount", {
            get: function () {
                return this._entities.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene.prototype, "entities", {
            get: function () {
                return this._entities;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene.prototype, "rootEntities", {
            get: function () {
                var rootEntities = this._rootEntities;
                if (this._rootEntitiesDirty) {
                    rootEntities.length = 0;
                    for (var _i = 0, _a = this._entities; _i < _a.length; _i++) {
                        var entity = _a[_i];
                        if (!(entity instanceof paper.GameObject) || !entity.transform.parent) {
                            rootEntities.push(entity);
                        }
                    }
                    this._rootEntitiesDirty = false;
                }
                return rootEntities;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene.prototype, "lightmaps", {
            /**
             * 该场景的光照贴图列表。
             */
            get: function () {
                return this._lightmaps;
            },
            set: function (value) {
                var lightmaps = this._lightmaps;
                for (var _i = 0, lightmaps_1 = lightmaps; _i < lightmaps_1.length; _i++) {
                    var lightmap = lightmaps_1[_i];
                    if (lightmap) {
                        lightmap.release();
                    }
                }
                if (value !== lightmaps) {
                    lightmaps.length = 0;
                    for (var _a = 0, value_3 = value; _a < value_3.length; _a++) {
                        var lightmap = value_3[_a];
                        lightmaps.push(lightmap);
                    }
                }
                for (var _b = 0, lightmaps_2 = lightmaps; _b < lightmaps_2.length; _b++) {
                    var lightmap = lightmaps_2[_b];
                    if (lightmap) {
                        lightmap.retain();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        Scene.prototype.findGameObjectsWithTag = function (tag) {
            return this.findEntitiesWithTag(tag);
        };
        /**
         * @deprecated
         */
        Scene.prototype.getRootGameObjects = function () {
            return this.rootEntities;
        };
        Object.defineProperty(Scene.prototype, "gameObjectCount", {
            /**
             * @deprecated
             */
            get: function () {
                return this._entities.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene.prototype, "gameObjects", {
            /**
             * @deprecated
             */
            get: function () {
                return this._entities;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 当场景被创建时派发事件。
         */
        Scene.onSceneCreated = new signals.Signal();
        /**
         * 当场景将要被销毁时派发事件。
         */
        Scene.onSceneDestroy = new signals.Signal();
        /**
         * 当场景被销毁时派发事件。
         */
        Scene.onSceneDestroyed = new signals.Signal();
        __decorate([
            paper.serializedField
        ], Scene.prototype, "name", void 0);
        __decorate([
            paper.serializedField
        ], Scene.prototype, "extras", void 0);
        __decorate([
            paper.serializedField("gameObjects"),
            paper.deserializedIgnore
        ], Scene.prototype, "entities", null);
        __decorate([
            paper.serializedField,
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], Scene.prototype, "lightmapIntensity", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("COLOR" /* COLOR */)
        ], Scene.prototype, "ambientColor", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property("NESTED" /* NESTED */)
        ], Scene.prototype, "fog", void 0);
        __decorate([
            paper.serializedField
        ], Scene.prototype, "lightmaps", null);
        return Scene;
    }(paper.BaseObject));
    paper.Scene = Scene;
    __reflect(Scene.prototype, "paper.Scene", ["paper.IScene"]);
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 网格过滤组件。
     * - 为网格渲染组件提供网格资源。
     */
    var MeshFilter = (function (_super) {
        __extends(MeshFilter, _super);
        function MeshFilter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._mesh = null;
            return _this;
        }
        /**
         * @internal
         */
        MeshFilter.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            if (this._mesh) {
                this._mesh.release();
            }
            this._mesh = null;
        };
        Object.defineProperty(MeshFilter.prototype, "mesh", {
            /**
             * 该组件的网格资源。
             */
            get: function () {
                return this._mesh;
            },
            set: function (value) {
                if (this._mesh === value) {
                    return;
                }
                if (this._mesh) {
                    this._mesh.release();
                }
                if (value) {
                    value.retain();
                }
                this._mesh = value;
                MeshFilter.onMeshChanged.dispatch(this);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 当网格过滤组件的网格资源改变时派发事件。
         */
        MeshFilter.onMeshChanged = new signals.Signal();
        __decorate([
            paper.editor.property("MESH" /* MESH */),
            paper.serializedField("_mesh")
        ], MeshFilter.prototype, "mesh", null);
        return MeshFilter;
    }(paper.BaseComponent));
    egret3d.MeshFilter = MeshFilter;
    __reflect(MeshFilter.prototype, "egret3d.MeshFilter");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 几何胶囊体。
     * - 与 Y 轴对齐。
     */
    var Capsule = (function (_super) {
        __extends(Capsule, _super);
        /**
         * 请使用 `egret3d.Capsule.create()` 创建实例。
         * @see egret3d.Capsule.create()
         */
        function Capsule() {
            var _this = _super.call(this) || this;
            /**
             * 该胶囊体的半径。
             */
            _this.radius = 0.0;
            /**
             * 该胶囊体圆柱部分的高度。
             */
            _this.height = 0.0;
            /**
             * 该胶囊体的中心点。
             */
            _this.center = egret3d.Vector3.create();
            return _this;
        }
        /**
         * 创建一个几何胶囊体。
         * @param center 中心点。
         * @param radius 半径。
         */
        Capsule.create = function (center, radius, height) {
            if (center === void 0) { center = egret3d.Vector3.ZERO; }
            if (radius === void 0) { radius = 0.0; }
            if (height === void 0) { height = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(center, radius, height);
                instance._released = false;
                return instance;
            }
            return new Capsule().set(center, radius, height);
        };
        Capsule.prototype.serialize = function () {
            return [this.center.x, this.center.y, this.center.z, this.radius, this.height];
        };
        Capsule.prototype.deserialize = function (value) {
            this.radius = value[3];
            this.height = value[4];
            this.center.fromArray(value);
            return this;
        };
        Capsule.prototype.clone = function () {
            return Capsule.create(this.center, this.radius, this.height);
        };
        Capsule.prototype.copy = function (value) {
            return this.set(value.center, value.radius, value.height);
        };
        Capsule.prototype.set = function (center, radius, height) {
            this.radius = radius;
            this.height = height;
            this.center.copy(center);
            return this;
        };
        /**
         * 该几何体是否包含指定的点。
         * @param point 一个点。
         */
        Capsule.prototype.contains = function (point) {
            var x = point.x, y = point.y, z = point.z;
            var _a = this, radius = _a.radius, center = _a.center;
            var halfHeight = this.height * 0.5;
            if (y < center.y - halfHeight - radius || center.y + halfHeight + radius < y) {
                return false;
            }
            if (x < center.x - radius || center.x + radius < x) {
                return false;
            }
            if (z < center.z - radius || center.z + radius < z) {
                return false;
            }
            var dX = x - center.x;
            var dY = y - center.y;
            var dZ = z - center.z;
            var radius2 = radius * radius;
            if (halfHeight > 0.0) {
                if (dY < -halfHeight) {
                    var bottomCenter = egret3d.helpVector3A.copy(center);
                    bottomCenter.y -= halfHeight;
                    return bottomCenter.getSquaredDistance(point) <= radius2;
                }
                else if (halfHeight < dY) {
                    var bottomCenter = egret3d.helpVector3A.copy(center);
                    bottomCenter.y += halfHeight;
                    return bottomCenter.getSquaredDistance(point) <= radius2;
                }
                return (dX * dX + dZ * dZ) <= radius2;
            }
            return center.getSquaredDistance(point) <= radius2;
        };
        Capsule.prototype.raycast = function (ray, raycastInfo) {
            if (raycastInfo === void 0) { raycastInfo = null; }
            var _a = this, radius = _a.radius, center = _a.center;
            var halfHeight = this.height * 0.5;
            var begin = egret3d.helpVector3A.copy(ray.origin).subtract(center);
            var end = egret3d.helpVector3B.multiplyScalar(100000.0, ray.direction).add(begin); // TODO 精度问题。
            var p1x = begin.x;
            var p1y = begin.y;
            var p1z = begin.z;
            var p2x = end.x;
            var p2y = end.y;
            var p2z = end.z;
            var radius2 = radius * radius;
            var dx = p2x - p1x;
            var dy = p2y - p1y;
            var dz = p2z - p1z;
            // XZ
            var tminxz = 0.0;
            var tmaxxz = 1.0;
            var a = dx * dx + dz * dz;
            var b = p1x * dx + p1z * dz;
            var c = (p1x * p1x + p1z * p1z) - radius2;
            var d = b * b - a * c;
            if (d < 0.0)
                return false;
            if (a > 0.0) {
                var sqrtD = Math.sqrt(d);
                var ia = 1.0 / a;
                tminxz = (-b - sqrtD) * ia;
                tmaxxz = (-b + sqrtD) * ia;
                if (tminxz >= 1.0 || tmaxxz <= 0.0)
                    return false;
            }
            else {
                if (c >= 0.0)
                    return false;
                tminxz = 0.0;
                tmaxxz = 1.0;
            }
            var min;
            var crossY = p1y + dy * tminxz;
            if (-halfHeight < crossY && crossY < halfHeight) {
                if (tminxz > 0.0) {
                    // hit: side
                    min = tminxz;
                    if (raycastInfo) {
                        var px = p1x + min * dx;
                        var py = p1z + min * dy;
                        raycastInfo.distance = min;
                        raycastInfo.position.set(px, crossY, py).add(center);
                        if (raycastInfo.normal) {
                            raycastInfo.normal.set(px, 0.0, py).normalize();
                        }
                    }
                    return true;
                }
                return false;
            }
            // Sphere test.
            var sphereCenter = egret3d.helpVector3C.set(center.x, center.y + (crossY < 0.0 ? -halfHeight : halfHeight), center.z);
            var v1 = egret3d.helpVector3D.subtract(sphereCenter, ray.origin);
            var tca = v1.dot(ray.direction);
            var d2 = v1.dot(v1) - tca * tca;
            if (d2 > radius2)
                return false;
            var thc = Math.sqrt(radius2 - d2);
            var t0 = tca - thc;
            var t1 = tca + thc;
            if (t0 < 0.0 || t1 < 0.0)
                return false;
            if (raycastInfo) {
                var position = ray.getPointAt(raycastInfo.distance = t0, raycastInfo.position);
                var normal = raycastInfo.normal;
                if (normal) {
                    normal.subtract(position, sphereCenter).normalize();
                }
            }
            return true;
        };
        Capsule._instances = [];
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], Capsule.prototype, "radius", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
        ], Capsule.prototype, "height", void 0);
        __decorate([
            paper.editor.property("VECTOR3" /* VECTOR3 */)
        ], Capsule.prototype, "center", void 0);
        return Capsule;
    }(paper.BaseRelease));
    egret3d.Capsule = Capsule;
    __reflect(Capsule.prototype, "egret3d.Capsule", ["paper.ICCS", "paper.ISerializable", "egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 网格渲染组件系统。
     * - 为网格渲染组件生成绘制信息。
     */
    var MeshRendererSystem = (function (_super) {
        __extends(MeshRendererSystem, _super);
        function MeshRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._drawCallCollecter = paper.Application.sceneManager.globalEntity.getComponent(egret3d.DrawCallCollecter);
            _this._materialFilter = [];
            return _this;
        }
        MeshRendererSystem.prototype._updateDrawCalls = function (entity, checkState) {
            if (checkState && !this.groups[0].containsEntity(entity)) {
                return;
            }
            var drawCallCollecter = this._drawCallCollecter;
            var filter = entity.getComponent(egret3d.MeshFilter);
            var renderer = entity.getComponent(egret3d.MeshRenderer);
            var mesh = filter.mesh;
            var materials = renderer.materials;
            var materialCount = materials.length;
            // Clear drawCalls.
            drawCallCollecter.removeDrawCalls(entity);
            if (!mesh || materialCount === 0) {
                return;
            }
            var primitives = mesh.glTFMesh.primitives;
            var subMeshCount = primitives.length;
            if (true && subMeshCount === 0) {
                throw new Error();
            }
            var materialFilter = this._materialFilter;
            var matrix = entity.getComponent(egret3d.Transform).localToWorldMatrix;
            if (materialFilter.length < materialCount) {
                materialFilter.length = materialCount;
            }
            for (var i = 0; i < subMeshCount; ++i) {
                var materialIndex = primitives[i].material;
                var material = null;
                if (materialIndex === undefined) {
                    material = egret3d.DefaultMaterials.MESH_BASIC;
                }
                else if (materialIndex < materialCount) {
                    material = materials[materialIndex];
                    materialFilter[materialIndex] = true;
                }
                if (material) {
                    var drawCall = egret3d.DrawCall.create();
                    drawCall.entity = entity;
                    drawCall.renderer = renderer;
                    drawCall.matrix = matrix;
                    drawCall.subMeshIndex = i;
                    drawCall.mesh = mesh;
                    drawCall.material = material;
                    drawCallCollecter.addDrawCall(drawCall);
                }
            }
            for (var i = 0; i < materialCount; ++i) {
                if (materialFilter[i]) {
                    continue;
                }
                var material = materials[i];
                for (var j = 0; j < subMeshCount; ++j) {
                    var drawCall = egret3d.DrawCall.create();
                    drawCall.entity = entity;
                    drawCall.renderer = renderer;
                    drawCall.matrix = matrix;
                    drawCall.subMeshIndex = j;
                    drawCall.mesh = mesh;
                    drawCall.material = material;
                    drawCallCollecter.addDrawCall(drawCall);
                }
            }
            // materialFilter.length = 0;
        };
        MeshRendererSystem.prototype.getMatchers = function () {
            return [
                paper.Matcher.create(egret3d.Transform, egret3d.MeshFilter, egret3d.MeshRenderer),
            ];
        };
        MeshRendererSystem.prototype.getListeners = function () {
            var _this = this;
            return [
                {
                    type: egret3d.MeshFilter.onMeshChanged, listener: function (component) {
                        _this._updateDrawCalls(component.entity, true);
                        var renderer = component.entity.getComponent(egret3d.MeshRenderer);
                        if (renderer) {
                            renderer._localBoundingBoxDirty = true;
                        }
                    }
                },
                {
                    type: egret3d.MeshRenderer.onMaterialsChanged, listener: function (component) {
                        _this._updateDrawCalls(component.entity, true);
                    }
                }
            ];
        };
        MeshRendererSystem.prototype.onEntityAdded = function (entity) {
            this._updateDrawCalls(entity, false);
        };
        MeshRendererSystem.prototype.onEntityRemoved = function (entity) {
            this._drawCallCollecter.removeDrawCalls(entity);
        };
        return MeshRendererSystem;
    }(paper.BaseSystem));
    egret3d.MeshRendererSystem = MeshRendererSystem;
    __reflect(MeshRendererSystem.prototype, "egret3d.MeshRendererSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3A = egret3d.Vector3.create();
    var _helpVector3B = egret3d.Vector3.create();
    var _helpVector3C = egret3d.Vector3.create();
    var _helpMatrix = egret3d.Matrix4.create();
    /**
     * 蒙皮网格渲染组件。
     */
    var SkinnedMeshRenderer = (function (_super) {
        __extends(SkinnedMeshRenderer, _super);
        function SkinnedMeshRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 强制使用 cpu 蒙皮。
             * - 骨骼数超过硬件支持的最大骨骼数量，或顶点权重大于 4 个，需要使用 CPU 蒙皮。
             * - CPU 蒙皮性能较低，仅是兼容方案，应合理的控制骨架的最大骨骼数量。
             */
            _this.forceCPUSkin = false;
            /**
             *
             */
            _this.boneMatrices = null;
            /**
             *
             */
            _this.boneTexture = null;
            /**
             *
             */
            _this.source = null;
            _this._skinnedDirty = true;
            _this._bones = [];
            _this._rootBone = null;
            /**
             * @internal
             */
            _this._retargetBoneNames = null;
            _this._mesh = null;
            _this._skinnedVertices = null;
            return _this;
        }
        SkinnedMeshRenderer.prototype._skinning = function (vertexOffset, vertexCount) {
            if (this._skinnedDirty) {
                var mesh = this._mesh;
                var boneMatrices = this.boneMatrices;
                var p0 = _helpVector3A;
                var p1 = _helpVector3B;
                var p2 = _helpVector3C;
                var vertices = mesh.getVertices();
                var indices = mesh.getIndices();
                var joints = mesh.getAttributes("JOINTS_0" /* JOINTS_0 */);
                var weights = mesh.getAttributes("WEIGHTS_0" /* WEIGHTS_0 */);
                if (!this._skinnedVertices) {
                    this._skinnedVertices = new Float32Array(vertices.length);
                }
                if (vertexCount === 0) {
                    vertexCount = indices.length;
                }
                else {
                    vertexCount += vertexOffset;
                }
                for (var i = vertexOffset; i < vertexCount; ++i) {
                    var index = indices[i];
                    var vertexIndex = index * 3;
                    var jointIndex = index * 4;
                    p0.fromArray(vertices, vertexIndex);
                    p1.clear();
                    for (var i_3 = 0; i_3 < 4; ++i_3) {
                        var weight = weights[jointIndex + i_3];
                        if (weight <= 0.01) {
                            continue;
                        }
                        p1.add(p2.applyMatrix(_helpMatrix.fromArray(boneMatrices, joints[jointIndex + i_3] * 16), p0).multiplyScalar(weight));
                    }
                    p1.toArray(this._skinnedVertices, vertexIndex);
                }
                if (vertexCount === indices.length) {
                    this._skinnedDirty = false;
                }
            }
            return this._skinnedVertices;
        };
        /**
         * @internal
         */
        SkinnedMeshRenderer.prototype._update = function () {
            var mesh = this._mesh;
            var boneMatrices = this.boneMatrices;
            if (mesh && !mesh.isDisposed && boneMatrices) {
                // TODO cache 剔除，脏标记。
                // TODO bind to GPU
                var bones = this._bones;
                var inverseBindMatrices = mesh.inverseBindMatrices;
                for (var i = 0, l = bones.length; i < l; ++i) {
                    var offset = i * 16;
                    var bone = bones[i];
                    var matrix = bone ? bone.localToWorldMatrix : egret3d.Matrix4.IDENTITY;
                    _helpMatrix.fromArray(inverseBindMatrices, offset).premultiply(matrix).toArray(boneMatrices, offset);
                }
                if (this.boneTexture) {
                    this.boneTexture.uploadTexture(boneMatrices); // TODO
                }
                if (this.forceCPUSkin) {
                    // this._skinning(0, 0); TODO
                }
                this._skinnedDirty = true;
                return true;
            }
        };
        /**
         * @internal
         */
        SkinnedMeshRenderer.prototype.initialize = function (reset) {
            _super.prototype.initialize.call(this);
            if (!reset) {
                return;
            }
            // TODO cache 剔除，脏标记。
            this._bones.length = 0;
            this.rootBone = null;
            this.boneMatrices = null;
            var mesh = this._mesh;
            var parent = this.gameObject.transform.parent;
            var bones = this._bones;
            if (mesh && parent) {
                var config = mesh.config;
                var skin = config.skins[0];
                var children = parent.getChildren({});
                if (skin.skeleton !== undefined) {
                    var rootNode = config.nodes[skin.skeleton];
                    if (rootNode.name in children) {
                        var transforms = children[rootNode.name];
                        this.rootBone = Array.isArray(transforms) ? transforms[0] : transforms;
                    }
                }
                for (var _i = 0, _a = skin.joints; _i < _a.length; _i++) {
                    var joint = _a[_i];
                    var node = config.nodes[joint];
                    if (node.name in children) {
                        var transforms = children[node.name];
                        bones.push(Array.isArray(transforms) ? transforms[0] : transforms);
                    }
                    else {
                        bones.push(null);
                    }
                }
                if (egret3d.renderState.textureFloatEnabled) {
                    // let size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix
                    // size = Math.max(math.ceilPowerOfTwo(size), 4);
                    // this.boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
                    // this.boneTexture = Texture.create({
                    //     source: this.boneMatrices,
                    //     width: size, height: size,
                    //     type: gltf.ComponentType.Float
                    // });
                    this.boneMatrices = new Float32Array((bones.length + 1) * 16);
                    this.boneTexture = egret3d.Texture.create({
                        source: this.boneMatrices,
                        width: (bones.length + 1) * 4, height: 1,
                        type: 5126 /* Float */
                    });
                    this.boneTexture.retain();
                }
                else {
                    this.boneMatrices = new Float32Array(bones.length * 16);
                    if (bones.length > egret3d.renderState.maxBoneCount) {
                        this.forceCPUSkin = true;
                        console.warn("The bone count of this mesh has exceeded the maxBoneCount and will use the forced CPU skin.", mesh.name);
                    }
                }
                this._update();
            }
        };
        /**
         * @internal
         */
        SkinnedMeshRenderer.prototype.uninitialize = function () {
            if (this._mesh) {
                this._mesh.release();
            }
            if (this.boneTexture) {
                this.boneTexture.release();
                this.boneTexture.dispose();
            }
            //transform可能已经被删除
            var boundingTransform = this.getBoundingTransform();
            if (boundingTransform) {
                boundingTransform.unregisterObserver(this);
            }
            _super.prototype.uninitialize.call(this);
            this.boneMatrices = null;
            this.boneTexture = null;
            this._bones.length = 0;
            this._rootBone = null;
            this._retargetBoneNames = null;
            this._mesh = null;
            this._skinnedVertices = null;
        };
        SkinnedMeshRenderer.prototype.recalculateLocalBox = function () {
            // TODO 蒙皮网格的 aabb 需要能自定义，或者强制更新。
            var mesh = this._mesh;
            this._localBoundingBox.clear();
            if (mesh && !mesh.isDisposed) {
                this._skinning(0, 0);
                var vertices = this._skinnedVertices;
                var position = egret3d.helpVector3A;
                var worldToLocalMatrix = this.getBoundingTransform().worldToLocalMatrix;
                for (var i = 0, l = vertices.length; i < l; i += 3) {
                    position.set(vertices[i], vertices[i + 1], vertices[i + 2]).applyMatrix(worldToLocalMatrix);
                    this._localBoundingBox.add(position);
                }
            }
        };
        /**
         * @internal
         */
        SkinnedMeshRenderer.prototype.getBoundingTransform = function () {
            return this._rootBone || this.gameObject.transform;
        };
        /**
         * 实时获取网格资源的指定三角形顶点位置。
         * - 采用 CPU 蒙皮指定顶点。
         */
        SkinnedMeshRenderer.prototype.getTriangle = function (triangleIndex, out) {
            if (!out) {
                out = egret3d.Triangle.create();
            }
            var mesh = this._mesh;
            var boneMatrices = this.boneMatrices;
            if (mesh && !mesh.isDisposed && boneMatrices) {
                mesh.getTriangle(triangleIndex, out, this._skinning(triangleIndex * 3, 3));
            }
            return out;
        };
        SkinnedMeshRenderer.prototype.raycast = function (ray, raycastInfo) {
            if (raycastInfo === void 0) { raycastInfo = null; }
            var mesh = this._mesh;
            var boneMatrices = this.boneMatrices;
            if (!mesh || mesh.isDisposed || !boneMatrices) {
                return false;
            }
            var transform = this.gameObject.transform;
            var boundingTransform = this.getBoundingTransform();
            var localRay = egret3d.helpRay.applyMatrix(boundingTransform.worldToLocalMatrix, ray);
            var localBoundingBox = this.localBoundingBox;
            if (localBoundingBox.raycast(localRay) && mesh.raycast(ray, raycastInfo, this.forceCPUSkin ? null : this._skinning(0, 0))) {
                if (raycastInfo) {
                    raycastInfo.transform = transform;
                }
                return true;
            }
            return false;
        };
        Object.defineProperty(SkinnedMeshRenderer.prototype, "boneCount", {
            /**
             *
             */
            get: function () {
                return this._bones.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkinnedMeshRenderer.prototype, "bones", {
            /**
             * 该渲染组件的骨骼列表。
             */
            get: function () {
                return this._bones;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkinnedMeshRenderer.prototype, "rootBone", {
            /**
             * 该渲染组件的根骨骼。
             */
            get: function () {
                return this._rootBone;
            },
            set: function (value) {
                if (this._rootBone === value) {
                    return;
                }
                this.getBoundingTransform().unregisterObserver(this);
                this._rootBone = value;
                this.getBoundingTransform().registerObserver(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkinnedMeshRenderer.prototype, "mesh", {
            /**
             * 该渲染组件的网格资源。
             */
            get: function () {
                return this._mesh;
            },
            set: function (value) {
                if (value && !value.config.scenes && !value.config.nodes && !value.config.skins) {
                    console.warn("Invalid skinned mesh.", value.name);
                    return;
                }
                if (this._mesh === value) {
                    return;
                }
                if (this._mesh) {
                    this._mesh.release();
                }
                if (value) {
                    value.retain();
                }
                this._mesh = value;
                SkinnedMeshRenderer.onMeshChanged.dispatch(this);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 当蒙皮网格渲染组件的网格资源改变时派发事件。
         */
        SkinnedMeshRenderer.onMeshChanged = new signals.Signal();
        __decorate([
            paper.editor.property("UINT" /* UINT */, { readonly: true })
        ], SkinnedMeshRenderer.prototype, "boneCount", null);
        __decorate([
            paper.editor.property("MESH" /* MESH */),
            paper.serializedField("_mesh")
        ], SkinnedMeshRenderer.prototype, "mesh", null);
        return SkinnedMeshRenderer;
    }(egret3d.MeshRenderer));
    egret3d.SkinnedMeshRenderer = SkinnedMeshRenderer;
    __reflect(SkinnedMeshRenderer.prototype, "egret3d.SkinnedMeshRenderer");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 蒙皮网格渲染组件系统。
     * - 为蒙皮网格渲染组件生成绘制信息。
     * - 更新蒙皮网格的骨骼矩阵信息。
     */
    var SkinnedMeshRendererSystem = (function (_super) {
        __extends(SkinnedMeshRendererSystem, _super);
        function SkinnedMeshRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._drawCallCollecter = paper.Application.sceneManager.globalEntity.getComponent(egret3d.DrawCallCollecter);
            _this._materialFilter = [];
            return _this;
        }
        SkinnedMeshRendererSystem.prototype._updateDrawCalls = function (entity, checkState) {
            if (checkState && !this.enabled || !this.groups[0].containsEntity(entity)) {
                return;
            }
            var drawCallCollecter = this._drawCallCollecter;
            var renderer = entity.getComponent(egret3d.SkinnedMeshRenderer);
            var mesh = renderer.mesh;
            var materials = renderer.materials;
            var materialCount = materials.length;
            // Clear drawCalls.
            drawCallCollecter.removeDrawCalls(entity);
            if (!mesh || materialCount === 0) {
                return;
            }
            var primitives = mesh.glTFMesh.primitives;
            var subMeshCount = primitives.length;
            if (true && subMeshCount === 0) {
                throw new Error();
            }
            var materialFilter = this._materialFilter;
            var matrix = egret3d.Matrix4.IDENTITY;
            materialFilter.length = materialCount;
            for (var i = 0; i < subMeshCount; ++i) {
                var materialIndex = primitives[i].material;
                var material = null;
                if (materialIndex === undefined) {
                    material = egret3d.DefaultMaterials.MESH_BASIC;
                }
                else if (materialIndex < materialCount) {
                    material = materials[materialIndex];
                    materialFilter[materialIndex] = true;
                }
                if (material) {
                    var drawCall = egret3d.DrawCall.create();
                    drawCall.entity = entity;
                    drawCall.renderer = renderer;
                    drawCall.matrix = matrix;
                    drawCall.subMeshIndex = i;
                    drawCall.mesh = mesh;
                    drawCall.material = material;
                    drawCallCollecter.addDrawCall(drawCall);
                }
            }
            for (var i = 0; i < materialCount; ++i) {
                if (materialFilter[i]) {
                    continue;
                }
                var material = materials[i];
                for (var j = 0; j < subMeshCount; ++j) {
                    var drawCall = egret3d.DrawCall.create();
                    drawCall.entity = entity;
                    drawCall.renderer = renderer;
                    drawCall.matrix = matrix;
                    drawCall.subMeshIndex = j;
                    drawCall.mesh = mesh;
                    drawCall.material = material;
                    drawCallCollecter.addDrawCall(drawCall);
                }
            }
            materialFilter.length = 0;
        };
        SkinnedMeshRendererSystem.prototype.getMatchers = function () {
            return [
                paper.Matcher.create(egret3d.Transform, egret3d.SkinnedMeshRenderer),
            ];
        };
        SkinnedMeshRendererSystem.prototype.getListeners = function () {
            var _this = this;
            return [
                {
                    type: egret3d.SkinnedMeshRenderer.onMeshChanged, listener: function (component) {
                        _this._updateDrawCalls(component.entity, true);
                        var renderer = component.entity.getComponent(egret3d.SkinnedMeshRenderer);
                        if (renderer) {
                            renderer._localBoundingBoxDirty = true;
                        }
                    }
                },
                {
                    type: egret3d.SkinnedMeshRenderer.onMaterialsChanged, listener: function (component) {
                        _this._updateDrawCalls(component.entity, true);
                    }
                },
            ];
        };
        SkinnedMeshRendererSystem.prototype.onEntityAdded = function (entity) {
            var renderer = entity.getComponent(egret3d.SkinnedMeshRenderer);
            if (renderer.mesh && !renderer.source && !renderer.boneMatrices) {
                renderer.initialize(true);
            }
            this._updateDrawCalls(entity, false);
        };
        SkinnedMeshRendererSystem.prototype.onEntityRemoved = function (entity) {
            this._drawCallCollecter.removeDrawCalls(entity);
        };
        SkinnedMeshRendererSystem.prototype.onFrame = function () {
            for (var _i = 0, _a = this.groups[0].entities; _i < _a.length; _i++) {
                var entity = _a[_i];
                entity.getComponent(egret3d.SkinnedMeshRenderer)._update();
            }
        };
        return SkinnedMeshRendererSystem;
    }(paper.BaseSystem));
    egret3d.SkinnedMeshRendererSystem = SkinnedMeshRendererSystem;
    __reflect(SkinnedMeshRendererSystem.prototype, "egret3d.SkinnedMeshRendererSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 可以添加egret2d显示对象（包括EUI）进行渲染。
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var Egret2DRenderer = (function (_super) {
        __extends(Egret2DRenderer, _super);
        function Egret2DRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @internal
             */
            _this._order = -1;
            /**
             * TODO
             */
            _this.frustumCulled = false;
            _this._screenAdapter = new egret3d.ConstantAdapter();
            _this._stageWidth = 0;
            _this._stageHeight = 0;
            _this._scaler = 1;
            return _this;
        }
        Object.defineProperty(Egret2DRenderer.prototype, "screenAdapter", {
            get: function () {
                return this._screenAdapter;
            },
            set: function (adapter) {
                adapter.$dirty = true;
                this._screenAdapter = adapter;
            },
            enumerable: true,
            configurable: true
        });
        Egret2DRenderer.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.stage = new egret.Stage();
            this.stage.maxTouches = 98;
            this.root = new egret.DisplayObjectContainer();
            this.stage.addChild(this.root);
            if (!this._renderer) {
                this._renderer = egret.web.Renderer.getInstance(egret3d.WebGLCapabilities.webgl || egret3d.Egret2DRendererSystem.webgl);
            }
            var stage = this.stage;
            var displayList = new egret.sys.DisplayList(stage);
            displayList.renderBuffer = new egret.sys.RenderBuffer(undefined, undefined, true);
            stage.$displayList = displayList;
            // TODO
            var webInput = paper.Application.systemManager.getSystem(egret3d.Egret2DRendererSystem).webInput;
            if (webInput) {
                egret.web.$cacheTextAdapter(webInput, stage, egret3d.Egret2DRendererSystem.canvas.parentNode, egret3d.Egret2DRendererSystem.canvas);
            }
        };
        Egret2DRenderer.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            this.stage.removeChild(this.root);
        };
        Egret2DRenderer.prototype.recalculateLocalBox = function () {
            // TODO
            this._localBoundingBox.size = egret3d.Vector3.ZERO;
        };
        Egret2DRenderer.prototype.raycast = function (p1, p2) {
            if (p2 === void 0) { p2 = null; }
            // TODO
            return false;
        };
        /**
         * screen position to ui position
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 从屏幕坐标转换到当前2D系统的坐标
         * @version paper 1.0
         * @platform Web
         * @language
         */
        Egret2DRenderer.prototype.screenPosToUIPos = function (pos, out) {
            if (out === void 0) { out = new egret3d.Vector2(); }
            out.x = pos.x / this._scaler;
            out.y = pos.y / this._scaler;
            return out;
        };
        Object.defineProperty(Egret2DRenderer.prototype, "scaler", {
            /**
             * 从屏幕坐标到当前2D系统的坐标的缩放系数
             */
            get: function () {
                return this._scaler;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *
         */
        Egret2DRenderer.prototype.update = function (deltaTime, w, h) {
            this._order = -1;
            var stage2d = this.stage;
            if (this._stageWidth !== w || this._stageHeight !== h || this.screenAdapter.$dirty) {
                var result = { w: 0, h: 0, s: 0 };
                this.screenAdapter.calculateScaler(w, h, result);
                this.screenAdapter.$dirty = false;
                // this._scaler = this.root.scaleX = this.root.scaleY = result.s;
                stage2d.$displayList["offsetMatrix"].a = result.s;
                stage2d.$displayList["offsetMatrix"].d = result.s;
                this._scaler = result.s;
                var stageWidth = result.w;
                var stageHeight = result.h;
                stage2d.$stageWidth = stageWidth;
                stage2d.$stageHeight = stageHeight;
                // stage.$displayList.setClipRect(screenWidth, screenHeight);
                stage2d.pushResize(w, h);
                stage2d.dispatchEventWith(egret.Event.RESIZE);
                this._stageWidth = w;
                this._stageHeight = h;
            }
            // // clear catched events
            // this._catchedEvent = {};
        };
        /**
         * @internal
         */
        Egret2DRenderer.prototype._draw = function () {
            this._renderer.beforeRender();
            this.stage.drawToSurface();
        };
        return Egret2DRenderer;
    }(paper.BaseRenderer));
    egret3d.Egret2DRenderer = Egret2DRenderer;
    __reflect(Egret2DRenderer.prototype, "egret3d.Egret2DRenderer");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * Egret 传统 2D 渲染系统。
     */
    var Egret2DRendererSystem = (function (_super) {
        __extends(Egret2DRendererSystem, _super);
        function Egret2DRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * TODO
             * @internal
             */
            _this.webInput = egret.Capabilities.runtimeType === egret.RuntimeType.WEB ? new egret["web"].HTMLInput() : null;
            _this._entitiesDirty = false;
            _this._sortedEntities = [];
            return _this;
        }
        Egret2DRendererSystem.prototype._onSortEntities = function (a, b) {
            return b.getComponent(egret3d.Egret2DRenderer)._order - a.getComponent(egret3d.Egret2DRenderer)._order;
        };
        Egret2DRendererSystem.prototype._sortEntities = function () {
            if (this._entitiesDirty) {
                this._sortedEntities.sort(this._onSortEntities);
                this._entitiesDirty = false;
            }
            return this._sortedEntities;
        };
        Egret2DRendererSystem.prototype._onTouchStart = function (pointer, signal) {
            if (paper.Application.playerMode !== 1 /* Player */) {
                return;
            }
            var event = pointer.event;
            for (var _i = 0, _a = this._sortEntities(); _i < _a.length; _i++) {
                var entity = _a[_i];
                var renderer = entity.getComponent(egret3d.Egret2DRenderer);
                var scaler = renderer.scaler;
                if (renderer.stage.$onTouchBegin(pointer.position.x / scaler, pointer.position.y / scaler, event.pointerId)) {
                    break;
                }
            }
        };
        Egret2DRendererSystem.prototype._onTouchMove = function (pointer, signal) {
            if (paper.Application.playerMode !== 1 /* Player */) {
                return;
            }
            var event = pointer.event;
            for (var _i = 0, _a = this._sortEntities(); _i < _a.length; _i++) {
                var entity = _a[_i];
                var renderer = entity.getComponent(egret3d.Egret2DRenderer);
                var scaler = renderer.scaler;
                if (renderer.stage.$onTouchMove(pointer.position.x / scaler, pointer.position.y / scaler, event.pointerId)) {
                    break;
                }
            }
        };
        Egret2DRendererSystem.prototype._onTouchEnd = function (pointer, signal) {
            if (paper.Application.playerMode !== 1 /* Player */) {
                return;
            }
            var event = pointer.event;
            for (var _i = 0, _a = this._sortEntities(); _i < _a.length; _i++) {
                var entity = _a[_i];
                var renderer = entity.getComponent(egret3d.Egret2DRenderer);
                var scaler = renderer.scaler;
                if (renderer.stage.$onTouchEnd(pointer.position.x / scaler, pointer.position.y / scaler, event.pointerId)) {
                    break;
                }
            }
        };
        Egret2DRendererSystem.prototype.getMatchers = function () {
            return [
                paper.Matcher.create(egret3d.Egret2DRenderer),
            ];
        };
        Egret2DRendererSystem.prototype.onAwake = function (config) {
            Egret2DRendererSystem.canvas = config.canvas;
            Egret2DRendererSystem.webgl = config.webgl;
            var webgl = Egret2DRendererSystem.webgl;
            if (!webgl) {
                return;
            }
            var webInput = this.webInput;
            if (webInput) {
                var canvas = Egret2DRendererSystem.canvas;
                webInput._initStageDelegateDiv(canvas.parentNode, canvas);
                webInput.$updateSize();
            }
        };
        Egret2DRendererSystem.prototype.onEnable = function () {
            egret3d.inputCollecter.onPointerDown.add(this._onTouchStart, this);
            egret3d.inputCollecter.onPointerCancel.add(this._onTouchEnd, this);
            egret3d.inputCollecter.onPointerUp.add(this._onTouchEnd, this);
            egret3d.inputCollecter.onPointerMove.add(this._onTouchMove, this);
        };
        Egret2DRendererSystem.prototype.onDisable = function () {
            egret3d.inputCollecter.onPointerDown.remove(this._onTouchStart, this);
            egret3d.inputCollecter.onPointerCancel.remove(this._onTouchEnd, this);
            egret3d.inputCollecter.onPointerUp.remove(this._onTouchEnd, this);
            egret3d.inputCollecter.onPointerMove.remove(this._onTouchMove, this);
        };
        Egret2DRendererSystem.prototype.onEntityAdded = function (entity) {
            this._entitiesDirty = true;
            this._sortedEntities.push(entity);
        };
        Egret2DRendererSystem.prototype.onEntityRemoved = function (entity) {
            var index = this._sortedEntities.indexOf(entity);
            if (index >= 0) {
                this._sortedEntities.splice(index, 1);
            }
        };
        Egret2DRendererSystem.prototype.onFrame = function (deltaTime) {
            var _a = egret3d.stage.viewport, w = _a.w, h = _a.h;
            for (var _i = 0, _b = this.groups[0].entities; _i < _b.length; _i++) {
                var entity = _b[_i];
                entity.getComponent(egret3d.Egret2DRenderer).update(deltaTime, w, h);
            }
        };
        /**
         * @deprecated
         */
        Egret2DRendererSystem.canvas = null;
        /**
         * @deprecated
         */
        Egret2DRendererSystem.webgl = null;
        return Egret2DRendererSystem;
    }(paper.BaseSystem));
    egret3d.Egret2DRendererSystem = Egret2DRendererSystem;
    __reflect(Egret2DRendererSystem.prototype, "egret3d.Egret2DRendererSystem");
})(egret3d || (egret3d = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-present, Egret Technology.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var egret;
(function (egret) {
    var web;
    (function (web) {
        /**
         * @internal
         */
        var Renderer = (function () {
            function Renderer(context) {
                this.context = context;
                var egretWebGLRenderContext = this.egretWebGLRenderContext = egret.web.WebGLRenderContext.getInstance(0, 0);
                egretWebGLRenderContext.setContext(context);
                this.drawCmdManager = egretWebGLRenderContext.drawCmdManager;
                this.vao = egretWebGLRenderContext.vao;
                // egretWebGLRenderContext.drawFunc = this.$drawWebGL.bind(this);
                egretWebGLRenderContext.$drawWebGL = this.$drawWebGL.bind(this);
                egret.sys.RenderBuffer = egret.web.WebGLRenderBuffer;
                egret.sys.systemRenderer = new egret.web.WebGLRenderer();
                egret.sys.canvasRenderer = new egret.CanvasRenderer();
                egret.sys.customHitTestBuffer = new egret.web.WebGLRenderBuffer(3, 3);
                egret.sys.canvasHitTestBuffer = new egret.web.CanvasRenderBuffer(3, 3);
                egret.Capabilities['$renderMode'] = "webgl";
                this.vertexBuffer = context.createBuffer();
                this.indexBuffer = context.createBuffer();
                // app.addEventListener("beforeRender", function() {
                //     egret.ticker.update();
                // }, this);
            }
            Renderer.getInstance = function (context) {
                if (!this._instance) {
                    this._instance = new Renderer(context);
                }
                return this._instance;
            };
            Renderer.prototype.beforeRender = function () {
                var gl = this.context;
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                gl.disable(gl.DEPTH_TEST);
                gl.disable(gl.CULL_FACE);
                gl.enable(gl.BLEND);
                gl.disable(gl.STENCIL_TEST);
                gl.colorMask(true, true, true, true);
                this.setBlendMode("source-over");
                // 目前只使用0号材质单元，默认开启
                gl.activeTexture(gl.TEXTURE0);
                this.currentProgram = null;
            };
            Renderer.prototype.$drawWebGL = function () {
                if (this.drawCmdManager.drawDataLen == 0) {
                    return;
                }
                this.uploadVerticesArray(this.vao.getVertices());
                // 有mesh，则使用indicesForMesh
                if (this.vao.hasMesh) {
                    this.uploadIndicesArray(this.vao.getMeshIndices());
                }
                var length = this.drawCmdManager.drawDataLen;
                var offset = 0;
                for (var i = 0; i < length; i++) {
                    var data = this.drawCmdManager.drawData[i];
                    if (!data) {
                        continue;
                    }
                    offset = this.drawData(data, offset);
                    // 计算draw call
                    if (data.type == 6 /* ACT_BUFFER */) {
                        this._activatedBuffer = data.buffer;
                        this.egretWebGLRenderContext.activatedBuffer = data.buffer;
                    }
                    if (data.type == 0 /* TEXTURE */ || data.type == 1 /* PUSH_MASK */ || data.type == 2 /* POP_MASK */) {
                        if (this._activatedBuffer && this._activatedBuffer.$computeDrawCall) {
                            this._activatedBuffer.$drawCalls++;
                        }
                    }
                }
                // 切换回默认indices
                if (this.vao.hasMesh) {
                    this.uploadIndicesArray(this.vao.getIndices());
                }
                // 清空数据
                this.drawCmdManager.clear();
                this.vao.clear();
            };
            /**
             * 执行绘制命令
             */
            Renderer.prototype.drawData = function (data, offset) {
                if (!data) {
                    return;
                }
                var gl = this.context;
                var program;
                var filter = data.filter;
                switch (data.type) {
                    case 0 /* TEXTURE */:
                        if (filter) {
                            if (filter.type === "custom") {
                                program = web.EgretWebGLProgram.getProgram(gl, filter.$vertexSrc, filter.$fragmentSrc, filter.$shaderKey);
                            }
                            else if (filter.type === "colorTransform") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.colorTransform_frag, "colorTransform");
                            }
                            else if (filter.type === "blurX") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.blur_frag, "blur");
                            }
                            else if (filter.type === "blurY") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.blur_frag, "blur");
                            }
                            else {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.glow_frag, "glow");
                            }
                        }
                        else {
                            program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.texture_frag, "texture");
                        }
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data);
                        offset += this.drawTextureElements(data, offset);
                        break;
                    case 1 /* PUSH_MASK */:
                        program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.primitive_frag, "primitive");
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data);
                        offset += this.drawPushMaskElements(data, offset);
                        break;
                    case 2 /* POP_MASK */:
                        program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.primitive_frag, "primitive");
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data);
                        offset += this.drawPopMaskElements(data, offset);
                        break;
                    case 3 /* BLEND */:
                        this.setBlendMode(data.value);
                        break;
                    case 4 /* RESIZE_TARGET */:
                        data.buffer.rootRenderTarget.resize(data.width, data.height);
                        this.onResize(data.width, data.height);
                        break;
                    case 5 /* CLEAR_COLOR */:
                        if (this._activatedBuffer) {
                            var target = this._activatedBuffer.rootRenderTarget;
                            if (target.width != 0 || target.height != 0) {
                                target.clear(true);
                            }
                        }
                        break;
                    case 6 /* ACT_BUFFER */:
                        this.activateBuffer(data.buffer, data.width, data.height);
                        break;
                    case 7 /* ENABLE_SCISSOR */:
                        var buffer = this._activatedBuffer;
                        if (buffer) {
                            if (buffer.rootRenderTarget) {
                                buffer.rootRenderTarget.enabledStencil();
                            }
                            buffer.enableScissor(data.x, data.y, data.width, data.height);
                        }
                        break;
                    case 8 /* DISABLE_SCISSOR */:
                        buffer = this._activatedBuffer;
                        if (buffer) {
                            buffer.disableScissor();
                        }
                        break;
                    default:
                        break;
                }
                return offset;
            };
            Renderer.prototype.activeProgram = function (gl, program) {
                if (program != this.currentProgram) {
                    gl.useProgram(program.id);
                    // 目前所有attribute buffer的绑定方法都是一致的
                    var attribute = program.attributes;
                    for (var key in attribute) {
                        if (key === "aVertexPosition") {
                            gl.vertexAttribPointer(attribute["aVertexPosition"].location, 2, gl.FLOAT, false, 4 * 4, 0);
                            gl.enableVertexAttribArray(attribute["aVertexPosition"].location);
                        }
                        else if (key === "aTextureCoord") {
                            gl.vertexAttribPointer(attribute["aTextureCoord"].location, 2, gl.UNSIGNED_SHORT, true, 4 * 4, 2 * 4);
                            gl.enableVertexAttribArray(attribute["aTextureCoord"].location);
                        }
                        else if (key === "aColor") {
                            gl.vertexAttribPointer(attribute["aColor"].location, 1, gl.FLOAT, false, 4 * 4, 3 * 4);
                            gl.enableVertexAttribArray(attribute["aColor"].location);
                        }
                        else if (key === "aParticlePosition") {
                            gl.vertexAttribPointer(attribute["aParticlePosition"].location, 2, gl.FLOAT, false, 22 * 4, 0);
                            gl.enableVertexAttribArray(attribute["aParticlePosition"].location);
                        }
                        else if (key === "aParticleTextureCoord") {
                            gl.vertexAttribPointer(attribute["aParticleTextureCoord"].location, 2, gl.FLOAT, false, 22 * 4, 2 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleTextureCoord"].location);
                        }
                        else if (key === "aParticleScale") {
                            gl.vertexAttribPointer(attribute["aParticleScale"].location, 2, gl.FLOAT, false, 22 * 4, 4 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleScale"].location);
                        }
                        else if (key === "aParticleRotation") {
                            gl.vertexAttribPointer(attribute["aParticleRotation"].location, 2, gl.FLOAT, false, 22 * 4, 6 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleRotation"].location);
                        }
                        else if (key === "aParticleRed") {
                            gl.vertexAttribPointer(attribute["aParticleRed"].location, 2, gl.FLOAT, false, 22 * 4, 8 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleRed"].location);
                        }
                        else if (key === "aParticleGreen") {
                            gl.vertexAttribPointer(attribute["aParticleGreen"].location, 2, gl.FLOAT, false, 22 * 4, 10 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleGreen"].location);
                        }
                        else if (key === "aParticleBlue") {
                            gl.vertexAttribPointer(attribute["aParticleBlue"].location, 2, gl.FLOAT, false, 22 * 4, 12 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleBlue"].location);
                        }
                        else if (key === "aParticleAlpha") {
                            gl.vertexAttribPointer(attribute["aParticleAlpha"].location, 2, gl.FLOAT, false, 22 * 4, 14 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleAlpha"].location);
                        }
                        else if (key === "aParticleEmitRotation") {
                            gl.vertexAttribPointer(attribute["aParticleEmitRotation"].location, 2, gl.FLOAT, false, 22 * 4, 16 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleEmitRotation"].location);
                        }
                        else if (key === "aParticleEmitRadius") {
                            gl.vertexAttribPointer(attribute["aParticleEmitRadius"].location, 2, gl.FLOAT, false, 22 * 4, 18 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleEmitRadius"].location);
                        }
                        else if (key === "aParticleTime") {
                            gl.vertexAttribPointer(attribute["aParticleTime"].location, 2, gl.FLOAT, false, 22 * 4, 20 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleTime"].location);
                        }
                        //===== particle end =====
                    }
                    this.currentProgram = program;
                }
            };
            Renderer.prototype.syncUniforms = function (program, filter, data) {
                var uniforms = program.uniforms;
                for (var key in uniforms) {
                    if (key === "projectionVector") {
                        uniforms[key].setValue({ x: this.projectionX, y: this.projectionY });
                    }
                    else if (key === "uTextureSize") {
                        uniforms[key].setValue({ x: data.textureWidth, y: data.textureHeight });
                    }
                    else if (key === "uSampler") {
                    }
                    else if (key === "uGlobalMatrix") {
                        uniforms[key].setValue([data.a, data.c, data.tx, data.b, data.d, data.ty, 0, 0, 1]);
                    }
                    else if (key === "uGlobalAlpha") {
                        uniforms[key].setValue(data.alpha);
                    }
                    else {
                        var value = filter.$uniforms[key];
                        if (value !== undefined) {
                            uniforms[key].setValue(value);
                        }
                        else {
                            // egret.warn("filter custom: uniform " + key + " not defined!");
                        }
                    }
                }
            };
            /**
             * 画texture
             **/
            Renderer.prototype.drawTextureElements = function (data, offset) {
                var gl = this.context;
                if (data.texture.isCanvas) {
                    gl.wxBindCanvasTexture(gl.TEXTURE_2D, data.texture);
                }
                else {
                    gl.bindTexture(gl.TEXTURE_2D, data.texture);
                }
                var size = data.count * 3;
                gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                egret3d.drawCallCollecter.drawCallCount++;
                return size;
            };
            /**
             * 启用RenderBuffer
             */
            Renderer.prototype.activateBuffer = function (buffer, width, height) {
                buffer.rootRenderTarget.activate();
                if (!this.bindIndices) {
                    this.uploadIndicesArray(this.vao.getIndices());
                }
                buffer.restoreStencil();
                buffer.restoreScissor();
                this.onResize(width, height);
            };
            Renderer.prototype.onResize = function (width, height) {
                this.projectionX = width / 2;
                this.projectionY = -height / 2;
                if (this.context) {
                    this.context.viewport(0, 0, width, height);
                }
            };
            /**
             * 上传顶点数据
             */
            Renderer.prototype.uploadVerticesArray = function (array) {
                var gl = this.context;
                gl.bufferData(gl.ARRAY_BUFFER, array, gl.STREAM_DRAW);
            };
            /**
             * 上传索引数据
             */
            Renderer.prototype.uploadIndicesArray = function (array) {
                var gl = this.context;
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, gl.STATIC_DRAW);
                this.bindIndices = true;
            };
            /**
             * 画push mask
             **/
            Renderer.prototype.drawPushMaskElements = function (data, offset) {
                var gl = this.context;
                var size = data.count * 3;
                var buffer = this._activatedBuffer;
                if (buffer) {
                    if (buffer.rootRenderTarget) {
                        buffer.rootRenderTarget.enabledStencil();
                    }
                    if (buffer.stencilHandleCount == 0) {
                        buffer.enableStencil();
                        gl.clear(gl.STENCIL_BUFFER_BIT); // clear
                    }
                    var level = buffer.stencilHandleCount;
                    buffer.stencilHandleCount++;
                    gl.colorMask(false, false, false, false);
                    gl.stencilFunc(gl.EQUAL, level, 0xFF);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
                    // gl.bindTexture(gl.TEXTURE_2D, null);
                    gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                    egret3d.drawCallCollecter.drawCallCount++;
                    gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);
                    gl.colorMask(true, true, true, true);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                }
                return size;
            };
            /**
             * 画pop mask
             **/
            Renderer.prototype.drawPopMaskElements = function (data, offset) {
                var gl = this.context;
                var size = data.count * 3;
                var buffer = this._activatedBuffer;
                if (buffer) {
                    buffer.stencilHandleCount--;
                    if (buffer.stencilHandleCount == 0) {
                        buffer.disableStencil(); // skip this draw
                    }
                    else {
                        var level = buffer.stencilHandleCount;
                        gl.colorMask(false, false, false, false);
                        gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
                        // gl.bindTexture(gl.TEXTURE_2D, null);
                        gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                        egret3d.drawCallCollecter.drawCallCount++;
                        gl.stencilFunc(gl.EQUAL, level, 0xFF);
                        gl.colorMask(true, true, true, true);
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                    }
                }
                return size;
            };
            /**
             * 设置混色
             */
            Renderer.prototype.setBlendMode = function (value) {
                var gl = this.context;
                var blendModeWebGL = Renderer.blendModesForGL[value];
                if (blendModeWebGL) {
                    gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
                }
            };
            Renderer.initBlendMode = function () {
                Renderer.blendModesForGL = {};
                Renderer.blendModesForGL["source-over"] = [1, 771];
                Renderer.blendModesForGL["lighter"] = [1, 1];
                Renderer.blendModesForGL["lighter-in"] = [770, 771];
                Renderer.blendModesForGL["destination-out"] = [0, 771];
                Renderer.blendModesForGL["destination-in"] = [0, 770];
            };
            Renderer.blendModesForGL = null;
            return Renderer;
        }());
        web.Renderer = Renderer;
        __reflect(Renderer.prototype, "egret.web.Renderer");
        Renderer.initBlendMode();
    })(web = egret.web || (egret.web = {}));
})(egret || (egret = {}));
var egret3d;
(function (egret3d) {
    /**
     * ConstantAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 恒定像素的适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var ConstantAdapter = (function () {
        function ConstantAdapter() {
            this.$dirty = true;
            this._scaleFactor = 1;
        }
        Object.defineProperty(ConstantAdapter.prototype, "scaleFactor", {
            /**
             * scaleFactor
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 设置缩放值
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            set: function (value) {
                this._scaleFactor = value;
                this.$dirty = true;
            },
            enumerable: true,
            configurable: true
        });
        ConstantAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var scaler = this._scaleFactor;
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return ConstantAdapter;
    }());
    egret3d.ConstantAdapter = ConstantAdapter;
    __reflect(ConstantAdapter.prototype, "egret3d.ConstantAdapter", ["egret3d.IScreenAdapter"]);
    /**
     * ConstantAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 拉伸扩展的适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var ExpandAdapter = (function () {
        function ExpandAdapter() {
            this.$dirty = true;
            this._resolution = new egret3d.Vector2(640, 1136);
        }
        /**
         * setResolution
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 设置分辨率
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        ExpandAdapter.prototype.setResolution = function (width, height) {
            this._resolution.x = width;
            this._resolution.y = height;
            this.$dirty = true;
        };
        ExpandAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var canvasRate = canvasWidth / canvasHeight;
            var resolutionRate = this._resolution.x / this._resolution.y;
            var scaler = 1;
            if (canvasRate > resolutionRate) {
                scaler = canvasHeight / this._resolution.y;
            }
            else {
                scaler = canvasWidth / this._resolution.x;
            }
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return ExpandAdapter;
    }());
    egret3d.ExpandAdapter = ExpandAdapter;
    __reflect(ExpandAdapter.prototype, "egret3d.ExpandAdapter", ["egret3d.IScreenAdapter"]);
    /**
     * ShrinkAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 缩放的适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var ShrinkAdapter = (function () {
        function ShrinkAdapter() {
            this.$dirty = true;
            this._resolution = new egret3d.Vector2(640, 1136);
        }
        /**
         * setResolution
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 设置分辨率
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        ShrinkAdapter.prototype.setResolution = function (width, height) {
            this._resolution.x = width;
            this._resolution.y = height;
            this.$dirty = true;
        };
        ShrinkAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var canvasRate = canvasWidth / canvasHeight;
            var resolutionRate = this._resolution.x / this._resolution.y;
            var scaler = 1;
            if (canvasRate > resolutionRate) {
                scaler = canvasWidth / this._resolution.x;
            }
            else {
                scaler = canvasHeight / this._resolution.y;
            }
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return ShrinkAdapter;
    }());
    egret3d.ShrinkAdapter = ShrinkAdapter;
    __reflect(ShrinkAdapter.prototype, "egret3d.ShrinkAdapter", ["egret3d.IScreenAdapter"]);
    /**
     * MatchWidthOrHeightAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 适应宽高适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var MatchWidthOrHeightAdapter = (function () {
        function MatchWidthOrHeightAdapter() {
            this.$dirty = true;
            this._resolution = new egret3d.Vector2(640, 1136);
            this._matchFactor = 1.0; // width : height
        }
        /**
         * setResolution
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 设置分辨率
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MatchWidthOrHeightAdapter.prototype.setResolution = function (width, height) {
            this._resolution.x = width;
            this._resolution.y = height;
            this.$dirty = true;
        };
        Object.defineProperty(MatchWidthOrHeightAdapter.prototype, "matchFactor", {
            /**
             * matchFactor
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 设置匹配系数，0-1之间，越小越倾向以宽度适配，越大越倾向以高度适配。
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            set: function (value) {
                this._matchFactor = value;
                this.$dirty = true;
            },
            enumerable: true,
            configurable: true
        });
        MatchWidthOrHeightAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var scaler1 = canvasWidth / this._resolution.x;
            var scaler2 = canvasHeight / this._resolution.y;
            var scaler = scaler1 + (scaler2 - scaler1) * this._matchFactor;
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return MatchWidthOrHeightAdapter;
    }());
    egret3d.MatchWidthOrHeightAdapter = MatchWidthOrHeightAdapter;
    __reflect(MatchWidthOrHeightAdapter.prototype, "egret3d.MatchWidthOrHeightAdapter", ["egret3d.IScreenAdapter"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 动画组件。
     */
    var Animation = (function (_super) {
        __extends(Animation, _super);
        function Animation() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.autoPlay = false;
            /**
             * 是否将动画数据中根节点的变换动画应用到该组件实体的变换组件上。
             */
            _this.applyRootMotion = false;
            /**
             * 动画速度。
             */
            _this.timeScale = 1.0;
            _this._animations = [];
            /**
             * @internal
             */
            _this._fadeStates = [];
            /**
             * @internal
             */
            _this._binders = {};
            _this._animationController = null;
            _this._lastAnimationLayer = null;
            return _this;
        }
        /**
         * @internal
         */
        Animation.prototype._getBinder = function (name, type) {
            var blendLayers = this._binders;
            name += "/" + type;
            if (!(name in blendLayers)) {
                blendLayers[name] = egret3d.AnimationBinder.create();
            }
            return blendLayers[name];
        };
        Animation.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            for (var _i = 0, _a = this._animations; _i < _a.length; _i++) {
                var animation = _a[_i];
                if (animation) {
                    animation.release();
                }
            }
            var fadeStatess = this._fadeStates;
            for (var _b = 0, fadeStatess_1 = fadeStatess; _b < fadeStatess_1.length; _b++) {
                var fadeStates = fadeStatess_1[_b];
                for (var _c = 0, fadeStates_1 = fadeStates; _c < fadeStates_1.length; _c++) {
                    var fadeState = fadeStates_1[_c];
                    fadeState.release();
                }
            }
            var binders = this._binders;
            for (var k in binders) {
                binders[k].release();
                delete binders[k];
            }
            if (this._animationController) {
                this._animationController.release();
            }
            this._animations.length = 0;
            this._fadeStates.length = 0;
            // this._binders;
            this._animationController = null;
            this._lastAnimationLayer = null;
        };
        /**
         * 融合播放一个指定的动画。
         * @param animationClipName 动画剪辑的名称。
         * @param fadeTime 融合的时间。
         * @param playTimes 播放次数。（-1：采用动画数据配置，0：循环播放，N：循环播放 N 次）
         * @param layerIndex 动画层索引。
         * @param layerAdditive 动画层混合方式是否为叠加。
         */
        Animation.prototype.fadeIn = function (animationClipName, fadeTime, playTimes, layerIndex, layerAdditive) {
            if (playTimes === void 0) { playTimes = -1; }
            if (layerIndex === void 0) { layerIndex = 0; }
            if (layerAdditive === void 0) { layerAdditive = false; }
            //
            if (!this._animationController) {
                this._animationController = egret3d.AnimationController.create("Default" /* Default */).retain();
            }
            var animationController = this._animationController;
            var animationLayers = animationController.layers;
            if (layerIndex > animationLayers.length) {
                console.warn("The animation layers must be continuous.");
                return null;
            }
            var animationLayer = animationController.getOrAddLayer(layerIndex);
            animationLayer.additive = layerAdditive;
            // const animationNode: AnimationNode = {
            //     asset: "",
            //     clip: "",
            //     timeScale: 1.0,
            // }; TODO
            // 
            var animationAsset = null;
            var animationClip = null;
            var animationTree = null;
            for (var _i = 0, _a = this._animations; _i < _a.length; _i++) {
                animationAsset = _a[_i];
                if (!animationAsset) {
                    continue;
                }
                animationClip = animationAsset.getAnimationClip(animationClipName);
                if (animationClip !== null) {
                    break;
                }
            }
            if (!animationAsset || !animationClip) {
                for (var _b = 0, _c = animationLayer.machine.nodes; _b < _c.length; _b++) {
                    var node = _c[_b];
                    if (node.name === animationClipName) {
                        animationTree = node;
                    }
                }
                if (!animationTree) {
                    console.warn("There is no animation clip named \"" + animationClipName + "\" in the \"" + this.gameObject.path + "\" gameObject.", animationClipName, this.gameObject.path);
                    return null;
                }
            }
            //
            var fadeStatess = this._fadeStates;
            if (layerIndex >= fadeStatess.length) {
                fadeStatess[layerIndex] = [];
            }
            for (var _d = 0, _e = fadeStatess[layerIndex]; _d < _e.length; _d++) {
                var fadeStates = _e[_d];
                fadeStates.fadeOut(fadeTime);
            }
            //
            var lastFadeState = egret3d.AnimationFadeState.create();
            lastFadeState.totalTime = fadeTime;
            fadeStatess[layerIndex].push(lastFadeState);
            if (animationTree) {
                var animationTreeState = egret3d.AnimationTreeState.create();
                animationTreeState.animationLayer = animationLayer;
                animationTreeState.animationNode = animationTree;
                lastFadeState.states.push(animationTreeState);
                for (var _f = 0, _g = animationTree.nodes; _f < _g.length; _f++) {
                    var animationNode = _g[_f];
                    animationAsset = paper.Asset.find(animationNode.asset);
                    if (animationAsset) {
                        animationClip = animationAsset.getAnimationClip(animationNode.name);
                        if (animationClip) {
                            var animationState_1 = egret3d.AnimationState.create();
                            animationState_1._parent = animationTreeState;
                            animationState_1._initialize(this, animationLayer, null, animationAsset, animationClip);
                            animationState_1.playTimes = playTimes < 0 ? (animationClip.playTimes || 0) : playTimes;
                            lastFadeState.states.push(animationState_1);
                        }
                    }
                }
                //
                this._lastAnimationLayer = animationLayer;
                return null;
            }
            //
            var animationState = egret3d.AnimationState.create();
            animationState._initialize(this, animationLayer, null, animationAsset, animationClip);
            animationState.playTimes = playTimes < 0 ? (animationClip.playTimes || 0) : playTimes;
            lastFadeState.states.push(animationState);
            //
            this._lastAnimationLayer = animationLayer;
            return animationState;
        };
        /**
         * 播放一个指定的动画。
         * @param animationClipNameOrNames
         * @param playTimes 播放次数。（-1：采用动画数据配置，0：循环播放，N：循环播放 N 次）
         */
        Animation.prototype.play = function (animationClipNameOrNames, playTimes) {
            if (animationClipNameOrNames === void 0) { animationClipNameOrNames = null; }
            if (playTimes === void 0) { playTimes = -1; }
            if (!this._animationController) {
                this._animationController = egret3d.AnimationController.create("Default" /* Default */).retain();
            }
            var animationController = this._animationController;
            var animationLayer = animationController.getOrAddLayer(0);
            //
            if (!animationLayer._clipNames) {
                animationLayer._clipNames = [];
            }
            var clipNames = animationLayer._clipNames;
            clipNames.length = 0;
            if (Array.isArray(animationClipNameOrNames)) {
                if (animationClipNameOrNames.length > 0) {
                    for (var _i = 0, animationClipNameOrNames_1 = animationClipNameOrNames; _i < animationClipNameOrNames_1.length; _i++) {
                        var animationName = animationClipNameOrNames_1[_i];
                        clipNames.push(animationName);
                    }
                    animationClipNameOrNames = clipNames.shift();
                }
                else {
                    animationClipNameOrNames = "";
                }
            }
            else if (!animationClipNameOrNames) {
                animationClipNameOrNames = "";
            }
            var animationState = null;
            if (animationClipNameOrNames) {
                animationState = this.fadeIn(animationClipNameOrNames, 0.0, playTimes);
            }
            else {
                var lastAnimationState = this.lastAnimationState;
                if (lastAnimationState) {
                    if (!lastAnimationState.isPlaying && !lastAnimationState.isCompleted) {
                        animationState = lastAnimationState;
                        lastAnimationState.play();
                    }
                    else {
                        animationState = this.fadeIn(lastAnimationState.animationClip.name, 0.0, playTimes);
                    }
                }
                else {
                    var animations = this._animations;
                    if (animations.length > 0) {
                        var defaultAnimationAsset = animations[0];
                        if (defaultAnimationAsset) {
                            animationClipNameOrNames = defaultAnimationAsset.config.animations[0].extensions.paper.clips[0].name;
                            animationState = this.fadeIn(animationClipNameOrNames, 0.0, playTimes);
                        }
                    }
                }
            }
            return animationState;
        };
        /**
         *
         */
        Animation.prototype.stop = function (animationName, layerIndex) {
            if (animationName === void 0) { animationName = null; }
            if (layerIndex === void 0) { layerIndex = 0; }
            if (animationName) {
                var animationState = this.getState(animationName, layerIndex);
                if (animationState && animationState.constructor === egret3d.AnimationState) {
                    animationState.stop();
                }
            }
            else {
                var fadeStatess = this._fadeStates;
                for (var _i = 0, fadeStatess_2 = fadeStatess; _i < fadeStatess_2.length; _i++) {
                    var fadeStates = fadeStatess_2[_i];
                    for (var _a = 0, fadeStates_2 = fadeStates; _a < fadeStates_2.length; _a++) {
                        var fadeState = fadeStates_2[_a];
                        for (var _b = 0, _c = fadeState.states; _b < _c.length; _b++) {
                            var animationState = _c[_b];
                            if (animationState.constructor === egret3d.AnimationState) {
                                animationState.stop();
                            }
                        }
                    }
                }
            }
        };
        /**
         *
         */
        Animation.prototype.getState = function (animationName, layerIndex) {
            if (layerIndex === void 0) { layerIndex = 0; }
            var fadeStatess = this._fadeStates;
            if (fadeStatess.length > layerIndex) {
                var fadeStates = fadeStatess[layerIndex];
                var i = fadeStates.length;
                while (i--) {
                    var fadeState = fadeStates[i];
                    for (var _i = 0, _a = fadeState.states; _i < _a.length; _i++) {
                        var animationState = _a[_i];
                        if (animationState.name === animationName) {
                            return animationState;
                        }
                    }
                }
            }
            return null;
        };
        /**
         *
         */
        Animation.prototype.hasAnimation = function (animationClipName) {
            for (var _i = 0, _a = this._animations; _i < _a.length; _i++) {
                var animationAsset = _a[_i];
                if (!animationAsset) {
                    continue;
                }
                var animationClip = animationAsset.getAnimationClip(animationClipName);
                if (animationClip) {
                    return true;
                }
            }
            return false;
        };
        Object.defineProperty(Animation.prototype, "lastAnimationnName", {
            /**
             *
             */
            get: function () {
                var lastAnimationState = this.lastAnimationState;
                return lastAnimationState ? lastAnimationState.name : "";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "animations", {
            /**
             * 动画数据列表。
             */
            get: function () {
                return this._animations;
            },
            set: function (value) {
                var animations = this._animations;
                for (var _i = 0, animations_1 = animations; _i < animations_1.length; _i++) {
                    var animation = animations_1[_i];
                    if (animation) {
                        animation.release();
                    }
                }
                if (value !== animations) {
                    animations.length = 0;
                    for (var _a = 0, value_4 = value; _a < value_4.length; _a++) {
                        var animation = value_4[_a];
                        animations.push(animation);
                    }
                }
                for (var _b = 0, animations_2 = animations; _b < animations_2.length; _b++) {
                    var animation = animations_2[_b];
                    if (animation) {
                        animation.retain();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "animationController", {
            /**
             *
             */
            get: function () {
                if (!this._animationController) {
                    this._animationController = egret3d.AnimationController.create("Default" /* Default */).retain();
                }
                return this._animationController;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "lastAnimationState", {
            /**
             *
             */
            get: function () {
                var animationController = this._animationController;
                var lastAnimationLayer = this._lastAnimationLayer;
                if (animationController && lastAnimationLayer) {
                    var layerIndex = animationController.layers.indexOf(lastAnimationLayer);
                    var fadeStatess = this._fadeStates;
                    if (fadeStatess.length > layerIndex) {
                        var fadeStates = fadeStatess[layerIndex];
                        if (fadeStates.length > 0) {
                            var animationStates = fadeStates[fadeStates.length - 1].states;
                            var animationState = animationStates[animationStates.length - 1];
                            if (animationState.constructor === egret3d.AnimationState) {
                                return animationState;
                            }
                        }
                    }
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], Animation.prototype, "autoPlay", void 0);
        __decorate([
            paper.editor.property("CHECKBOX" /* CHECKBOX */),
            paper.serializedField
        ], Animation.prototype, "applyRootMotion", void 0);
        __decorate([
            paper.editor.property("FLOAT" /* FLOAT */)
        ], Animation.prototype, "timeScale", void 0);
        __decorate([
            paper.serializedField("_animations")
        ], Animation.prototype, "animations", null);
        return Animation;
    }(paper.BaseComponent));
    egret3d.Animation = Animation;
    __reflect(Animation.prototype, "egret3d.Animation");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     */
    var AnimationFadeState = (function (_super) {
        __extends(AnimationFadeState, _super);
        function AnimationFadeState() {
            var _this = _super.call(this) || this;
            _this.states = [];
            return _this;
        }
        AnimationFadeState.create = function () {
            var instance;
            if (this._instances.length > 0) {
                instance = this._instances.pop();
                instance._released = false;
            }
            else {
                instance = new AnimationFadeState();
                instance.onClear();
            }
            return instance;
        };
        AnimationFadeState.prototype.onClear = function () {
            for (var _i = 0, _a = this.states; _i < _a.length; _i++) {
                var state = _a[_i];
                state.release();
            }
            this.fadeState = -1;
            this.subFadeState = -1;
            this.progress = 0.0;
            this.time = 0.0;
            this.totalTime = 0.0;
            this.states.length = 0;
        };
        AnimationFadeState.prototype.fadeOut = function (totalTime) {
            if (this.fadeState > 0) {
                if (totalTime > this.totalTime - this.time) {
                    return this;
                }
            }
            else {
                this.fadeState = 1;
                this.subFadeState = -1;
                if (totalTime <= 0.0 || this.progress <= 0.0) {
                    this.progress = 2.220446049250313e-16 /* EPSILON */; // Modify fade progress to different value.
                }
            }
            this.totalTime = this.progress > 2.220446049250313e-16 /* EPSILON */ ? totalTime / this.progress : 0.0;
            this.time = this.totalTime * (1.0 - this.progress);
            return this;
        };
        AnimationFadeState._instances = [];
        return AnimationFadeState;
    }(paper.BaseRelease));
    egret3d.AnimationFadeState = AnimationFadeState;
    __reflect(AnimationFadeState.prototype, "egret3d.AnimationFadeState");
    /**
     *
     */
    var AnimationBaseState = (function (_super) {
        __extends(AnimationBaseState, _super);
        function AnimationBaseState() {
            return _super.call(this) || this;
        }
        AnimationBaseState.prototype.onClear = function () {
            this.weight = 1.0;
            this.animationLayer = null;
            this.animationNode = null;
            this._globalWeight = 0.0;
            this._globalTimeScale = 1.0;
            this._parent = null;
        };
        return AnimationBaseState;
    }(paper.BaseRelease));
    egret3d.AnimationBaseState = AnimationBaseState;
    __reflect(AnimationBaseState.prototype, "egret3d.AnimationBaseState");
    /**
     *
     */
    var AnimationTreeState = (function (_super) {
        __extends(AnimationTreeState, _super);
        function AnimationTreeState() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @internal
         */
        AnimationTreeState.create = function () {
            var instance;
            if (this._instances.length > 0) {
                instance = this._instances.pop();
                instance._released = false;
            }
            else {
                instance = new AnimationTreeState();
                instance.onClear();
            }
            return instance;
        };
        Object.defineProperty(AnimationTreeState.prototype, "name", {
            /**
             *
             */
            get: function () {
                return this.animationNode.name;
            },
            enumerable: true,
            configurable: true
        });
        AnimationTreeState._instances = [];
        return AnimationTreeState;
    }(AnimationBaseState));
    egret3d.AnimationTreeState = AnimationTreeState;
    __reflect(AnimationTreeState.prototype, "egret3d.AnimationTreeState");
    /**
     * 动画状态。
     */
    var AnimationState = (function (_super) {
        __extends(AnimationState, _super);
        function AnimationState() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.channels = [];
            _this._lastRootMotionPosition = null;
            return _this;
        }
        /**
         * @internal
         */
        AnimationState.create = function () {
            var instance;
            if (this._instances.length > 0) {
                instance = this._instances.pop();
                instance._released = false;
            }
            else {
                instance = new AnimationState();
                instance.onClear();
            }
            return instance;
        };
        /**
         * @internal
         */
        AnimationState.prototype._applyRootMotion = function (x, y, z, weight, time, animationChannel) {
            if (!this._animation.applyRootMotion) {
                return;
            }
            if (!this._lastRootMotionPosition) {
                this._lastRootMotionPosition = egret3d.Vector4.create();
            }
            var transform = this._animation.gameObject.transform;
            var lastPosition = this._lastRootMotionPosition;
            if (this._animation.timeScale * this.timeScale > 0.0) {
                if (lastPosition.w > time) {
                    this._lastRootMotionRotation = 0.0;
                    lastPosition.set(0.0, 0.0, 0.0, 0.0);
                }
            }
            else if (lastPosition.w < time) {
                var applyRootMotion = this.animationClip.applyRootMotion || 5 /* XZ */;
                var outputBuffer = animationChannel.outputBuffer;
                var index = outputBuffer.length - 3;
                this._lastRootMotionRotation = 0.0;
                lastPosition.set((applyRootMotion & 1 /* X */) ? outputBuffer[index] : 0.0, (applyRootMotion & 2 /* Y */) ? outputBuffer[index + 1] : 0.0, (applyRootMotion & 4 /* Z */) ? outputBuffer[index + 2] : 0.0, this.animationClip.duration);
            }
            var position = egret3d.helpVector3A.set(x, y, z).subtract(lastPosition)
                .applyMatrix3(transform.localToParentMatrix).multiplyScalar(weight);
            transform.translate(position);
            lastPosition.set(x, y, z, time);
        };
        /**
         * @internal
         */
        AnimationState.prototype._initialize = function (animation, animationLayer, animationNode, animationAsset, animationClip) {
            var assetConfig = animationAsset.config;
            this.animationAsset = animationAsset;
            this.animation = assetConfig.animations[0]; // TODO 动画数据暂不合并。
            this.animationClip = animationClip;
            this.animationLayer = animationLayer;
            this.animationNode = animationNode;
            this._animation = animation;
            if (this.animation.channels) {
                var animationMask = animationLayer.mask;
                var jointNames = animationMask ? animationMask.jointNames : null;
                var rootGameObject = animation.gameObject;
                var children = rootGameObject.transform.getChildren({});
                children["__root__"] = rootGameObject.transform; // 
                for (var _i = 0, _a = this.animation.channels; _i < _a.length; _i++) {
                    var glTFChannel = _a[_i];
                    var nodeIndex = glTFChannel.target.node;
                    var pathName = glTFChannel.target.path;
                    var extension = glTFChannel.extensions ? glTFChannel.extensions.paper : null;
                    if (nodeIndex === undefined) {
                        // const channel = AnimationChannel.create();
                        // channel.components = animation;
                        // this.channels.push(channel);
                        switch (pathName) {
                            default:
                                console.warn("Unknown animation channel.", pathName);
                                break;
                        }
                    }
                    else {
                        var nodeName = this.animationAsset.getNode(nodeIndex).name;
                        if (!(nodeName in children) || (jointNames && jointNames.indexOf(nodeName) < 0)) {
                            continue;
                        }
                        var channel = egret3d.AnimationChannel.create();
                        var transform = children[nodeName];
                        var binder = null;
                        if (Array.isArray(transform)) {
                            transform = transform[0];
                        }
                        if (!extension) {
                            binder = channel.binder = animation._getBinder(nodeName, pathName);
                            binder.target = transform;
                        }
                        channel.glTFChannel = glTFChannel;
                        channel.glTFSampler = this.animation.samplers[glTFChannel.sampler];
                        channel.inputBuffer = this.animationAsset.createTypeArrayFromAccessor(this.animationAsset.getAccessor(channel.glTFSampler.input));
                        channel.outputBuffer = this.animationAsset.createTypeArrayFromAccessor(this.animationAsset.getAccessor(channel.glTFSampler.output));
                        this.channels.push(channel);
                        switch (pathName) {
                            case "translation":
                                channel.updateTarget = channel.onUpdateTranslation;
                                if (binder.bindPose === null) {
                                    binder.bindPose = egret3d.Vector3.create().copy(transform.localPosition);
                                    binder.updateTarget = binder.onUpdateTranslation;
                                }
                                break;
                            case "rotation":
                                channel.updateTarget = channel.onUpdateRotation;
                                if (binder.bindPose === null) {
                                    binder.bindPose = egret3d.Quaternion.create().copy(transform.localRotation);
                                    binder.updateTarget = binder.onUpdateRotation;
                                }
                                if (animationLayer.additive && !binder.quaternions) {
                                    binder.quaternions = [];
                                    binder.quaternionWeights = [];
                                }
                                break;
                            case "scale":
                                channel.updateTarget = channel.onUpdateScale;
                                if (binder.bindPose === null) {
                                    binder.bindPose = egret3d.Vector3.create().copy(transform.localScale);
                                    binder.updateTarget = binder.onUpdateScale;
                                }
                                break;
                            case "weights":
                                // TODO
                                break;
                            case "custom":
                                switch (extension.type) {
                                    case "paper.GameObject":
                                        switch (extension.property) {
                                            case "activeSelf":
                                                channel.binder = transform;
                                                channel.updateTarget = channel.onUpdateActive;
                                                break;
                                        }
                                        break;
                                    default:
                                        var componentClass = egret.getDefinitionByName(extension.type); // TODO 不依赖 getDefinitionByName
                                        if (componentClass) {
                                            var component = transform.gameObject.getComponent(componentClass);
                                            if (component) {
                                                var uri = extension.uri;
                                                var needUpdate = extension.needUpdate;
                                                channel.updateTarget = channel.onUpdateFloat; // TODO
                                                if (uri) {
                                                    var paths = uri.split("/");
                                                    var target = component;
                                                    var updateTarget = null;
                                                    var path = "";
                                                    for (var _b = 0, paths_1 = paths; _b < paths_1.length; _b++) {
                                                        path = paths_1[_b];
                                                        if (!path) {
                                                            continue;
                                                        }
                                                        if (path === "$") {
                                                            updateTarget = target;
                                                        }
                                                        else {
                                                            target = target[path];
                                                        }
                                                    }
                                                    channel.binder = target;
                                                    if (needUpdate !== undefined && needUpdate >= 0) {
                                                        channel.needUpdate = (updateTarget || target).needUpdate;
                                                    }
                                                }
                                                else {
                                                    channel.binder = component;
                                                    if (needUpdate !== undefined && needUpdate >= 0) {
                                                        channel.needUpdate = component.needUpdate; // TODO interface
                                                    }
                                                }
                                            }
                                            else {
                                                console.warn("Can not find component.", extension.type);
                                            }
                                        }
                                        else {
                                            console.warn("Unknown component class.", extension.type);
                                        }
                                }
                                break;
                            default:
                                console.warn("Unknown animation channel.", pathName);
                                break;
                        }
                    }
                }
            }
        };
        AnimationState.prototype.onClear = function () {
            _super.prototype.onClear.call(this);
            for (var _i = 0, _a = this.channels; _i < _a.length; _i++) {
                var channel = _a[_i];
                channel.release();
            }
            if (this._lastRootMotionPosition) {
                this._lastRootMotionPosition.release();
            }
            this.playTimes = 0;
            this.currentPlayTimes = 0;
            this.channels.length = 0;
            this.animationAsset = null;
            this.animation = null;
            this.animationClip = null;
            this._playheadEnabled = true;
            this._playState = -1;
            this._timeScale = 1.0;
            this._time = 0.0;
            this._currentTime = -1.0;
            this._lastRootMotionRotation = 0.0;
            this._lastRootMotionPosition = null;
            this._animation = null;
        };
        /**
         * 继续该动画状态的播放。
         */
        AnimationState.prototype.play = function () {
            this._playheadEnabled = true;
            return this;
        };
        /**
         * 停止该动画状态的播放。
         */
        AnimationState.prototype.stop = function () {
            this._playheadEnabled = false;
            return this;
        };
        Object.defineProperty(AnimationState.prototype, "isPlaying", {
            /**
             * 该动画状态是否正在播放。
             */
            get: function () {
                return this._playheadEnabled && this._playState !== 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "isCompleted", {
            /**
             * 该动画状态是否播放完毕。
             */
            get: function () {
                return this._playState === 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "timeScale", {
            /**
             * 该动画状态的播放速度。
             */
            get: function () {
                return this._timeScale;
            },
            set: function (value) {
                if (value !== value) {
                    value = 0.0;
                }
                this._timeScale = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "totalTime", {
            /**
             * 该动画状态的总播放时间。
             */
            get: function () {
                return this.animationClip.duration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "currentTime", {
            /**
             * 该动画状态的当前播放时间。
             */
            get: function () {
                return this._currentTime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "name", {
            /**
             *
             */
            get: function () {
                return this.animationClip ? this.animationClip.name : "";
            },
            enumerable: true,
            configurable: true
        });
        AnimationState._instances = [];
        return AnimationState;
    }(AnimationBaseState));
    egret3d.AnimationState = AnimationState;
    __reflect(AnimationState.prototype, "egret3d.AnimationState");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     */
    var AnimationBinder = (function (_super) {
        __extends(AnimationBinder, _super);
        function AnimationBinder() {
            return _super.call(this) || this;
        }
        AnimationBinder.create = function () {
            var instance;
            if (this._instances.length > 0) {
                instance = this._instances.pop();
                instance._released = false;
            }
            else {
                instance = new AnimationBinder();
                instance.onClear();
            }
            return instance;
        };
        AnimationBinder.prototype.onClear = function () {
            this.clear();
            if (this.quaternions) {
                for (var _i = 0, _a = this.quaternions; _i < _a.length; _i++) {
                    var quaternion = _a[_i];
                    quaternion.release();
                }
            }
            if (this.bindPose && this.bindPose.release) {
                this.bindPose.release();
            }
            this.target = null;
            this.bindPose = null;
            this.updateTarget = null;
            this.quaternions = null;
            this.quaternionWeights = null;
        };
        AnimationBinder.prototype.clear = function () {
            this.dirty = 0;
            this.weight = 1.0;
            this.totalWeight = 0.0;
            this.layer = null;
            var quaternionWeights = this.quaternionWeights;
            if (quaternionWeights) {
                for (var i = 0, l = quaternionWeights.length; i < l; ++i) {
                    quaternionWeights[i] = 0.0;
                }
            }
        };
        AnimationBinder.prototype.updateBlend = function (animationlayer, animationState) {
            var globalWeight = animationState._globalWeight;
            if (this.dirty > 0) {
                if (animationlayer.additive) {
                    this.dirty++;
                    this.weight = globalWeight;
                    return true;
                }
                else if (this.layer === animationState.animationLayer) {
                    this.dirty++;
                    this.weight = globalWeight;
                    this.totalWeight += this.weight;
                    return true;
                }
                else if (this.totalWeight < 1.0 - 2.220446049250313e-16 /* EPSILON */) {
                    this.dirty++;
                    this.weight = globalWeight * (1.0 - this.totalWeight);
                    this.totalWeight += this.weight;
                    this.layer = animationState.animationLayer;
                    return true;
                }
                return false;
            }
            this.dirty++;
            this.weight = globalWeight;
            this.layer = animationState.animationLayer;
            if (!animationlayer.additive) {
                this.totalWeight += globalWeight;
            }
            return true;
        };
        AnimationBinder.prototype.onUpdateTranslation = function () {
            var transforms = this.target;
            var target = transforms.localPosition;
            if (this.totalWeight < 1.0 - 2.220446049250313e-16 /* EPSILON */) {
                var weight = 1.0 - this.totalWeight;
                var bindPose = this.bindPose;
                if (this.dirty > 0) {
                    target.x += bindPose.x * weight;
                    target.y += bindPose.y * weight;
                    target.z += bindPose.z * weight;
                }
                else {
                    target.x = bindPose.x * weight;
                    target.y = bindPose.y * weight;
                    target.z = bindPose.z * weight;
                }
            }
            target.update();
        };
        AnimationBinder.prototype.onUpdateRotation = function () {
            var transforms = this.target;
            var target = transforms.localRotation;
            var bindPose = this.bindPose;
            var quaternions = this.quaternions;
            if (quaternions) {
                var posed = false;
                var i = quaternions.length;
                while (i--) {
                    var quaternion = quaternions[i];
                    var weight = this.quaternionWeights[i];
                    if (weight === 0.0) {
                        continue;
                    }
                    if (weight < 0.0) {
                        quaternion.lerp(egret3d.Quaternion.IDENTITY, quaternion, -weight);
                        // if (weight !== -1.0) { // TODO
                        //     if (quaternion.w >= 0.0) {
                        //         weight = -weight;
                        //     }
                        //     quaternion.x *= weight;
                        //     quaternion.y *= weight;
                        //     quaternion.z *= weight;
                        //     quaternion.w *= weight;
                        // }
                        if (!posed) {
                            target.x = bindPose.x;
                            target.y = bindPose.y;
                            target.z = bindPose.z;
                            target.w = bindPose.w;
                        }
                        target.multiply(quaternion, target);
                    }
                    else {
                        if (weight !== 1.0) {
                            if (quaternion.dot(target) < 0.0) {
                                weight = -weight;
                            }
                            quaternion.x *= weight;
                            quaternion.y *= weight;
                            quaternion.z *= weight;
                            quaternion.w *= weight;
                        }
                        if (posed) {
                            target.x += quaternion.x;
                            target.y += quaternion.y;
                            target.z += quaternion.z;
                            target.w += quaternion.w;
                        }
                        else {
                            target.x = quaternion.x;
                            target.y = quaternion.y;
                            target.z = quaternion.z;
                            target.w = quaternion.w;
                        }
                    }
                    posed = true;
                }
            }
            if (this.totalWeight < 1.0 - 2.220446049250313e-16 /* EPSILON */) {
                var weight = 1.0 - this.totalWeight;
                if (bindPose.dot(target) < 0.0) {
                    weight = -weight;
                }
                if (this.dirty > 0) {
                    target.x += bindPose.x * weight;
                    target.y += bindPose.y * weight;
                    target.z += bindPose.z * weight;
                    target.w += bindPose.w * weight;
                }
                else {
                    target.x = bindPose.x * weight;
                    target.y = bindPose.y * weight;
                    target.z = bindPose.z * weight;
                    target.w = bindPose.w * weight;
                }
            }
            target.normalize();
            target.update();
        };
        AnimationBinder.prototype.onUpdateScale = function () {
            var transforms = this.target;
            var target = transforms.localScale;
            if (this.totalWeight < 1.0 - 2.220446049250313e-16 /* EPSILON */) {
                var weight = 1.0 - this.totalWeight;
                var bindPose = this.bindPose;
                if (this.dirty > 0) {
                    target.x += bindPose.x * weight;
                    target.y += bindPose.y * weight;
                    target.z += bindPose.z * weight;
                }
                else {
                    target.x = bindPose.x * weight;
                    target.y = bindPose.y * weight;
                    target.z = bindPose.z * weight;
                }
            }
            target.update();
        };
        AnimationBinder._instances = [];
        return AnimationBinder;
    }(paper.BaseRelease));
    egret3d.AnimationBinder = AnimationBinder;
    __reflect(AnimationBinder.prototype, "egret3d.AnimationBinder");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpQuaternionA = egret3d.Quaternion.create();
    var _helpQuaternionB = egret3d.Quaternion.create();
    /**
     * @private
     */
    var AnimationChannel = (function (_super) {
        __extends(AnimationChannel, _super);
        function AnimationChannel() {
            return _super.call(this) || this;
        }
        AnimationChannel.create = function () {
            var instance;
            if (this._instances.length > 0) {
                instance = this._instances.pop();
                instance._released = false;
            }
            else {
                instance = new AnimationChannel();
                instance.onClear();
            }
            return instance;
        };
        AnimationChannel.prototype.onClear = function () {
            this.enabled = true;
            this.binder = null;
            this.updateTarget = null;
            this.needUpdate = null;
        };
        AnimationChannel.prototype.onUpdateTranslation = function (animationlayer, animationState) {
            var additive = animationlayer.additive;
            var currentTime = animationState._currentTime;
            var interpolation = this.glTFSampler.interpolation;
            var outputBuffer = this.outputBuffer;
            var binder = this.binder;
            var frameIndex = this.getFrameIndex(currentTime);
            var x, y, z;
            if (frameIndex >= 0) {
                var offset = frameIndex * 3;
                x = outputBuffer[offset++];
                y = outputBuffer[offset++];
                z = outputBuffer[offset++];
                if (!interpolation || interpolation !== "STEP") {
                    var inputBuffer = this.inputBuffer;
                    var frameStart = inputBuffer[frameIndex];
                    var progress = (currentTime - frameStart) / (inputBuffer[frameIndex + 1] - frameStart);
                    x += (outputBuffer[offset++] - x) * progress;
                    y += (outputBuffer[offset++] - y) * progress;
                    z += (outputBuffer[offset++] - z) * progress;
                }
            }
            else {
                x = outputBuffer[0];
                y = outputBuffer[1];
                z = outputBuffer[2];
            }
            if (additive) {
                x -= outputBuffer[0];
                y -= outputBuffer[1];
                z -= outputBuffer[2];
            }
            var weight = binder.weight;
            var target = binder.target.localPosition;
            var animationClip = animationState.animationClip;
            if (this.glTFChannel.target.node === animationClip.root) {
                var applyRootMotion = animationClip.applyRootMotion || 5 /* XZ */;
                if (weight !== 1.0) {
                    if ((applyRootMotion & 1 /* X */) === 0) {
                        x *= weight;
                    }
                    if ((applyRootMotion & 2 /* Y */) === 0) {
                        y *= weight;
                    }
                    if ((applyRootMotion & 4 /* Z */) === 0) {
                        z *= weight;
                    }
                }
                if (binder.dirty > 1) {
                    if ((applyRootMotion & 1 /* X */) === 0) {
                        target.x += x;
                        x = 0.0;
                    }
                    if ((applyRootMotion & 2 /* Y */) === 0) {
                        target.y += y;
                        y = 0.0;
                    }
                    if ((applyRootMotion & 4 /* Z */) === 0) {
                        target.z += z;
                        z = 0.0;
                    }
                }
                else {
                    if (applyRootMotion & 1 /* X */) {
                        target.x = outputBuffer[0];
                    }
                    else {
                        target.x = x;
                        x = 0.0;
                    }
                    if (applyRootMotion & 2 /* Y */) {
                        target.y = outputBuffer[1];
                    }
                    else {
                        target.y = y;
                        y = 0.0;
                    }
                    if (applyRootMotion & 4 /* Z */) {
                        target.z = outputBuffer[2];
                    }
                    else {
                        target.z = z;
                        z = 0.0;
                    }
                }
                animationState._applyRootMotion(x, y, z, weight, currentTime, this);
            }
            else {
                if (weight !== 1.0) {
                    x *= weight;
                    y *= weight;
                    z *= weight;
                }
                if (binder.dirty > 1) {
                    target.x += x;
                    target.y += y;
                    target.z += z;
                }
                else {
                    target.x = x;
                    target.y = y;
                    target.z = z;
                }
            }
        };
        AnimationChannel.prototype.onUpdateRotation = function (animationlayer, animationState) {
            var additive = animationlayer.additive;
            var currentTime = animationState._currentTime;
            var interpolation = this.glTFSampler.interpolation;
            var outputBuffer = this.outputBuffer;
            var binder = this.binder;
            var frameIndex = this.getFrameIndex(currentTime);
            var x, y, z, w;
            if (frameIndex >= 0) {
                var offset = frameIndex * 4;
                x = outputBuffer[offset++];
                y = outputBuffer[offset++];
                z = outputBuffer[offset++];
                w = outputBuffer[offset++];
                if (!interpolation || interpolation !== "STEP") {
                    var inputBuffer = this.inputBuffer;
                    var frameStart = inputBuffer[frameIndex];
                    var progress = (currentTime - frameStart) / (inputBuffer[frameIndex + 1] - frameStart);
                    // TODO lerp?.set(x, y, z, w).dot(target) < 0.0
                    x += (outputBuffer[offset++] - x) * progress;
                    y += (outputBuffer[offset++] - y) * progress;
                    z += (outputBuffer[offset++] - z) * progress;
                    w += (outputBuffer[offset++] - w) * progress;
                }
            }
            else {
                x = outputBuffer[0];
                y = outputBuffer[1];
                z = outputBuffer[2];
                w = outputBuffer[3];
            }
            var weight = binder.weight;
            var target = binder.target.localRotation;
            var quaternions = binder.quaternions;
            if (quaternions) {
                var quaternion = void 0;
                var index = binder.dirty - 1;
                if (quaternions.length <= index) {
                    quaternions.push(egret3d.Quaternion.create());
                }
                quaternion = quaternions[index];
                if (additive) {
                    // quaternion.fromArray(outputBuffer).inverse().premultiply(_helpQuaternionA.set(x, y, z, w));
                    quaternion.x = -outputBuffer[0];
                    quaternion.y = -outputBuffer[1];
                    quaternion.z = -outputBuffer[2];
                    quaternion.w = outputBuffer[3];
                    quaternion.multiply(_helpQuaternionA.set(x, y, z, w), quaternion);
                    binder.quaternionWeights[index] = -weight;
                }
                else {
                    quaternion.x = x;
                    quaternion.y = y;
                    quaternion.z = z;
                    quaternion.w = w;
                    binder.quaternionWeights[index] = weight;
                }
            }
            else {
                if (weight !== 1.0) {
                    if (_helpQuaternionA.set(x, y, z, w).dot(target) < 0.0) {
                        weight = -weight;
                    }
                    x *= weight;
                    y *= weight;
                    z *= weight;
                    w *= weight;
                }
                if (binder.dirty > 1) {
                    target.x += x;
                    target.y += y;
                    target.z += z;
                    target.w += w;
                }
                else {
                    target.x = x;
                    target.y = y;
                    target.z = z;
                    target.w = w;
                }
            }
        };
        AnimationChannel.prototype.onUpdateScale = function (animationlayer, animationState) {
            var additive = animationlayer.additive;
            var currentTime = animationState._currentTime;
            var interpolation = this.glTFSampler.interpolation;
            var outputBuffer = this.outputBuffer;
            var binder = this.binder;
            var frameIndex = this.getFrameIndex(currentTime);
            var x, y, z;
            if (frameIndex >= 0) {
                var offset = frameIndex * 3;
                x = outputBuffer[offset++];
                y = outputBuffer[offset++];
                z = outputBuffer[offset++];
                if (!interpolation || interpolation !== "STEP") {
                    var inputBuffer = this.inputBuffer;
                    var frameStart = inputBuffer[frameIndex];
                    var progress = (currentTime - frameStart) / (inputBuffer[frameIndex + 1] - frameStart);
                    x += (outputBuffer[offset++] - x) * progress;
                    y += (outputBuffer[offset++] - y) * progress;
                    z += (outputBuffer[offset++] - z) * progress;
                }
            }
            else {
                x = outputBuffer[0];
                y = outputBuffer[1];
                z = outputBuffer[2];
            }
            if (additive) {
                x -= outputBuffer[0];
                y -= outputBuffer[1];
                z -= outputBuffer[2];
            }
            var weight = binder.weight;
            var target = binder.target.localScale;
            if (weight !== 1.0) {
                x *= weight;
                y *= weight;
                z *= weight;
            }
            if (binder.dirty > 1) {
                target.x += x;
                target.y += y;
                target.z += z;
            }
            else {
                target.x = x;
                target.y = y;
                target.z = z;
            }
        };
        AnimationChannel.prototype.onUpdateActive = function (animationlayer, animationState) {
            var currentTime = animationState._currentTime;
            var outputBuffer = this.outputBuffer;
            var frameIndex = this.getFrameIndex(currentTime);
            //
            this.binder.entity.enabled = (frameIndex >= 0 ? outputBuffer[frameIndex] : outputBuffer[0]) !== 0;
        };
        AnimationChannel.prototype.onUpdateFloat = function (animationlayer, animationState) {
            var additive = animationlayer.additive;
            var currentTime = animationState._currentTime;
            var interpolation = this.glTFSampler.interpolation;
            var outputBuffer = this.outputBuffer;
            var frameIndex = this.getFrameIndex(currentTime);
            var target = this.binder;
            var extension = this.glTFChannel.extensions.paper;
            var x;
            if (frameIndex >= 0) {
                var offset = frameIndex;
                x = outputBuffer[offset++];
                if (!interpolation || interpolation !== "STEP") {
                    var inputBuffer = this.inputBuffer;
                    var frameStart = inputBuffer[frameIndex];
                    var progress = (currentTime - frameStart) / (inputBuffer[frameIndex + 1] - frameStart);
                    x += (outputBuffer[offset++] - x) * progress;
                }
            }
            else {
                x = outputBuffer[0];
            }
            if (additive) {
                x -= outputBuffer[0];
            }
            target[extension.property] = x;
            if (this.needUpdate) {
                this.needUpdate(extension.needUpdate);
            }
        };
        AnimationChannel.prototype.getFrameIndex = function (currentTime) {
            var inputBuffer = this.inputBuffer;
            var frameCount = inputBuffer.length;
            if (true && frameCount === 0) {
                throw new Error();
            }
            if (frameCount === 1) {
                return -1;
            }
            else if (currentTime <= inputBuffer[0]) {
                return 0;
            }
            else if (currentTime >= inputBuffer[frameCount - 1]) {
                return frameCount - 2;
            }
            var beginIndex = 0;
            var endIndex = frameCount - 1;
            while (endIndex - beginIndex > 1) {
                var middleIndex = beginIndex + ((endIndex - beginIndex) * 0.5) >> 0;
                if (currentTime >= inputBuffer[middleIndex]) {
                    beginIndex = middleIndex;
                }
                else {
                    endIndex = middleIndex;
                }
            }
            return beginIndex;
        };
        AnimationChannel._instances = [];
        return AnimationChannel;
    }(paper.BaseRelease));
    egret3d.AnimationChannel = AnimationChannel;
    __reflect(AnimationChannel.prototype, "egret3d.AnimationChannel");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 动画事件类型。
     */
    var AnimationEventType;
    (function (AnimationEventType) {
        AnimationEventType[AnimationEventType["Start"] = 0] = "Start";
        AnimationEventType[AnimationEventType["LoopComplete"] = 1] = "LoopComplete";
        AnimationEventType[AnimationEventType["Complete"] = 2] = "Complete";
        AnimationEventType[AnimationEventType["KeyFrame"] = 3] = "KeyFrame";
        AnimationEventType[AnimationEventType["Sound"] = 4] = "Sound";
    })(AnimationEventType = egret3d.AnimationEventType || (egret3d.AnimationEventType = {}));
    /**
     * 动画事件。
     */
    var AnimationEvent = (function (_super) {
        __extends(AnimationEvent, _super);
        function AnimationEvent() {
            var _this = _super.call(this) || this;
            _this.type = 0 /* Start */;
            _this.animationState = null;
            _this.frameEvent = null;
            return _this;
        }
        AnimationEvent.create = function (type, animationState, keyFrameEvent) {
            if (keyFrameEvent === void 0) { keyFrameEvent = null; }
            var instance = null;
            if (this._instances.length > 0) {
                instance = this._instances.pop();
                instance._released = false;
            }
            else {
                instance = new AnimationEvent();
            }
            instance.type = type;
            instance.animationState = animationState;
            instance.frameEvent = keyFrameEvent;
            return instance;
        };
        AnimationEvent._instances = [];
        return AnimationEvent;
    }(paper.BaseRelease));
    egret3d.AnimationEvent = AnimationEvent;
    __reflect(AnimationEvent.prototype, "egret3d.AnimationEvent");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 动画系统。
     */
    var AnimationSystem = (function (_super) {
        __extends(AnimationSystem, _super);
        function AnimationSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._animation = null;
            return _this;
        }
        AnimationSystem.prototype._updateAnimationFadeState = function (animationFadeState, deltaTime) {
            if (deltaTime < 0.0) {
                deltaTime = -deltaTime;
            }
            var isFadeOut = animationFadeState.fadeState === 1;
            var totalTime = animationFadeState.totalTime;
            var time = animationFadeState.time += deltaTime;
            if (animationFadeState.subFadeState === -1) {
                animationFadeState.subFadeState = 0;
            }
            if (time >= totalTime) {
                animationFadeState.subFadeState = 1;
                animationFadeState.progress = isFadeOut ? 0.0 : 1.0;
            }
            else if (time > 0.0) {
                animationFadeState.progress = isFadeOut ? (1.0 - time / totalTime) : (time / totalTime);
            }
            else {
                animationFadeState.progress = isFadeOut ? 1.0 : 0.0;
            }
            if (animationFadeState.subFadeState === 1) {
                if (!isFadeOut) {
                    animationFadeState.fadeState = 0;
                    animationFadeState.subFadeState = 0; //
                }
            }
        };
        AnimationSystem.prototype._updateAnimationTreeState = function (animationFadeState, animationTreeState) {
            var animationLayer = animationTreeState.animationLayer;
            var weight = animationLayer.weight * animationTreeState.weight;
            if (animationTreeState._parent) {
                weight *= animationTreeState._parent._globalWeight;
            }
            else {
                weight *= animationFadeState.progress;
            }
            animationTreeState._globalWeight = weight;
        };
        AnimationSystem.prototype._updateAnimationState = function (animationFadeState, animationState, deltaTime, forceUpdate) {
            var animation = this._animation;
            var gameObject = animation.gameObject;
            var animationLayer = animationState.animationLayer;
            // const animationNode = animationState.animationNode;
            var weight = animationLayer.weight * animationState.weight;
            if (animationState._parent) {
                weight *= animationState._parent._globalWeight;
            }
            else {
                weight *= animationFadeState.progress;
            }
            animationState._globalWeight = weight;
            // Update time.
            if (animationState._playheadEnabled) {
                deltaTime *= animation.timeScale * animationState.timeScale;
                animationState._time += deltaTime;
            }
            var time = animationState._time;
            // const isBlendDirty = this._fadeState !== 0 || this._subFadeState === 0;
            var prevPlayState = animationState._playState;
            var prevPlayTimes = animationState.currentPlayTimes;
            var prevTime = animationState._currentTime;
            var playTimes = animationState.playTimes;
            var duration = animationState.animationClip.duration;
            var totalTime = playTimes * duration;
            var currentTime = 0.0;
            if (playTimes > 0 && (time >= totalTime || time <= -totalTime)) {
                if (animationState._playState <= 0 && animationState._playheadEnabled) {
                    animationState._playState = 1;
                }
                animationState.currentPlayTimes = playTimes;
                if (time >= totalTime) {
                    currentTime = duration;
                }
                else {
                    currentTime = 0.0;
                }
            }
            else {
                if (animationState._playState !== 0 && animationState._playheadEnabled) {
                    animationState._playState = 0;
                }
                if (time < 0.0) {
                    time = -time;
                    animationState.currentPlayTimes = (time / duration) >> 0;
                    currentTime = duration - (time % duration);
                }
                else {
                    animationState.currentPlayTimes = (time / duration) >> 0;
                    currentTime = time % duration;
                }
            }
            currentTime += animationState.animationClip.position;
            animationState._currentTime = currentTime;
            if (forceUpdate || weight !== 0.0) {
                var mask = animationLayer.mask;
                if (mask && mask._dirty) {
                    var jointNames = mask.jointNames;
                    var nodes = animationState.animationAsset.config.nodes;
                    for (var _i = 0, _a = animationState.channels; _i < _a.length; _i++) {
                        var channel = _a[_i];
                        if (jointNames && jointNames.length > 0) {
                            var jointIndex = channel.glTFChannel.target.node;
                            channel.enabled = jointIndex === undefined || jointNames.indexOf(nodes[jointIndex].name) >= 0;
                        }
                        else {
                            channel.enabled = true;
                        }
                    }
                }
                for (var _b = 0, _c = animationState.channels; _b < _c.length; _b++) {
                    var channel = _c[_b];
                    if (!channel.updateTarget || !channel.enabled) {
                        continue;
                    }
                    var binder = channel.binder;
                    if (binder.constructor === egret3d.AnimationBinder) {
                        if (binder.updateBlend(animationLayer, animationState)) {
                            channel.updateTarget(animationLayer, animationState);
                        }
                    }
                    else {
                        channel.updateTarget(animationLayer, animationState);
                    }
                }
            }
            // this._events; // TODO buffer event.
            if (prevPlayState === -1 && animationState._playState !== -1) {
                gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(0 /* Start */, animationState), false);
            }
            //
            var loopEvent = false;
            var frameEvents = animationState.animation.extensions.paper.events;
            if (deltaTime !== 0.0 && frameEvents) {
                if (deltaTime > 0.0) {
                    if (prevTime < currentTime) {
                        for (var _d = 0, frameEvents_1 = frameEvents; _d < frameEvents_1.length; _d++) {
                            var event_1 = frameEvents_1[_d];
                            if (prevTime < event_1.position && event_1.position <= currentTime) {
                                gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(3 /* KeyFrame */, animationState, event_1), false);
                            }
                        }
                    }
                    else {
                        for (var _e = 0, frameEvents_2 = frameEvents; _e < frameEvents_2.length; _e++) {
                            var event_2 = frameEvents_2[_e];
                            if (prevTime < event_2.position) {
                                gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(3 /* KeyFrame */, animationState, event_2), false);
                            }
                        }
                        gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(1 /* LoopComplete */, animationState), false);
                        for (var _f = 0, frameEvents_3 = frameEvents; _f < frameEvents_3.length; _f++) {
                            var event_3 = frameEvents_3[_f];
                            if (event_3.position <= currentTime) {
                                gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(3 /* KeyFrame */, animationState, event_3), false);
                            }
                        }
                        loopEvent = true;
                    }
                }
                else {
                    if (prevTime > currentTime) {
                        for (var _g = 0, frameEvents_4 = frameEvents; _g < frameEvents_4.length; _g++) {
                            var event_4 = frameEvents_4[_g];
                            if (currentTime <= event_4.position && event_4.position < prevTime) {
                                gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(3 /* KeyFrame */, animationState, event_4), false);
                            }
                        }
                    }
                    else {
                        for (var _h = 0, frameEvents_5 = frameEvents; _h < frameEvents_5.length; _h++) {
                            var event_5 = frameEvents_5[_h];
                            if (event_5.position < prevTime) {
                                gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(3 /* KeyFrame */, animationState, event_5), false);
                            }
                        }
                        gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(1 /* LoopComplete */, animationState), false);
                        for (var _j = 0, frameEvents_6 = frameEvents; _j < frameEvents_6.length; _j++) {
                            var event_6 = frameEvents_6[_j];
                            if (currentTime <= event_6.position) {
                                gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(3 /* KeyFrame */, animationState, event_6), false);
                            }
                        }
                        loopEvent = true;
                    }
                }
            }
            if (animationState.currentPlayTimes !== prevPlayTimes) {
                if (!loopEvent) {
                    gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(1 /* LoopComplete */, animationState), false);
                }
                if (animationState._playState === 1) {
                    var clipNames = animationLayer._clipNames;
                    if (clipNames && clipNames.length > 0) {
                        animation.play(clipNames.shift());
                    }
                    else {
                        gameObject.sendMessage("onAnimationEvent", egret3d.AnimationEvent.create(2 /* Complete */, animationState), false);
                    }
                }
            }
        };
        AnimationSystem.prototype.getMatchers = function () {
            return [
                paper.Matcher.create(egret3d.Transform, egret3d.Animation),
            ];
        };
        AnimationSystem.prototype.onEntityAdded = function (entity) {
            var animation = entity.getComponent(egret3d.Animation);
            if ((paper.Application.playerMode & 4 /* Editor */) === 0 &&
                animation.autoPlay &&
                (!animation.lastAnimationState || !animation.lastAnimationState.isPlaying)) {
                animation.play();
            }
        };
        AnimationSystem.prototype.onFrame = function (deltaTime) {
            for (var _i = 0, _a = this.groups[0].entities; _i < _a.length; _i++) {
                var entity = _a[_i];
                var animation = this._animation = entity.getComponent(egret3d.Animation);
                var animationController = animation.animationController;
                if (!animationController) {
                    continue;
                }
                var animationLayers = animationController.layers;
                var animationFadeStates = animation._fadeStates;
                var blendlayers = animation._binders;
                for (var k in blendlayers) {
                    var blendLayer = blendlayers[k];
                    blendLayer.clear();
                }
                for (var i = animationFadeStates.length - 1; i >= 0; i--) {
                    var fadeStates = animationFadeStates[i];
                    for (var j = 0, r = 0, lJ = fadeStates.length; j < lJ; ++j) {
                        var forceUpdate = false;
                        var fadeState = fadeStates[j];
                        var sFadeState = fadeState.fadeState;
                        var sSubFadeState = fadeState.subFadeState;
                        if (sFadeState === 1 && sSubFadeState === 1) {
                            r++;
                            fadeState.release();
                        }
                        else {
                            if (r > 0) {
                                fadeStates[j - r] = fadeState;
                            }
                            if (sFadeState !== 0 || sSubFadeState !== 0) {
                                forceUpdate = true;
                                this._updateAnimationFadeState(fadeState, deltaTime);
                            }
                            for (var _b = 0, _c = fadeState.states; _b < _c.length; _b++) {
                                var animationState = _c[_b];
                                if (animationState.constructor === egret3d.AnimationTreeState) {
                                    this._updateAnimationTreeState(fadeState, animationState);
                                }
                                else {
                                    this._updateAnimationState(fadeState, animationState, deltaTime, forceUpdate);
                                }
                            }
                        }
                        if (j === lJ - 1 && r > 0) {
                            fadeStates.length -= r;
                        }
                    }
                }
                for (var _d = 0, animationLayers_1 = animationLayers; _d < animationLayers_1.length; _d++) {
                    var layer = animationLayers_1[_d];
                    var mask = layer.mask;
                    if (mask && mask._dirty) {
                        mask._dirty = false;
                    }
                }
                for (var k in blendlayers) {
                    var blendLayer = blendlayers[k];
                    blendLayer.updateTarget();
                }
            }
        };
        return AnimationSystem;
    }(paper.BaseSystem));
    egret3d.AnimationSystem = AnimationSystem;
    __reflect(AnimationSystem.prototype, "egret3d.AnimationSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        /**
         * @private
         * 渲染类型为Mesh的属性格式
         */
        var MeshShaderAttributeFormat = [
            { key: "POSITION" /* POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "COLOR_0" /* COLOR_0 */, type: "VEC4" /* VEC4 */ },
            { key: "TEXCOORD_0" /* TEXCOORD_0 */, type: "VEC2" /* VEC2 */ },
            { key: "_START_POSITION" /* _START_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "_START_VELOCITY" /* _START_VELOCITY */, type: "VEC3" /* VEC3 */ },
            { key: "_START_COLOR" /* _START_COLOR */, type: "VEC4" /* VEC4 */ },
            { key: "_START_SIZE" /* _START_SIZE */, type: "VEC3" /* VEC3 */ },
            { key: "_START_ROTATION" /* _START_ROTATION */, type: "VEC3" /* VEC3 */ },
            { key: "_TIME" /* _TIME */, type: "VEC2" /* VEC2 */ },
            { key: "_RANDOM0" /* _RANDOM0 */, type: "VEC4" /* VEC4 */ },
            { key: "_RANDOM1" /* _RANDOM1 */, type: "VEC4" /* VEC4 */ },
            { key: "_WORLD_POSITION" /* _WORLD_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "_WORLD_ROTATION" /* _WORLD_ROTATION */, type: "VEC4" /* VEC4 */ },
        ];
        /**
         * @private
         * 渲染类型为Billboard的属性格式
         */
        var BillboardShaderAttributeFormat = [
            { key: "_CORNER" /* _CORNER */, type: "VEC2" /* VEC2 */ },
            { key: "TEXCOORD_0" /* TEXCOORD_0 */, type: "VEC2" /* VEC2 */ },
            { key: "_START_POSITION" /* _START_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "_START_VELOCITY" /* _START_VELOCITY */, type: "VEC3" /* VEC3 */ },
            { key: "_START_COLOR" /* _START_COLOR */, type: "VEC4" /* VEC4 */ },
            { key: "_START_SIZE" /* _START_SIZE */, type: "VEC3" /* VEC3 */ },
            { key: "_START_ROTATION" /* _START_ROTATION */, type: "VEC3" /* VEC3 */ },
            { key: "_TIME" /* _TIME */, type: "VEC2" /* VEC2 */ },
            { key: "_RANDOM0" /* _RANDOM0 */, type: "VEC4" /* VEC4 */ },
            { key: "_RANDOM1" /* _RANDOM1 */, type: "VEC4" /* VEC4 */ },
            { key: "_WORLD_POSITION" /* _WORLD_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "_WORLD_ROTATION" /* _WORLD_ROTATION */, type: "VEC4" /* VEC4 */ },
        ];
        /**
        * @internal
        */
        function createBatchMesh(renderer, maxParticleCount) {
            var meshAttributes = [];
            var meshAttributesType = {};
            if (renderer.renderMode === 4 /* Mesh */) {
                var mesh = renderer.mesh;
                var orginIndexBuffer = mesh.getIndices();
                var orginIndexBufferCount = orginIndexBuffer.length;
                for (var _i = 0, MeshShaderAttributeFormat_1 = MeshShaderAttributeFormat; _i < MeshShaderAttributeFormat_1.length; _i++) {
                    var attribute = MeshShaderAttributeFormat_1[_i];
                    meshAttributes.push(attribute.key);
                    meshAttributesType[attribute.key] = attribute.type;
                }
                var totalVertexCount = mesh.vertexCount * maxParticleCount;
                var totalIndexCount = orginIndexBufferCount * maxParticleCount;
                var batchMesh = egret3d.Mesh.create(totalVertexCount, totalIndexCount, meshAttributes, meshAttributesType);
                batchMesh.drawMode = 35048 /* Dynamic */;
                //
                var index = 0;
                //提前填充
                var orginPostionBuffer = mesh.getAttributes("POSITION" /* POSITION */);
                var orginUVBuffer = mesh.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */);
                var orginColorBuffer = mesh.getAttributes("COLOR_0" /* COLOR_0 */);
                var positionBuffer = batchMesh.getAttributes("POSITION" /* POSITION */);
                var colorBuffer = batchMesh.getAttributes("COLOR_0" /* COLOR_0 */);
                var uvBuffer = batchMesh.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */);
                for (var i = 0; i < totalVertexCount; i++) {
                    var vector2Offset = i * 2;
                    var vector3Offset = i * 3;
                    var vector4Offset = i * 4;
                    var orginVertexIndex = i % mesh.vertexCount;
                    positionBuffer[vector3Offset] = orginPostionBuffer[orginVertexIndex * 3];
                    positionBuffer[vector3Offset + 1] = orginPostionBuffer[orginVertexIndex * 3 + 1];
                    positionBuffer[vector3Offset + 2] = orginPostionBuffer[orginVertexIndex * 3 + 2];
                    if (orginUVBuffer) {
                        uvBuffer[vector2Offset] = orginUVBuffer[orginVertexIndex * 2];
                        uvBuffer[vector2Offset + 1] = 1.0 - orginUVBuffer[orginVertexIndex * 2 + 1];
                    }
                    if (orginColorBuffer) {
                        colorBuffer[vector4Offset] = orginColorBuffer[orginVertexIndex * 4];
                        colorBuffer[vector4Offset + 1] = orginColorBuffer[orginVertexIndex * 4 + 1];
                        colorBuffer[vector4Offset + 2] = orginColorBuffer[orginVertexIndex * 4 + 2];
                        colorBuffer[vector4Offset + 3] = orginColorBuffer[orginVertexIndex * 4 + 3];
                    }
                    else {
                        colorBuffer[vector4Offset] = 1;
                        colorBuffer[vector4Offset + 1] = 1;
                        colorBuffer[vector4Offset + 2] = 1;
                        colorBuffer[vector4Offset + 3] = 1;
                    }
                }
                var indexBuffer = batchMesh.getIndices();
                for (var i = 0; i < maxParticleCount; i++) {
                    var indexOffset = i * mesh.vertexCount;
                    for (var j = 0; j < orginIndexBufferCount; j++) {
                        indexBuffer[index++] = orginIndexBuffer[j] + indexOffset;
                    }
                }
                return batchMesh;
            }
            else {
                var orginIndexBuffer = [0, 2, 1, 1, 2, 3];
                var orginIndexBufferCount = orginIndexBuffer.length;
                for (var _a = 0, BillboardShaderAttributeFormat_1 = BillboardShaderAttributeFormat; _a < BillboardShaderAttributeFormat_1.length; _a++) {
                    var attribute = BillboardShaderAttributeFormat_1[_a];
                    meshAttributes.push(attribute.key);
                    meshAttributesType[attribute.key] = attribute.type;
                }
                var vertexStride = 4;
                var totalVertexCount = vertexStride * maxParticleCount;
                var totalIndexCount = orginIndexBufferCount * maxParticleCount;
                var batchMesh = egret3d.Mesh.create(totalVertexCount, totalIndexCount, meshAttributes, meshAttributesType);
                batchMesh.drawMode = 35048 /* Dynamic */;
                var cornerBuffer = batchMesh.getAttributes("_CORNER" /* _CORNER */);
                var uvBuffer = batchMesh.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */);
                for (var i = 0; i < totalVertexCount; i++) {
                    var orginVertexIndex = i % vertexStride;
                    var vector2Offset = i * 2;
                    switch (orginVertexIndex) {
                        case 0:
                            cornerBuffer[vector2Offset] = -0.5;
                            cornerBuffer[vector2Offset + 1] = 0.5;
                            uvBuffer[vector2Offset] = 0.0;
                            uvBuffer[vector2Offset + 1] = 0.0;
                            break;
                        case 1:
                            cornerBuffer[vector2Offset] = 0.5;
                            cornerBuffer[vector2Offset + 1] = 0.5;
                            uvBuffer[vector2Offset] = 1.0;
                            uvBuffer[vector2Offset + 1] = 0.0;
                            break;
                        case 2:
                            cornerBuffer[vector2Offset] = -0.5;
                            cornerBuffer[vector2Offset + 1] = -0.5;
                            uvBuffer[vector2Offset] = 0.0;
                            uvBuffer[vector2Offset + 1] = 1.0;
                            break;
                        case 3:
                            cornerBuffer[vector2Offset] = 0.5;
                            cornerBuffer[vector2Offset + 1] = -0.5;
                            uvBuffer[vector2Offset] = 1.0;
                            uvBuffer[vector2Offset + 1] = 1.0;
                            break;
                    }
                }
                var indexBuffer = batchMesh.getIndices();
                for (var i = 0; i < maxParticleCount; i++) {
                    var indexOffset = i * 6;
                    var firstVertex = i * vertexStride;
                    var secondVertex = firstVertex + 2;
                    indexBuffer[indexOffset + 0] = firstVertex;
                    indexBuffer[indexOffset + 1] = secondVertex;
                    indexBuffer[indexOffset + 2] = firstVertex + 1;
                    indexBuffer[indexOffset + 3] = firstVertex + 1;
                    indexBuffer[indexOffset + 4] = secondVertex;
                    indexBuffer[indexOffset + 5] = firstVertex + 3;
                }
                return batchMesh;
            }
        }
        particle.createBatchMesh = createBatchMesh;
        /**
         * @internal
         */
        function generatePositionAndDirection(position, direction, shape) {
            position.x = position.y = position.z = 0;
            direction.x = direction.y = 0;
            direction.z = 1.0;
            //
            switch (shape.shapeType) {
                case 4 /* Cone */:
                case 7 /* ConeShell */:
                    {
                        _generateConeParticlePosition(shape, position, direction);
                    }
                    break;
                case 8 /* ConeVolume */:
                case 9 /* ConeVolumeShell */:
                    {
                        _generateConeVolumeParticlePosition(shape, position, direction);
                    }
                    break;
                case 5 /* Box */:
                    {
                        _generateBoxParticlePosition(shape, position, direction);
                    }
                    break;
                case 0 /* Sphere */:
                case 1 /* SphereShell */:
                    {
                        _generateSphereParticlePosition(shape, position, direction);
                    }
                    break;
                case 10 /* Circle */:
                    {
                        _generateCircleParticlePosition(shape, position, direction);
                    }
                    break;
            }
            direction.normalize();
        }
        particle.generatePositionAndDirection = generatePositionAndDirection;
        function _randomPostionCircle(out) {
            var angle = Math.random() * 6.283185307179586 /* PI_DOUBLE */;
            out.x = Math.cos(angle);
            out.y = Math.sin(angle);
        }
        function _randomPositionInsideCircle(out) {
            _randomPostionCircle(out);
            var range = Math.pow(Math.random(), 0.5);
            out.x = out.x * range;
            out.y = out.y * range;
        }
        function _randomPositionArcCircle(arc, out) {
            arc *= 0.017453292519943295 /* DEG_RAD */;
            var angle = Math.random() * arc;
            out.x = Math.cos(angle);
            out.y = Math.sin(angle);
        }
        function _randomPositionInsideArcCircle(arc, out) {
            _randomPositionArcCircle(arc, out);
            var range = Math.pow(Math.random(), 0.5);
            out.x = out.x * range;
            out.y = out.y * range;
        }
        function _randomPositionSphere(out) {
            var ranZ = Math.random() * 2 - 1.0;
            var angle = Math.random() * 6.283185307179586 /* PI_DOUBLE */;
            var range = Math.sqrt(1.0 - ranZ * ranZ);
            out.x = Math.cos(angle) * range;
            out.y = Math.sin(angle) * range;
            out.z = ranZ;
        }
        function _randomPositionInsideSphere(out) {
            _randomPositionSphere(out);
            var range = Math.pow(Math.random(), 1.0 / 3.0);
            out.x = out.x * range;
            out.y = out.y * range;
            out.z = out.z * range;
        }
        function _generateConeParticlePosition(shape, position, direction) {
            var temp = egret3d.Vector3.create().release();
            if (shape.shapeType === 4 /* Cone */) {
                _randomPositionInsideCircle(temp);
            }
            else {
                _randomPostionCircle(temp);
            }
            position.x = temp.x * shape.radius;
            position.y = temp.y * shape.radius;
            position.z = temp.z * shape.radius;
            var angle = shape.angle * 0.017453292519943295 /* DEG_RAD */;
            var sinValue = Math.sin(angle);
            var cosValue = Math.cos(angle);
            if (shape.randomDirection) {
                _randomPositionInsideCircle(direction);
                direction.x = direction.x * sinValue;
                direction.y = direction.y * sinValue;
                direction.z = cosValue;
            }
            else {
                direction.x = temp.x * sinValue;
                direction.y = temp.y * sinValue;
                direction.z = cosValue;
            }
        }
        function _generateConeVolumeParticlePosition(shape, position, direction) {
            var temp = egret3d.Vector3.create().release();
            if (shape.shapeType === 8 /* ConeVolume */) {
                _randomPositionInsideCircle(temp);
            }
            else {
                _randomPostionCircle(temp);
            }
            position.x = temp.x * shape.radius;
            position.y = temp.y * shape.radius;
            position.z = 0;
            var angle = shape.angle * 0.017453292519943295 /* DEG_RAD */;
            var sinValue = Math.sin(angle);
            var cosValue = Math.cos(angle);
            direction.x = temp.x * sinValue;
            direction.y = temp.y * sinValue;
            direction.z = cosValue;
            egret3d.Vector3.normalize(direction);
            var len = Math.random() * shape.length;
            direction.x = direction.x * len;
            direction.y = direction.y * len;
            direction.z = direction.z * len;
            position.x += direction.x;
            position.y += direction.y;
            position.z += direction.z;
            if (shape.randomDirection) {
                _randomPositionSphere(direction);
            }
        }
        function _generateBoxParticlePosition(shape, position, direction) {
            position.x = shape.box.x * (Math.random() - 0.5);
            position.y = shape.box.y * (Math.random() - 0.5);
            position.z = shape.box.z * (Math.random() - 0.5);
            if (shape.randomDirection) {
                direction.x = 0.0;
                direction.y = 0.0;
                direction.z = 1.0;
            }
            else {
                direction.x = 0.0;
                direction.y = 0.0;
                direction.z = 1.0;
            }
        }
        function _generateSphereParticlePosition(shape, position, direction) {
            var temp = egret3d.Vector3.create().release();
            if (!shape.spherizeDirection) {
                if (shape.shapeType === 0 /* Sphere */) {
                    _randomPositionInsideSphere(position);
                }
                else {
                    _randomPositionSphere(position);
                }
            }
            position.x = position.x * shape.radius;
            position.y = position.y * shape.radius;
            position.z = position.z * shape.radius;
            if (shape.randomDirection || shape.spherizeDirection) {
                _randomPositionSphere(direction);
            }
            else {
                direction.x = position.x;
                direction.y = position.y;
                direction.z = position.z;
            }
        }
        function _generateCircleParticlePosition(shape, position, direction) {
            var temp = egret3d.Vector3.create().release();
            _randomPositionArcCircle(shape.arc, temp);
            position.x = -temp.x * shape.radius;
            position.y = temp.y * shape.radius;
            position.z = 0;
            if (shape.randomDirection) {
                _randomPositionSphere(direction);
            }
            else {
                direction.x = position.x;
                direction.y = position.y;
                direction.z = position.z;
            }
        }
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        particle.onMainChanged = new signals.Signal();
        particle.onColorChanged = new signals.Signal();
        particle.onVelocityChanged = new signals.Signal();
        particle.onSizeChanged = new signals.Signal();
        particle.onRotationChanged = new signals.Signal();
        particle.onTextureSheetChanged = new signals.Signal();
        particle.onShapeChanged = new signals.Signal();
        particle.onStartSize3DChanged = new signals.Signal();
        particle.onStartRotation3DChanged = new signals.Signal();
        particle.onSimulationSpaceChanged = new signals.Signal();
        particle.onScaleModeChanged = new signals.Signal();
        particle.onMaxParticlesChanged = new signals.Signal();
        /**
         *
         */
        var CurveMode;
        (function (CurveMode) {
            CurveMode[CurveMode["Constant"] = 0] = "Constant";
            CurveMode[CurveMode["Curve"] = 1] = "Curve";
            CurveMode[CurveMode["TwoCurves"] = 2] = "TwoCurves";
            CurveMode[CurveMode["TwoConstants"] = 3] = "TwoConstants";
        })(CurveMode = particle.CurveMode || (particle.CurveMode = {}));
        /**
         *
         */
        var ColorGradientMode;
        (function (ColorGradientMode) {
            ColorGradientMode[ColorGradientMode["Color"] = 0] = "Color";
            ColorGradientMode[ColorGradientMode["Gradient"] = 1] = "Gradient";
            ColorGradientMode[ColorGradientMode["TwoColors"] = 2] = "TwoColors";
            ColorGradientMode[ColorGradientMode["TwoGradients"] = 3] = "TwoGradients";
            ColorGradientMode[ColorGradientMode["RandomColor"] = 4] = "RandomColor";
        })(ColorGradientMode = particle.ColorGradientMode || (particle.ColorGradientMode = {}));
        /**
         *
         */
        var SimulationSpace;
        (function (SimulationSpace) {
            SimulationSpace[SimulationSpace["Local"] = 0] = "Local";
            SimulationSpace[SimulationSpace["World"] = 1] = "World";
            SimulationSpace[SimulationSpace["Custom"] = 2] = "Custom";
        })(SimulationSpace = particle.SimulationSpace || (particle.SimulationSpace = {}));
        /**
         *
         */
        var ScalingMode;
        (function (ScalingMode) {
            ScalingMode[ScalingMode["Hierarchy"] = 0] = "Hierarchy";
            ScalingMode[ScalingMode["Local"] = 1] = "Local";
            ScalingMode[ScalingMode["Shape"] = 2] = "Shape";
        })(ScalingMode = particle.ScalingMode || (particle.ScalingMode = {}));
        /**
         *
         */
        var ShapeType;
        (function (ShapeType) {
            ShapeType[ShapeType["None"] = -1] = "None";
            ShapeType[ShapeType["Sphere"] = 0] = "Sphere";
            ShapeType[ShapeType["SphereShell"] = 1] = "SphereShell";
            ShapeType[ShapeType["Hemisphere"] = 2] = "Hemisphere";
            ShapeType[ShapeType["HemisphereShell"] = 3] = "HemisphereShell";
            ShapeType[ShapeType["Cone"] = 4] = "Cone";
            ShapeType[ShapeType["Box"] = 5] = "Box";
            ShapeType[ShapeType["Mesh"] = 6] = "Mesh";
            ShapeType[ShapeType["ConeShell"] = 7] = "ConeShell";
            ShapeType[ShapeType["ConeVolume"] = 8] = "ConeVolume";
            ShapeType[ShapeType["ConeVolumeShell"] = 9] = "ConeVolumeShell";
            ShapeType[ShapeType["Circle"] = 10] = "Circle";
            ShapeType[ShapeType["CircleEdge"] = 11] = "CircleEdge";
            ShapeType[ShapeType["SingleSidedEdge"] = 12] = "SingleSidedEdge";
            ShapeType[ShapeType["MeshRenderer"] = 13] = "MeshRenderer";
            ShapeType[ShapeType["SkinnedMeshRenderer"] = 14] = "SkinnedMeshRenderer";
            ShapeType[ShapeType["BoxShell"] = 15] = "BoxShell";
            ShapeType[ShapeType["BoxEdge"] = 16] = "BoxEdge";
        })(ShapeType = particle.ShapeType || (particle.ShapeType = {}));
        /**
         *
         */
        var ShapeMultiModeValue;
        (function (ShapeMultiModeValue) {
            ShapeMultiModeValue[ShapeMultiModeValue["Random"] = 0] = "Random";
            ShapeMultiModeValue[ShapeMultiModeValue["Loop"] = 1] = "Loop";
            ShapeMultiModeValue[ShapeMultiModeValue["PingPong"] = 2] = "PingPong";
            ShapeMultiModeValue[ShapeMultiModeValue["BurstSpread"] = 3] = "BurstSpread";
        })(ShapeMultiModeValue = particle.ShapeMultiModeValue || (particle.ShapeMultiModeValue = {}));
        /**
         *
         */
        var AnimationType;
        (function (AnimationType) {
            AnimationType[AnimationType["WholeSheet"] = 0] = "WholeSheet";
            AnimationType[AnimationType["SingleRow"] = 1] = "SingleRow";
        })(AnimationType = particle.AnimationType || (particle.AnimationType = {}));
        /**
         *
         */
        var UVChannelFlags;
        (function (UVChannelFlags) {
            UVChannelFlags[UVChannelFlags["UV0"] = 1] = "UV0";
            UVChannelFlags[UVChannelFlags["UV1"] = 2] = "UV1";
            UVChannelFlags[UVChannelFlags["UV2"] = 4] = "UV2";
            UVChannelFlags[UVChannelFlags["UV3"] = 8] = "UV3";
        })(UVChannelFlags = particle.UVChannelFlags || (particle.UVChannelFlags = {}));
        /**
         *
         */
        var GradientMode;
        (function (GradientMode) {
            GradientMode[GradientMode["Blend"] = 0] = "Blend";
            GradientMode[GradientMode["Fixed"] = 1] = "Fixed";
        })(GradientMode = particle.GradientMode || (particle.GradientMode = {}));
        var _helpColorA = egret3d.Color.create();
        var _helpColorB = egret3d.Color.create();
        /**
         * TODO
         */
        var Keyframe = (function () {
            function Keyframe() {
            }
            Keyframe.prototype.serialize = function () {
                return [this.time, this.value];
            };
            Keyframe.prototype.deserialize = function (element) {
                this.time = element[0];
                this.value = element[1];
                return this;
            };
            Keyframe.prototype.copy = function (source) {
                this.time = source.time;
                this.value = source.value;
            };
            return Keyframe;
        }());
        particle.Keyframe = Keyframe;
        __reflect(Keyframe.prototype, "egret3d.particle.Keyframe", ["paper.ISerializable"]);
        /**
         * TODO
         */
        var AnimationCurve = (function () {
            function AnimationCurve() {
                /**
                 * 功能与效率平衡长度取4
                 */
                this._keys = new Array();
                this._floatValues = new Float32Array(8);
            }
            AnimationCurve.prototype.serialize = function () {
                return this._keys.map(function (keyFrame) { return keyFrame.serialize(); });
            };
            AnimationCurve.prototype.deserialize = function (element) {
                this._keys.length = 0;
                for (var i = 0, l = element.length; i < l; i++) {
                    var keyframe = new Keyframe();
                    keyframe.deserialize(element[i]);
                    this._keys.push(keyframe);
                }
                return this;
            };
            AnimationCurve.prototype.evaluate = function (t) {
                if (t === void 0) { t = 0; }
                for (var i = 0, l = this._keys.length; i < l; i++) {
                    var curKeyFrame = this._keys[i];
                    if (curKeyFrame.time < t) {
                        continue;
                    }
                    //
                    var lastIndex = i === 0 ? 0 : i - 1;
                    var lastKeyFrame = this._keys[lastIndex];
                    var tt = (t - lastKeyFrame.time) / (curKeyFrame.time - lastKeyFrame.time);
                    return egret3d.math.lerp(lastKeyFrame.value, curKeyFrame.value, tt);
                }
                throw "AnimationCurve: invalid t or keys.length is 0";
            };
            Object.defineProperty(AnimationCurve.prototype, "floatValues", {
                get: function () {
                    var res = this._floatValues;
                    var offset = 0;
                    for (var _i = 0, _a = this._keys; _i < _a.length; _i++) {
                        var keyFrame = _a[_i];
                        res[offset++] = keyFrame.time;
                        res[offset++] = keyFrame.value;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            AnimationCurve.prototype.copy = function (source) {
                this._keys.length = 0;
                var sourceKeys = source._keys;
                for (var i = 0, l = sourceKeys.length; i < l; i++) {
                    var keyframe = new Keyframe();
                    keyframe.time = sourceKeys[i].time;
                    keyframe.value = sourceKeys[i].value;
                    this._keys.push(keyframe);
                }
            };
            return AnimationCurve;
        }());
        particle.AnimationCurve = AnimationCurve;
        __reflect(AnimationCurve.prototype, "egret3d.particle.AnimationCurve", ["paper.ISerializable"]);
        /**
         * TODO
         */
        var Burst = (function () {
            function Burst() {
                this.time = 0.0;
                this.minCount = 0;
                this.maxCount = 100;
                this.cycleCount = 1;
                this.repeatInterval = 1.0;
            }
            Burst.prototype.serialize = function () {
                return [this.time, this.minCount, this.maxCount, this.cycleCount, this.repeatInterval];
            };
            Burst.prototype.deserialize = function (element) {
                this.time = element[0];
                this.minCount = element[1];
                this.maxCount = element[2];
                this.cycleCount = element[3];
                this.repeatInterval = element[4];
                return this;
            };
            return Burst;
        }());
        particle.Burst = Burst;
        __reflect(Burst.prototype, "egret3d.particle.Burst", ["paper.ISerializable"]);
        /**
         * TODO
         */
        var GradientColorKey = (function () {
            function GradientColorKey() {
                this.time = 0.0;
                this.color = egret3d.Color.create();
            }
            GradientColorKey.prototype.serialize = function () {
                return { time: this.time, color: this.color.serialize() };
            };
            GradientColorKey.prototype.deserialize = function (element) {
                this.time = element.time;
                this.color.deserialize(element.color);
                return this;
            };
            return GradientColorKey;
        }());
        particle.GradientColorKey = GradientColorKey;
        __reflect(GradientColorKey.prototype, "egret3d.particle.GradientColorKey", ["paper.ISerializable"]);
        /**
         * TODO
         */
        var GradientAlphaKey = (function () {
            function GradientAlphaKey() {
                this.time = 0.0;
                this.alpha = 0.0;
            }
            GradientAlphaKey.prototype.serialize = function () {
                return { time: this.time, alpha: this.alpha };
            };
            GradientAlphaKey.prototype.deserialize = function (element) {
                this.alpha = element.alpha;
                this.time = element.time;
                return this;
            };
            return GradientAlphaKey;
        }());
        particle.GradientAlphaKey = GradientAlphaKey;
        __reflect(GradientAlphaKey.prototype, "egret3d.particle.GradientAlphaKey", ["paper.ISerializable"]);
        /**
         * TODO
         */
        var Gradient = (function () {
            function Gradient() {
                this.mode = 0 /* Blend */;
                this.alphaKeys = new Array();
                this.colorKeys = new Array();
                this._alphaValue = new Float32Array(8);
                this._colorValue = new Float32Array(16);
            }
            Gradient.prototype.serialize = function () {
                // TODO 导出数据应和 mode 有关，但编辑器需要全数据，需要区分出发布数据和编辑器全数据。
                return {
                    mode: this.mode,
                    alphaKeys: this.alphaKeys.map(function (v) { return v.serialize(); }),
                    colorKeys: this.colorKeys.map(function (v) { return v.serialize(); }),
                };
            };
            Gradient.prototype.deserialize = function (element) {
                this.colorKeys.length = 0;
                for (var i = 0, l = element.colorKeys.length; i < l; i++) {
                    var color = new GradientColorKey();
                    color.deserialize(element.colorKeys[i]);
                    this.colorKeys.push(color);
                }
                //
                this.alphaKeys.length = 0;
                for (var i = 0, l = element.alphaKeys.length; i < l; i++) {
                    var alpha = new GradientAlphaKey();
                    alpha.deserialize(element.alphaKeys[i]);
                    this.alphaKeys.push(alpha);
                }
                return this;
            };
            Gradient.prototype.evaluate = function (t, out) {
                if (t === void 0) { t = 0; }
                for (var i = 0, l = this.alphaKeys.length; i < l; i++) {
                    var curKeyFrame = this.alphaKeys[i];
                    if (curKeyFrame.time > t) {
                        var lastIndex = i === 0 ? 0 : i - 1;
                        var lastKeyFrame = this.alphaKeys[lastIndex];
                        var tt = (t - lastKeyFrame.time) / (curKeyFrame.time - lastKeyFrame.time);
                        out.a = egret3d.math.lerp(lastKeyFrame.alpha, curKeyFrame.alpha, tt);
                        break;
                    }
                }
                for (var i = 0, l = this.colorKeys.length; i < l; i++) {
                    var colorKey = this.colorKeys[i];
                    if (colorKey.time > t) {
                        var lastIndex = i === 0 ? 0 : i - 1;
                        var lastKeyFrame = this.colorKeys[lastIndex];
                        var tt = (t - lastKeyFrame.time) / (colorKey.time - lastKeyFrame.time);
                        out.r = egret3d.math.lerp(lastKeyFrame.color.r, colorKey.color.r, tt);
                        out.g = egret3d.math.lerp(lastKeyFrame.color.g, colorKey.color.g, tt);
                        out.b = egret3d.math.lerp(lastKeyFrame.color.b, colorKey.color.b, tt);
                        break;
                    }
                }
                return out;
            };
            Object.defineProperty(Gradient.prototype, "alphaValues", {
                get: function () {
                    var res = this._alphaValue;
                    var offset = 0;
                    for (var _i = 0, _a = this.alphaKeys; _i < _a.length; _i++) {
                        var alpha = _a[_i];
                        res[offset++] = alpha.time;
                        res[offset++] = alpha.alpha;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Gradient.prototype, "colorValues", {
                get: function () {
                    var res = this._colorValue;
                    var offset = 0;
                    for (var _i = 0, _a = this.colorKeys; _i < _a.length; _i++) {
                        var color = _a[_i];
                        res[offset++] = color.time;
                        res[offset++] = color.color.r;
                        res[offset++] = color.color.g;
                        res[offset++] = color.color.b;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            return Gradient;
        }());
        particle.Gradient = Gradient;
        __reflect(Gradient.prototype, "egret3d.particle.Gradient", ["paper.ISerializable"]);
        /**
         * TODO create
         */
        var MinMaxCurve = (function () {
            function MinMaxCurve() {
                this.mode = 0 /* Constant */;
                this.constant = 0.0;
                this.constantMin = 0.0;
                this.constantMax = 1.0;
                this.curve = new AnimationCurve();
                this.curveMin = new AnimationCurve();
                this.curveMax = new AnimationCurve();
            }
            MinMaxCurve.prototype.serialize = function () {
                return {
                    mode: this.mode,
                    constant: this.constant,
                    constantMin: this.constantMin,
                    constantMax: this.constantMax,
                    curve: this.curve.serialize(),
                    curveMin: this.curveMin.serialize(),
                    curveMax: this.curveMax.serialize(),
                };
            };
            MinMaxCurve.prototype.deserialize = function (element) {
                // 该兼容代码可以在插件导出全数据后移除。
                this.mode = element.mode;
                this.constant = element.constant || 0;
                this.constantMin = element.constantMin || 0;
                this.constantMax = element.constantMax || 0;
                element.curve && this.curve.deserialize(element.curve);
                element.curveMin && this.curveMin.deserialize(element.curveMin);
                element.curveMax && this.curveMax.deserialize(element.curveMax);
                return this;
            };
            MinMaxCurve.prototype.evaluate = function (t) {
                if (t === void 0) { t = 0; }
                if (this.mode === 0 /* Constant */) {
                    return this.constant;
                }
                else if (this.mode === 3 /* TwoConstants */) {
                    return (Math.random() * (this.constantMax - this.constantMin) + this.constantMin);
                }
                else if (this.mode === 1 /* Curve */) {
                    return this.curve.evaluate(t);
                }
                else {
                    var min = this.curveMin.evaluate(t);
                    var max = this.curveMax.evaluate(t);
                    return (Math.random() * (min - max) + min);
                }
            };
            MinMaxCurve.prototype.copy = function (source) {
                this.mode = source.mode;
                this.constant = source.constant;
                this.constantMin = source.constantMin;
                this.constantMax = source.constantMax;
                this.curve.copy(source.curve);
                this.curveMin.copy(source.curveMin);
                this.curveMax.copy(source.curveMax);
            };
            return MinMaxCurve;
        }());
        particle.MinMaxCurve = MinMaxCurve;
        __reflect(MinMaxCurve.prototype, "egret3d.particle.MinMaxCurve", ["paper.ISerializable"]);
        /**
         * TODO create
         */
        var MinMaxGradient = (function () {
            function MinMaxGradient() {
                this.mode = 1 /* Gradient */;
                this.color = egret3d.Color.create();
                this.colorMin = egret3d.Color.create();
                this.colorMax = egret3d.Color.create();
                this.gradient = new Gradient();
                this.gradientMin = new Gradient();
                this.gradientMax = new Gradient();
            }
            MinMaxGradient.prototype.serialize = function () {
                return {
                    mode: this.mode,
                    color: this.color.serialize(),
                    colorMin: this.colorMin.serialize(),
                    colorMax: this.colorMax.serialize(),
                    gradient: this.gradient.serialize(),
                    gradientMin: this.gradientMin.serialize(),
                    gradientMax: this.gradientMax.serialize(),
                };
            };
            MinMaxGradient.prototype.deserialize = function (element) {
                // 该兼容代码可以在插件导出全数据后移除。
                this.mode = element.mode;
                if (element.color) {
                    this.color.deserialize(element.color);
                }
                if (element.colorMin) {
                    this.colorMin.deserialize(element.colorMin);
                }
                if (element.colorMax) {
                    this.colorMax.deserialize(element.colorMax);
                }
                if (element.gradient) {
                    this.gradient.deserialize(element.gradient);
                }
                if (element.gradientMin) {
                    this.gradientMin.deserialize(element.gradientMin);
                }
                if (element.gradientMax) {
                    this.gradientMax.deserialize(element.gradientMax);
                }
                return this;
            };
            MinMaxGradient.prototype.evaluate = function (t, out) {
                if (t === void 0) { t = 0; }
                if (this.mode === 0 /* Color */) {
                    out.r = this.color.r;
                    out.g = this.color.g;
                    out.b = this.color.b;
                    out.a = this.color.a;
                }
                else if (this.mode === 2 /* TwoColors */) {
                    out.r = Math.random() * (this.colorMax.r - this.colorMin.r) + this.colorMin.r;
                    out.g = Math.random() * (this.colorMax.g - this.colorMin.g) + this.colorMin.g;
                    out.b = Math.random() * (this.colorMax.b - this.colorMin.b) + this.colorMin.b;
                    out.a = Math.random() * (this.colorMax.a - this.colorMin.a) + this.colorMin.a;
                }
                else if (this.mode === 1 /* Gradient */) {
                    return this.gradient.evaluate(t, out);
                }
                else if (this.mode === 3 /* TwoGradients */) {
                    this.gradientMin.evaluate(t, _helpColorA);
                    this.gradientMax.evaluate(t, _helpColorB);
                    out.r = (Math.random() * (_helpColorA.r - _helpColorB.r) + _helpColorA.r);
                    out.g = (Math.random() * (_helpColorA.g - _helpColorB.g) + _helpColorA.g);
                    out.b = (Math.random() * (_helpColorA.b - _helpColorB.b) + _helpColorA.b);
                    out.a = (Math.random() * (_helpColorA.a - _helpColorB.a) + _helpColorA.a);
                }
                else {
                    out.r = Math.random();
                    out.g = Math.random();
                    out.b = Math.random();
                    out.a = Math.random();
                }
                return out;
            };
            return MinMaxGradient;
        }());
        particle.MinMaxGradient = MinMaxGradient;
        __reflect(MinMaxGradient.prototype, "egret3d.particle.MinMaxGradient", ["paper.ISerializable"]);
        /**
         * 粒子模块基类。
         */
        var ParticleModule = (function (_super) {
            __extends(ParticleModule, _super);
            function ParticleModule(component) {
                var _this = _super.call(this) || this;
                _this.enable = false;
                _this._component = component;
                return _this;
            }
            ParticleModule.prototype.deserialize = function (_element) {
                this.enable = true;
                return this;
            };
            __decorate([
                paper.serializedField
            ], ParticleModule.prototype, "enable", void 0);
            return ParticleModule;
        }(paper.BaseObject));
        particle.ParticleModule = ParticleModule;
        __reflect(ParticleModule.prototype, "egret3d.particle.ParticleModule");
        /**
         *
         */
        var MainModule = (function (_super) {
            __extends(MainModule, _super);
            function MainModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 *
                 */
                _this.loop = false;
                /**
                 *
                 */
                _this.playOnAwake = false;
                /**
                 *
                 */
                _this.duration = 0.0;
                /**
                 *
                 */
                _this.startDelay = new MinMaxCurve();
                /**
                 *
                 */
                _this.startLifetime = new MinMaxCurve();
                /**
                 *
                 */
                _this.startSpeed = new MinMaxCurve();
                /**
                 *
                 */
                _this.startSizeX = new MinMaxCurve();
                /**
                 *
                 */
                _this.startSizeY = new MinMaxCurve();
                /**
                 *
                 */
                _this.startSizeZ = new MinMaxCurve();
                /**
                 *
                 */
                _this.startRotationX = new MinMaxCurve();
                /**
                 *
                 */
                _this.startRotationY = new MinMaxCurve();
                /**
                 *
                 */
                _this.startRotationZ = new MinMaxCurve();
                /**
                 *
                 */
                _this.startColor = new MinMaxGradient();
                /**
                 *
                 */
                _this.gravityModifier = new MinMaxCurve(); //TODO
                _this._startSize3D = false;
                _this._startRotation3D = false;
                _this._simulationSpace = 0 /* Local */;
                _this._scaleMode = 0 /* Hierarchy */;
                _this._maxParticles = 0;
                return _this;
            }
            MainModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.duration = element.duration;
                this.loop = element.loop || element.looping; // TODO 兼容代码 looping。
                this.startDelay.deserialize(element.startDelay);
                this.startLifetime.deserialize(element.startLifetime);
                this.startSpeed.deserialize(element.startSpeed);
                this._startSize3D = element.startSize3D || false;
                this.startSizeX.deserialize(element.startSizeX);
                this.startSizeY.deserialize(element.startSizeY);
                this.startSizeZ.deserialize(element.startSizeZ);
                this._startRotation3D = (element._startRotation3D || element.startRotation3D) || false;
                this.startRotationX.deserialize(element.startRotationX);
                this.startRotationY.deserialize(element.startRotationY);
                this.startRotationZ.deserialize(element.startRotationZ);
                this.startColor.deserialize(element.startColor);
                this.gravityModifier.deserialize(element.gravityModifier);
                this._simulationSpace = (element._simulationSpace || element.simulationSpace) || 0;
                this._scaleMode = (element._scaleMode || element.scaleMode) || 0 /* Hierarchy */;
                this.playOnAwake = element.playOnAwake;
                this._maxParticles = (element._maxParticles || element.maxParticles) || 0;
                return this;
            };
            Object.defineProperty(MainModule.prototype, "startSize3D", {
                get: function () {
                    return this._startSize3D;
                },
                set: function (value) {
                    if (this._startSize3D === value) {
                        return;
                    }
                    this._startSize3D = value;
                    particle.onStartSize3DChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "startRotation3D", {
                /**
                 *
                 */
                get: function () {
                    return this._startRotation3D;
                },
                set: function (value) {
                    if (this._startRotation3D === value) {
                        return;
                    }
                    this._startRotation3D = value;
                    particle.onStartRotation3DChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "simulationSpace", {
                /**
                 *
                 */
                get: function () {
                    return this._simulationSpace;
                },
                set: function (value) {
                    if (this._simulationSpace === value) {
                        return;
                    }
                    this._simulationSpace = value;
                    particle.onSimulationSpaceChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "scaleMode", {
                /**
                 *
                 */
                get: function () {
                    return this._scaleMode;
                },
                set: function (value) {
                    if (this._scaleMode === value) {
                        return;
                    }
                    this._scaleMode = value;
                    particle.onScaleModeChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "maxParticles", {
                /**
                 *
                 */
                get: function () {
                    return this._maxParticles;
                },
                set: function (value) {
                    if (this._maxParticles === value) {
                        return;
                    }
                    this._maxParticles = value;
                    particle.onMaxParticlesChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "loop", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "playOnAwake", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "duration", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startDelay", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startLifetime", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSpeed", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSizeX", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSizeY", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSizeZ", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startRotationX", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startRotationY", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startRotationZ", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startColor", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "gravityModifier", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_startSize3D", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_startRotation3D", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_simulationSpace", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_scaleMode", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_maxParticles", void 0);
            return MainModule;
        }(ParticleModule));
        particle.MainModule = MainModule;
        __reflect(MainModule.prototype, "egret3d.particle.MainModule");
        /**
         *
         */
        var EmissionModule = (function (_super) {
            __extends(EmissionModule, _super);
            function EmissionModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 *
                 */
                _this.rateOverTime = new MinMaxCurve();
                /**
                 *
                 */
                _this.bursts = [];
                return _this;
            }
            EmissionModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.rateOverTime.deserialize(element.rateOverTime);
                if (element.bursts) {
                    this.bursts.length = 0;
                    for (var i = 0, l = element.bursts.length; i < l; i++) {
                        var burst = new Burst();
                        burst.deserialize(element.bursts[i]);
                        this.bursts.push(burst);
                    }
                }
                return this;
            };
            __decorate([
                paper.serializedField
            ], EmissionModule.prototype, "rateOverTime", void 0);
            __decorate([
                paper.serializedField
            ], EmissionModule.prototype, "bursts", void 0);
            return EmissionModule;
        }(ParticleModule));
        particle.EmissionModule = EmissionModule;
        __reflect(EmissionModule.prototype, "egret3d.particle.EmissionModule");
        /**
         *
         */
        var ShapeModule = (function (_super) {
            __extends(ShapeModule, _super);
            function ShapeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 *
                 */
                _this.shapeType = 0 /* Sphere */;
                /**
                 *
                 */
                _this.radius = 0.0;
                /**
                 *
                 */
                _this.angle = 0.0;
                /**
                 *
                 */
                _this.length = 0.0;
                /**
                 *
                 */
                _this.arcSpeed = new MinMaxCurve();
                /**
                 *
                 */
                _this.arcMode = 0 /* Random */;
                _this.arc = 0.0;
                /**
                 *
                 */
                _this.radiusSpread = 0.0;
                /**
                 *
                 */
                _this.radiusMode = 0 /* Random */;
                /**
                 *
                 */
                _this.box = egret3d.Vector3.create();
                /**
                 *
                 */
                _this.randomDirection = false;
                /**
                 *
                 */
                _this.spherizeDirection = false;
                return _this;
            }
            ShapeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.shapeType = element.shapeType;
                this.radius = element.radius;
                this.angle = element.angle;
                this.length = element.length;
                this.arc = element.arc || 0.0;
                this.arcSpeed.deserialize(element.arcSpeed);
                this.arcMode = element.arcMode;
                this.radiusSpread = element.radiusSpread;
                this.radiusMode = element.radiusMode;
                this.box.deserialize(element.box);
                this.randomDirection = element.randomDirection;
                this.spherizeDirection = element.spherizeDirection;
                return this;
            };
            /**
             * @internal
             */
            ShapeModule.prototype.invalidUpdate = function () {
                particle.onShapeChanged.dispatch(this._component);
            };
            /**
             * @internal
             */
            ShapeModule.prototype.generatePositionAndDirection = function (position, direction) {
                particle.generatePositionAndDirection(position, direction, this);
            };
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "shapeType", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "radius", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "angle", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "length", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "arcSpeed", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "arcMode", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "arc", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "radiusSpread", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "radiusMode", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "box", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "randomDirection", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "spherizeDirection", void 0);
            return ShapeModule;
        }(ParticleModule));
        particle.ShapeModule = ShapeModule;
        __reflect(ShapeModule.prototype, "egret3d.particle.ShapeModule");
        /**
         *
         */
        var VelocityOverLifetimeModule = (function (_super) {
            __extends(VelocityOverLifetimeModule, _super);
            function VelocityOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._mode = 0 /* Constant */;
                _this._space = 0 /* Local */;
                _this._x = new MinMaxCurve();
                _this._y = new MinMaxCurve();
                _this._z = new MinMaxCurve();
                return _this;
            }
            VelocityOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._mode = (element._mode || element.mode) || 0 /* Constant */;
                this._space = (element._space || element.space) || 0 /* Local */;
                this._x.deserialize(element._x || element.x);
                this._y.deserialize(element._y || element.y);
                this._z.deserialize(element._z || element.z);
                return this;
            };
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "mode", {
                /**
                 *
                 */
                get: function () {
                    return this._mode;
                },
                set: function (value) {
                    if (this._mode === value) {
                        return;
                    }
                    this._mode = value;
                    particle.onVelocityChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "space", {
                /**
                 *
                 */
                get: function () {
                    return this._space;
                },
                set: function (value) {
                    if (this._space === value) {
                        return;
                    }
                    this._space = value;
                    particle.onVelocityChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "x", {
                /**
                 *
                 */
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    this._x.copy(value);
                    particle.onVelocityChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "y", {
                /**
                 *
                 */
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    this._y.copy(value);
                    particle.onVelocityChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "z", {
                /**
                 *
                 */
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    this._z.copy(value);
                    particle.onVelocityChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_mode", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_space", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_x", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_y", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_z", void 0);
            return VelocityOverLifetimeModule;
        }(ParticleModule));
        particle.VelocityOverLifetimeModule = VelocityOverLifetimeModule;
        __reflect(VelocityOverLifetimeModule.prototype, "egret3d.particle.VelocityOverLifetimeModule");
        /**
         *
         */
        var ColorOverLifetimeModule = (function (_super) {
            __extends(ColorOverLifetimeModule, _super);
            function ColorOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._color = new MinMaxGradient(); // TODO readonly
                return _this;
            }
            ColorOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._color.deserialize(element._color || element.color);
                return this;
            };
            Object.defineProperty(ColorOverLifetimeModule.prototype, "color", {
                /**
                 *
                 */
                get: function () {
                    return this._color;
                },
                set: function (value) {
                    this._color = value; // TODO copy
                    particle.onColorChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ColorOverLifetimeModule.prototype, "_color", void 0);
            return ColorOverLifetimeModule;
        }(ParticleModule));
        particle.ColorOverLifetimeModule = ColorOverLifetimeModule;
        __reflect(ColorOverLifetimeModule.prototype, "egret3d.particle.ColorOverLifetimeModule");
        /**
         *
         */
        var SizeOverLifetimeModule = (function (_super) {
            __extends(SizeOverLifetimeModule, _super);
            function SizeOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._separateAxes = false;
                _this._size = new MinMaxCurve();
                _this._x = new MinMaxCurve();
                _this._y = new MinMaxCurve();
                _this._z = new MinMaxCurve();
                return _this;
            }
            SizeOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._separateAxes = (element._separateAxes || element.separateAxes) || false;
                this._size.deserialize(element._size || element.size);
                this._x.deserialize(element._x || element.x);
                this._y.deserialize(element._y || element.y);
                this._z.deserialize(element._z || element.z);
                return this;
            };
            Object.defineProperty(SizeOverLifetimeModule.prototype, "separateAxes", {
                /**
                 *
                 */
                get: function () {
                    return this._separateAxes;
                },
                set: function (value) {
                    if (this._separateAxes === value) {
                        return;
                    }
                    this._separateAxes = value;
                    particle.onSizeChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "size", {
                /**
                 *
                 */
                get: function () {
                    return this._size;
                },
                set: function (value) {
                    this._size.copy(value);
                    particle.onSizeChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "x", {
                /**
                 *
                 */
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    this._x.copy(value);
                    particle.onSizeChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "y", {
                /**
                 *
                 */
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    this._y.copy(value);
                    particle.onSizeChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "z", {
                /**
                 *
                 */
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    this._z.copy(value);
                    particle.onSizeChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_separateAxes", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_size", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_x", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_y", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_z", void 0);
            return SizeOverLifetimeModule;
        }(ParticleModule));
        particle.SizeOverLifetimeModule = SizeOverLifetimeModule;
        __reflect(SizeOverLifetimeModule.prototype, "egret3d.particle.SizeOverLifetimeModule");
        /**
         *
         */
        var RotationOverLifetimeModule = (function (_super) {
            __extends(RotationOverLifetimeModule, _super);
            function RotationOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._separateAxes = false;
                _this._x = new MinMaxCurve();
                _this._y = new MinMaxCurve();
                _this._z = new MinMaxCurve();
                return _this;
            }
            RotationOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._separateAxes = (element._separateAxes || element.separateAxes) || false;
                this._x.deserialize(element._x || element.x);
                this._y.deserialize(element._y || element.y);
                this._z.deserialize(element._z || element.z);
                return this;
            };
            Object.defineProperty(RotationOverLifetimeModule.prototype, "separateAxes", {
                /**
                 *
                 */
                get: function () {
                    return this._separateAxes;
                },
                set: function (value) {
                    if (this._separateAxes === value) {
                        return;
                    }
                    this._separateAxes = value;
                    particle.onRotationChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RotationOverLifetimeModule.prototype, "x", {
                /**
                 *
                 */
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    this._x.copy(value);
                    particle.onRotationChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RotationOverLifetimeModule.prototype, "y", {
                /**
                 *
                 */
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    this._y.copy(value);
                    particle.onRotationChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RotationOverLifetimeModule.prototype, "z", {
                /**
                 *
                 */
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    this._z.copy(value);
                    particle.onRotationChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_separateAxes", void 0);
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_x", void 0);
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_y", void 0);
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_z", void 0);
            return RotationOverLifetimeModule;
        }(ParticleModule));
        particle.RotationOverLifetimeModule = RotationOverLifetimeModule;
        __reflect(RotationOverLifetimeModule.prototype, "egret3d.particle.RotationOverLifetimeModule");
        /**
         *
         */
        var TextureSheetAnimationModule = (function (_super) {
            __extends(TextureSheetAnimationModule, _super);
            function TextureSheetAnimationModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._useRandomRow = false;
                _this._animation = 0 /* WholeSheet */;
                _this._numTilesX = 1;
                _this._numTilesY = 1;
                _this._cycleCount = 1;
                _this._rowIndex = 0;
                _this._frameOverTime = new MinMaxCurve();
                _this._startFrame = new MinMaxCurve();
                _this._floatValues = new Float32Array(4);
                return _this;
            }
            TextureSheetAnimationModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._numTilesX = (element._numTilesX || element.numTilesX) || 0;
                this._numTilesY = (element._numTilesY || element.numTilesY) || 0;
                this._animation = (element._animation || element.animation) || 0 /* WholeSheet */;
                this._useRandomRow = (element._useRandomRow || element.useRandomRow) || false;
                this._frameOverTime.deserialize(element._frameOverTime || element.frameOverTime);
                this._startFrame.deserialize(element._startFrame || element.startFrame);
                this._cycleCount = (element._cycleCount || element.cycleCount) || 0;
                this._rowIndex = (element._rowIndex || element.rowIndex) || 0;
                return this;
            };
            Object.defineProperty(TextureSheetAnimationModule.prototype, "numTilesX", {
                /**
                 *
                 */
                get: function () {
                    return this._numTilesX;
                },
                set: function (value) {
                    if (this._numTilesX === value) {
                        return;
                    }
                    this._numTilesX = value;
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "numTilesY", {
                /**
                 *
                 */
                get: function () {
                    return this._numTilesY;
                },
                set: function (value) {
                    if (this._numTilesY === value) {
                        return;
                    }
                    this._numTilesY = value;
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "animation", {
                /**
                 *
                 */
                get: function () {
                    return this._animation;
                },
                set: function (value) {
                    if (this._animation === value) {
                        return;
                    }
                    this._animation = value;
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "useRandomRow", {
                /**
                 *
                 */
                get: function () {
                    return this._useRandomRow;
                },
                set: function (value) {
                    if (this._useRandomRow === value) {
                        return;
                    }
                    this._useRandomRow = value;
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "frameOverTime", {
                /**
                 *
                 */
                get: function () {
                    return this._frameOverTime;
                },
                set: function (value) {
                    this._frameOverTime.copy(value);
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "startFrame", {
                /**
                 *
                 */
                get: function () {
                    return this._startFrame;
                },
                set: function (value) {
                    this._startFrame.copy(value);
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "cycleCount", {
                /**
                 *
                 */
                get: function () {
                    return this._cycleCount;
                },
                set: function (value) {
                    if (this._cycleCount === value) {
                        return;
                    }
                    this._cycleCount = value;
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "rowIndex", {
                /**
                 *
                 */
                get: function () {
                    return this._rowIndex;
                },
                set: function (value) {
                    if (this._rowIndex === value) {
                        return;
                    }
                    this._rowIndex = value;
                    particle.onTextureSheetChanged.dispatch(this._component);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "floatValues", {
                get: function () {
                    var res = this._floatValues;
                    if (this.enable) {
                        var subU = 1.0 / this._numTilesX;
                        var subV = 1.0 / this._numTilesY;
                        var startFrmaeCount = Math.floor(this._startFrame.constant);
                        var startRow = 0;
                        switch (this._animation) {
                            case 1 /* SingleRow */:
                                {
                                    if (this._useRandomRow) {
                                        startRow = Math.floor(Math.random() * this._numTilesY);
                                    }
                                    else {
                                        startRow = this._rowIndex;
                                    }
                                    break;
                                }
                            case 0 /* WholeSheet */:
                                {
                                    startRow = Math.floor(startFrmaeCount / this._numTilesX);
                                    break;
                                }
                        }
                        var startCol = Math.floor(startFrmaeCount % this._numTilesX);
                        res[0] = subU;
                        res[1] = subV;
                        res[2] = startCol * subU;
                        res[3] = startRow * subV;
                    }
                    else {
                        res[0] = 1.0;
                        res[1] = 1.0;
                        res[2] = 0.0;
                        res[3] = 0.0;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_useRandomRow", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_animation", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_numTilesX", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_numTilesY", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_cycleCount", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_rowIndex", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_frameOverTime", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_startFrame", void 0);
            return TextureSheetAnimationModule;
        }(ParticleModule));
        particle.TextureSheetAnimationModule = TextureSheetAnimationModule;
        __reflect(TextureSheetAnimationModule.prototype, "egret3d.particle.TextureSheetAnimationModule");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        //
        var positionHelper = new egret3d.Vector3();
        var velocityHelper = new egret3d.Vector3();
        var startSizeHelper = new egret3d.Vector3();
        var startColorHelper = egret3d.Color.create();
        var startRotationHelper = new egret3d.Vector3();
        var GRAVITY = new egret3d.Vector3(0, -9.81, 0); //TODO没有物理系统，暂时先放到这里
        /**
         * @internal
         */
        var ParticleBatcher = (function () {
            function ParticleBatcher() {
                this._dirty = false;
                this._time = 0.0;
                this._emittsionTime = 0;
                this._frameRateTime = 0;
                //最新存活位置
                this._firstAliveCursor = 0;
                this._lastFrameFirstCursor = 0;
                //最后存活位置
                this._lastAliveCursor = 0;
                this._forceUpdate = false;
                //原始顶点数量
                this._vertexStride = 0;
                //当前爆发的索引
                this._burstIndex = 0;
                //
                this._readEmitCount = 0;
                //最终重力
                this._finalGravity = new egret3d.Vector3();
                this._worldPostionCache = egret3d.Vector3.create();
                this._worldRotationCache = egret3d.Quaternion.create();
            }
            /**
            * 计算粒子爆发数量
            * @param startTime
            * @param endTime
            */
            ParticleBatcher.prototype._getBurstCount = function (startTime, endTime) {
                var totalEmitCount = 0;
                var bursts = this._comp.emission.bursts;
                for (var l = bursts.length; this._burstIndex < l; this._burstIndex++) {
                    var burst = bursts[this._burstIndex];
                    if (burst.time >= startTime && burst.time < endTime) {
                        // totalEmitCount += numberLerp(burst.minCount, burst.maxCount, Math.random());
                        totalEmitCount += burst.maxCount;
                    }
                    else {
                        break;
                    }
                }
                return totalEmitCount;
            };
            /**
             * 判断粒子是否已经过期
             * @param particleIndex
             */
            ParticleBatcher.prototype._isParticleExpired = function (particleIndex) {
                var startTimeOffset = particleIndex * this._vertexStride * 2;
                return this._time - this._startTimeBuffer[startTimeOffset + 1] + 0.0001 > this._startTimeBuffer[startTimeOffset];
            };
            /**
             *
             * @param time 批量增加粒子
             * @param startCursor
             * @param endCursor
             */
            ParticleBatcher.prototype._addParticles = function (time, startCursor, count, lastEmittsionTime) {
                var comp = this._comp;
                var main = comp.main;
                var velocityModule = comp.velocityOverLifetime;
                var colorModule = comp.colorOverLifetime;
                var sizeModule = comp.sizeOverLifetime;
                var rotationModule = comp.rotationOverLifetime;
                var textureSheetModule = comp.textureSheetAnimation;
                var isVelocityRandom = velocityModule.enable && (velocityModule.mode === 3 /* TwoConstants */ || velocityModule.mode === 2 /* TwoCurves */);
                var isColorRandom = colorModule.enable && colorModule.color.mode === 3 /* TwoGradients */;
                var isSizeRandom = sizeModule.enable && (sizeModule.size.mode === 3 /* TwoConstants */ || sizeModule.size.mode === 2 /* TwoCurves */);
                var isRotationRandom = rotationModule.enable && (rotationModule.x.mode === 3 /* TwoConstants */ || rotationModule.x.mode === 2 /* TwoCurves */);
                var isTextureRandom = textureSheetModule.enable && (textureSheetModule.startFrame.mode === 3 /* TwoConstants */ || textureSheetModule.startFrame.mode === 2 /* TwoCurves */);
                var needRandom0 = isColorRandom || isSizeRandom || isRotationRandom || isTextureRandom;
                var worldPosition = this._worldPostionCache;
                var worldRotation = this._worldRotationCache;
                var isWorldSpace = main.simulationSpace === 1 /* World */;
                var startPositionBuffer = this._startPositionBuffer;
                var startVelocityBuffer = this._startVelocityBuffer;
                var startColorBuffer = this._startColorBuffer;
                var startSizeBuffer = this._startSizeBuffer;
                var startRotationBuffer = this._startRotationBuffer;
                var startTimeBuffer = this._startTimeBuffer;
                var random0Buffer = this._random0Buffer;
                var random1Buffer = this._random1Buffer;
                var worldPostionBuffer = this._worldPostionBuffer;
                var worldRoationBuffer = this._worldRoationBuffer;
                var isSize3D = main.startSize3D;
                var isRotation3D = main.startRotation3D;
                var age = Math.min(lastEmittsionTime / main.duration, 1.0);
                var vertexStride = this._vertexStride;
                var addCount = 0, startIndex = 0, endIndex = 0;
                var lifetime = 0.0;
                var startSpeed = 0.0;
                var startSize = 0.0;
                var randomVelocityX = 0.0, randomVelocityY = 0.0, randomVelocityZ = 0.0;
                var randomColor = 0.0, randomSize = 0.0, randomRotation = 0.0, randomTextureAnimation = 0.0;
                var vector2Offset = 0, vector3Offset = 0, vector4Offset = 0;
                while (addCount !== count) {
                    comp.shape.generatePositionAndDirection(positionHelper, velocityHelper);
                    main.startColor.evaluate(age, startColorHelper);
                    lifetime = main.startLifetime.evaluate(age);
                    startSpeed = main.startSpeed.evaluate(age);
                    velocityHelper.x *= startSpeed;
                    velocityHelper.y *= startSpeed;
                    velocityHelper.z *= startSpeed;
                    if (isSize3D) {
                        startSizeHelper.x = main.startSizeX.evaluate(age);
                        startSizeHelper.y = main.startSizeY.evaluate(age);
                        startSizeHelper.z = main.startSizeZ.evaluate(age);
                    }
                    else {
                        startSize = main.startSizeX.evaluate(age);
                        startSizeHelper.x = startSize;
                        startSizeHelper.y = startSize;
                        startSizeHelper.z = startSize;
                    }
                    if (isRotation3D) {
                        startRotationHelper.x = main.startRotationX.evaluate(age);
                        startRotationHelper.y = main.startRotationY.evaluate(age);
                        startRotationHelper.z = main.startRotationZ.evaluate(age);
                    }
                    else {
                        startRotationHelper.x = main.startRotationX.evaluate(age);
                    }
                    randomVelocityX = isVelocityRandom ? Math.random() : 0.0;
                    randomVelocityY = isVelocityRandom ? Math.random() : 0.0;
                    randomVelocityZ = isVelocityRandom ? Math.random() : 0.0;
                    randomColor = isColorRandom ? Math.random() : 0.0;
                    randomSize = isSizeRandom ? Math.random() : 0.0;
                    randomRotation = isRotationRandom ? Math.random() : 0.0;
                    randomTextureAnimation = isTextureRandom ? Math.random() : 0.0;
                    for (startIndex = startCursor * vertexStride, endIndex = startIndex + vertexStride; startIndex < endIndex; startIndex++) {
                        vector2Offset = startIndex * 2;
                        vector3Offset = startIndex * 3;
                        vector4Offset = startIndex * 4;
                        //
                        startPositionBuffer[vector3Offset] = positionHelper.x;
                        startPositionBuffer[vector3Offset + 1] = positionHelper.y;
                        startPositionBuffer[vector3Offset + 2] = positionHelper.z;
                        startVelocityBuffer[vector3Offset] = velocityHelper.x;
                        startVelocityBuffer[vector3Offset + 1] = velocityHelper.y;
                        startVelocityBuffer[vector3Offset + 2] = velocityHelper.z;
                        startColorBuffer[vector4Offset] = startColorHelper.r;
                        startColorBuffer[vector4Offset + 1] = startColorHelper.g;
                        startColorBuffer[vector4Offset + 2] = startColorHelper.b;
                        startColorBuffer[vector4Offset + 3] = startColorHelper.a;
                        startSizeBuffer[vector3Offset] = startSizeHelper.x;
                        startSizeBuffer[vector3Offset + 1] = startSizeHelper.y;
                        startSizeBuffer[vector3Offset + 2] = startSizeHelper.z;
                        startRotationBuffer[vector3Offset] = startRotationHelper.x;
                        startRotationBuffer[vector3Offset + 1] = startRotationHelper.y;
                        startRotationBuffer[vector3Offset + 2] = startRotationHelper.z;
                        startTimeBuffer[vector2Offset] = lifetime;
                        startTimeBuffer[vector2Offset + 1] = time;
                        //
                        if (needRandom0) {
                            random0Buffer[vector4Offset] = randomColor;
                            random0Buffer[vector4Offset + 1] = randomSize;
                            random0Buffer[vector4Offset + 2] = randomRotation;
                            random0Buffer[vector4Offset + 3] = randomTextureAnimation;
                        }
                        if (isVelocityRandom) {
                            random1Buffer[vector4Offset] = randomVelocityX;
                            random1Buffer[vector4Offset + 1] = randomVelocityY;
                            random1Buffer[vector4Offset + 2] = randomVelocityZ;
                            random1Buffer[vector4Offset + 3] = 0;
                        }
                        if (isWorldSpace) {
                            worldPostionBuffer[vector3Offset] = worldPosition.x;
                            worldPostionBuffer[vector3Offset + 1] = worldPosition.y;
                            worldPostionBuffer[vector3Offset + 2] = worldPosition.z;
                            worldRoationBuffer[vector4Offset] = worldRotation.x;
                            worldRoationBuffer[vector4Offset + 1] = worldRotation.y;
                            worldRoationBuffer[vector4Offset + 2] = worldRotation.z;
                            worldRoationBuffer[vector4Offset + 3] = worldRotation.w;
                        }
                    }
                    startCursor++;
                    if (startCursor >= main.maxParticles) {
                        startCursor = 0;
                    }
                    addCount++;
                }
                //TODO理论上应该是每帧更新，不过现在没有物理系统，先放到这里
                var gravityModifier = main.gravityModifier.constant;
                this._finalGravity.x = GRAVITY.x * gravityModifier;
                this._finalGravity.y = GRAVITY.y * gravityModifier;
                this._finalGravity.z = GRAVITY.z * gravityModifier;
            };
            ParticleBatcher.prototype._tryEmit = function () {
                if (!this._isParticleExpired(this._firstAliveCursor)) {
                    return false;
                }
                //
                var maxParticles = this._comp.main.maxParticles;
                var nextCursor = this._firstAliveCursor + 1 >= maxParticles ? 0 : this._firstAliveCursor + 1;
                //
                if (nextCursor === this._lastAliveCursor) {
                    this._forceUpdate = true;
                }
                this._firstAliveCursor = nextCursor;
                return true;
            };
            ParticleBatcher.prototype.clean = function () {
                this._time = 0.0;
                this._dirty = false;
                this._emittsionTime = 0.0;
                this._frameRateTime = 0.0;
                this._firstAliveCursor = 0;
                this._lastFrameFirstCursor = 0;
                this._lastAliveCursor = 0;
                this._forceUpdate = false;
                this._vertexStride = 0;
                this._vertexAttributes = null;
                this._burstIndex = 0;
                this._readEmitCount = 0;
                this._startPositionBuffer = null;
                this._startVelocityBuffer = null;
                this._startColorBuffer = null;
                this._startSizeBuffer = null;
                this._startRotationBuffer = null;
                this._startTimeBuffer = null;
                this._random0Buffer = null;
                this._random1Buffer = null;
                this._worldPostionBuffer = null;
                this._worldRoationBuffer = null;
                // this._worldPostionCache = null!;
                // this._worldRotationCache = null!;
                this._comp = null;
                this._renderer = null;
            };
            ParticleBatcher.prototype.resetTime = function () {
                this._burstIndex = 0;
                this._emittsionTime = 0;
                this._readEmitCount = 0;
            };
            ParticleBatcher.prototype.init = function (comp, renderer) {
                this._comp = comp;
                this._renderer = renderer;
                var mesh = renderer.batchMesh ? renderer.batchMesh : particle.createBatchMesh(renderer, comp.main.maxParticles); //TODO .retain()
                this._vertexStride = renderer.renderMode === 4 /* Mesh */ ? renderer.mesh.vertexCount : 4;
                this._startPositionBuffer = mesh.getAttributes("_START_POSITION" /* _START_POSITION */);
                this._startVelocityBuffer = mesh.getAttributes("_START_VELOCITY" /* _START_VELOCITY */);
                this._startColorBuffer = mesh.getAttributes("_START_COLOR" /* _START_COLOR */);
                this._startSizeBuffer = mesh.getAttributes("_START_SIZE" /* _START_SIZE */);
                this._startRotationBuffer = mesh.getAttributes("_START_ROTATION" /* _START_ROTATION */);
                this._startTimeBuffer = mesh.getAttributes("_TIME" /* _TIME */);
                this._random0Buffer = mesh.getAttributes("_RANDOM0" /* _RANDOM0 */);
                this._random1Buffer = mesh.getAttributes("_RANDOM1" /* _RANDOM1 */);
                this._worldPostionBuffer = mesh.getAttributes("_WORLD_POSITION" /* _WORLD_POSITION */);
                this._worldRoationBuffer = mesh.getAttributes("_WORLD_ROTATION" /* _WORLD_ROTATION */);
                var primitive = mesh.glTFMesh.primitives[0];
                this._vertexAttributes = [];
                for (var k in primitive.attributes) {
                    this._vertexAttributes.push(k);
                }
                //
                for (var i = 0, l = this._startTimeBuffer.length; i < l; i++) {
                    this._startTimeBuffer[i] = 0.0;
                }
                renderer.batchMesh = mesh;
                if (!renderer.batchMaterial) {
                    renderer.batchMaterial = renderer.materials[0].clone().retain();
                }
                //刚创建的时候，vbo,ibo为空调用无效，只有active一直被交换设置，才会需要调用
                mesh.uploadSubIndexBuffer();
                mesh.uploadVertexBuffer();
            };
            ParticleBatcher.prototype.update = function (elapsedTime) {
                if (!this._comp || this._comp.isPaused) {
                    return;
                }
                //
                this._time += elapsedTime;
                var comp = this._comp;
                var mainModule = comp.main;
                //
                while (this._lastAliveCursor !== this._firstAliveCursor || this._forceUpdate) {
                    if (!this._isParticleExpired(this._lastAliveCursor)) {
                        break;
                    }
                    this._forceUpdate = false;
                    this._lastAliveCursor++;
                    if (this._lastAliveCursor >= mainModule.maxParticles) {
                        this._lastAliveCursor = 0;
                    }
                }
                var transform = comp.gameObject.transform;
                this._worldPostionCache.copy(transform.position);
                this._worldRotationCache.copy(transform.rotation);
                if (comp._isPlaying && this._time >= mainModule.startDelay.constant && comp.emission.enable) {
                    this._updateEmission(elapsedTime);
                }
                this._updateRender();
            };
            ParticleBatcher.prototype._updateEmission = function (elapsedTime) {
                var comp = this._comp;
                var mainModule = comp.main;
                var lastEmittsionTime = this._emittsionTime;
                this._emittsionTime += elapsedTime;
                var isOver = this._emittsionTime > mainModule.duration;
                var aliveParticleCount = this.aliveParticleCount;
                var totalEmitCount = 0;
                if (!isOver) {
                    if (comp.emission.bursts.length > 0) {
                        this._readEmitCount += this._getBurstCount(lastEmittsionTime, this._emittsionTime);
                    }
                }
                else {
                    if (mainModule.loop) {
                        this._readEmitCount = 0;
                        this._readEmitCount += this._getBurstCount(lastEmittsionTime, this._emittsionTime);
                        this._emittsionTime -= mainModule.duration;
                        this._burstIndex = 0;
                        this._readEmitCount += this._getBurstCount(0, this._emittsionTime);
                    }
                    else {
                        comp.stop(false);
                    }
                }
                //
                for (var i = 0, l = this._readEmitCount; i < l; i++) {
                    if (this._tryEmit()) {
                        totalEmitCount++;
                        this._readEmitCount--;
                    }
                }
                var rateOverTime = comp.emission.rateOverTime.constant;
                if (rateOverTime > 0) {
                    var minEmissionTime = 1 / rateOverTime;
                    this._frameRateTime += elapsedTime;
                    while (this._frameRateTime > minEmissionTime) {
                        if (!this._tryEmit()) {
                            break;
                        }
                        totalEmitCount++;
                        this._frameRateTime -= minEmissionTime;
                    }
                }
                totalEmitCount = Math.min(mainModule.maxParticles - aliveParticleCount, totalEmitCount);
                if (totalEmitCount > 0 && comp._isPlaying) {
                    this._addParticles(this._time, this._lastFrameFirstCursor, totalEmitCount, lastEmittsionTime);
                    this._dirty = true;
                }
            };
            ParticleBatcher.prototype._updateRender = function () {
                var renderer = this._renderer;
                var comp = this._comp;
                var mainModule = comp.main;
                //
                if (this._dirty) {
                    // renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes);
                    var bufferOffset = this._lastFrameFirstCursor * this._vertexStride;
                    if (this._firstAliveCursor > this._lastFrameFirstCursor) {
                        var bufferCount = (this._firstAliveCursor - this._lastFrameFirstCursor) * this._vertexStride;
                        renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes, bufferOffset, bufferCount);
                    }
                    else {
                        var addCount = mainModule.maxParticles - this._lastFrameFirstCursor;
                        renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes, bufferOffset, addCount * this._vertexStride);
                        renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes, 0, this._firstAliveCursor * this._vertexStride);
                    }
                    this._lastFrameFirstCursor = this._firstAliveCursor;
                    this._dirty = false;
                }
                var transform = comp.gameObject.transform;
                var material = renderer.batchMaterial;
                if (mainModule.simulationSpace === 0 /* Local */) {
                    material.setVector3("u_worldPosition" /* WORLD_POSITION */, this._worldPostionCache);
                    material.setVector4("u_worldRotation" /* WORLD_ROTATION */, this._worldRotationCache);
                }
                //
                switch (mainModule.scaleMode) {
                    case 1 /* Local */:
                        {
                            var scale = transform.localScale;
                            material.setVector3("u_positionScale" /* POSITION_SCALE */, scale);
                            material.setVector3("u_sizeScale" /* SIZE_SCALE */, scale);
                        }
                        break;
                    case 2 /* Shape */:
                        {
                            var scale = transform.scale;
                            material.setVector3("u_positionScale" /* POSITION_SCALE */, scale);
                            material.setVector3("u_sizeScale" /* SIZE_SCALE */, egret3d.Vector3.ONE);
                        }
                        break;
                    case 0 /* Hierarchy */:
                        {
                            var scale = transform.scale;
                            material.setVector3("u_positionScale" /* POSITION_SCALE */, scale);
                            material.setVector3("u_sizeScale" /* SIZE_SCALE */, scale);
                        }
                        break;
                }
                material.setFloat("u_currentTime" /* CURRENTTIME */, this._time);
                material.setVector3("u_gravity" /* GRAVIT */, this._finalGravity);
            };
            Object.defineProperty(ParticleBatcher.prototype, "aliveParticleCount", {
                get: function () {
                    if (this._firstAliveCursor >= this._lastAliveCursor) {
                        return this._firstAliveCursor - this._lastAliveCursor;
                    }
                    else {
                        return this._comp.main.maxParticles - this._lastAliveCursor + this._firstAliveCursor;
                    }
                },
                enumerable: true,
                configurable: true
            });
            return ParticleBatcher;
        }());
        particle.ParticleBatcher = ParticleBatcher;
        __reflect(ParticleBatcher.prototype, "egret3d.particle.ParticleBatcher");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        /**
         * 粒子组件。
         */
        var ParticleComponent = (function (_super) {
            __extends(ParticleComponent, _super);
            function ParticleComponent() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * 主模块。
                 */
                _this.main = new particle.MainModule(_this);
                /**
                 * 发射模块。
                 */
                _this.emission = new particle.EmissionModule(_this);
                /**
                 * 发射形状模块。
                 */
                _this.shape = new particle.ShapeModule(_this);
                /**
                 * 速率变换模块。
                 */
                _this.velocityOverLifetime = new particle.VelocityOverLifetimeModule(_this);
                /**
                 * 旋转变换模块。
                 */
                _this.rotationOverLifetime = new particle.RotationOverLifetimeModule(_this);
                /**
                 * 尺寸变化模块。
                 */
                _this.sizeOverLifetime = new particle.SizeOverLifetimeModule(_this);
                /**
                 * 颜色变化模块。
                 */
                _this.colorOverLifetime = new particle.ColorOverLifetimeModule(_this);
                /**
                 * 序列帧变化模块。
                 */
                _this.textureSheetAnimation = new particle.TextureSheetAnimationModule(_this);
                /**
                 * @internal
                 */
                _this._isPlaying = false;
                /**
                 * @internal
                 */
                _this._isPaused = false;
                _this._timeScale = 1.0;
                _this._batcher = new particle.ParticleBatcher();
                return _this;
            }
            ParticleComponent.prototype._clean = function (cleanPlayState) {
                if (cleanPlayState === void 0) { cleanPlayState = false; }
                if (cleanPlayState) {
                    this._isPlaying = false;
                    this._isPaused = false;
                }
                this._batcher.clean();
            };
            ParticleComponent.prototype.initialize = function () {
                _super.prototype.initialize.call(this);
                this._clean();
            };
            ParticleComponent.prototype.uninitialize = function () {
                _super.prototype.uninitialize.call(this);
                this._clean();
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.initBatcher = function (cleanPlayState) {
                if (cleanPlayState === void 0) { cleanPlayState = false; }
                this._clean(cleanPlayState);
                this._batcher.init(this, this.gameObject.getComponent(particle.ParticleRenderer));
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.update = function (elapsedTime) {
                this._batcher.update(elapsedTime * this._timeScale);
            };
            ParticleComponent.prototype.play = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                if (this._isPaused) {
                    this._isPaused = false;
                }
                else {
                    this._isPlaying = true;
                    this._isPaused = false;
                    this._batcher.resetTime();
                }
                //
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
                        var child = children_1[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.play(withChildren);
                        }
                    }
                }
            };
            ParticleComponent.prototype.pause = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                this._isPaused = true;
                //
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {
                        var child = children_2[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.pause(withChildren);
                        }
                    }
                }
            };
            ParticleComponent.prototype.stop = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                this._isPlaying = false;
                this._batcher.resetTime();
                //
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_3 = children; _i < children_3.length; _i++) {
                        var child = children_3[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.stop(withChildren);
                        }
                    }
                }
            };
            ParticleComponent.prototype.clear = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_4 = children; _i < children_4.length; _i++) {
                        var child = children_4[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.stop(withChildren);
                        }
                    }
                }
            };
            Object.defineProperty(ParticleComponent.prototype, "timeScale", {
                /**
                 * 播放速度    不能小于0
                 */
                get: function () {
                    return this._timeScale;
                },
                set: function (value) {
                    if (value < 0.0) {
                        value = 0.0;
                    }
                    this._timeScale = value;
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_5 = children; _i < children_5.length; _i++) {
                        var child = children_5[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp) {
                            particleComp.timeScale = value;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "isPlaying", {
                get: function () {
                    return this._isPlaying;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "isPaused", {
                get: function () {
                    return this._isPaused;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "isAlive", {
                get: function () {
                    return this._batcher.aliveParticleCount > 0 || this._isPlaying;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "loop", {
                get: function () {
                    return this.main.loop;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "main", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "emission", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "shape", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "velocityOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "rotationOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "sizeOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "colorOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "textureSheetAnimation", void 0);
            __decorate([
                paper.editor.property("FLOAT" /* FLOAT */, { minimum: 0.0 })
            ], ParticleComponent.prototype, "timeScale", null);
            return ParticleComponent;
        }(paper.BaseComponent));
        particle.ParticleComponent = ParticleComponent;
        __reflect(ParticleComponent.prototype, "egret3d.particle.ParticleComponent");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        var _helpMatrix = egret3d.Matrix4.create();
        /**
         * 粒子渲染模式。
         */
        var ParticleRenderMode;
        (function (ParticleRenderMode) {
            ParticleRenderMode[ParticleRenderMode["Billboard"] = 0] = "Billboard";
            ParticleRenderMode[ParticleRenderMode["Stretch"] = 1] = "Stretch";
            ParticleRenderMode[ParticleRenderMode["HorizontalBillboard"] = 2] = "HorizontalBillboard";
            ParticleRenderMode[ParticleRenderMode["VerticalBillboard"] = 3] = "VerticalBillboard";
            ParticleRenderMode[ParticleRenderMode["Mesh"] = 4] = "Mesh";
            ParticleRenderMode[ParticleRenderMode["None"] = 5] = "None";
        })(ParticleRenderMode = particle.ParticleRenderMode || (particle.ParticleRenderMode = {}));
        /**
         * 粒子着色器的变量名。
         * @internal
         */
        var ParticleMaterialUniform;
        (function (ParticleMaterialUniform) {
            ParticleMaterialUniform["WORLD_POSITION"] = "u_worldPosition";
            ParticleMaterialUniform["WORLD_ROTATION"] = "u_worldRotation";
            ParticleMaterialUniform["POSITION_SCALE"] = "u_positionScale";
            ParticleMaterialUniform["SIZE_SCALE"] = "u_sizeScale";
            ParticleMaterialUniform["SCALING_MODE"] = "u_scalingMode";
            ParticleMaterialUniform["GRAVIT"] = "u_gravity";
            ParticleMaterialUniform["START_SIZE3D"] = "START_SIZE3D";
            ParticleMaterialUniform["START_ROTATION3D"] = "u_startRotation3D";
            ParticleMaterialUniform["SIMULATION_SPACE"] = "u_simulationSpace";
            ParticleMaterialUniform["CURRENTTIME"] = "u_currentTime";
            ParticleMaterialUniform["ALPHAS_GRADIENT"] = "u_alphaGradient[0]";
            ParticleMaterialUniform["COLOR_GRADIENT"] = "u_colorGradient[0]";
            ParticleMaterialUniform["ALPHA_GRADIENT_MAX"] = "u_alphaGradientMax[0]";
            ParticleMaterialUniform["COLOR_GRADIENT_MAX"] = "u_colorGradientMax[0]";
            ParticleMaterialUniform["VELOCITY_CONST"] = "u_velocityConst";
            ParticleMaterialUniform["VELOCITY_CURVE_X"] = "u_velocityCurveX[0]";
            ParticleMaterialUniform["VELOCITY_CURVE_Y"] = "u_velocityCurveY[0]";
            ParticleMaterialUniform["VELOCITY_CURVE_Z"] = "u_velocityCurveZ[0]";
            ParticleMaterialUniform["VELOCITY_CONST_MAX"] = "u_velocityConstMax";
            ParticleMaterialUniform["VELOCITY_CURVE_MAX_X"] = "u_velocityCurveMaxX[0]";
            ParticleMaterialUniform["VELOCITY_CURVE_MAX_Y"] = "u_velocityCurveMaxY[0]";
            ParticleMaterialUniform["VELOCITY_CURVE_MAX_Z"] = "u_velocityCurveMaxZ[0]";
            ParticleMaterialUniform["SPACE_TYPE"] = "u_spaceType";
            ParticleMaterialUniform["SIZE_CURVE"] = "u_sizeCurve[0]";
            ParticleMaterialUniform["SIZE_CURVE_X"] = "u_sizeCurveX[0]";
            ParticleMaterialUniform["SIZE_CURVE_Y"] = "u_sizeCurveY[0]";
            ParticleMaterialUniform["SIZE_CURVE_Z"] = "u_sizeCurveZ[0]";
            ParticleMaterialUniform["SIZE_CURVE_MAX"] = "u_sizeCurveMax[0]";
            ParticleMaterialUniform["SIZE_CURVE_MAX_X"] = "u_sizeCurveMaxX[0]";
            ParticleMaterialUniform["SIZE_CURVE_MAX_Y"] = "u_sizeCurveMaxY[0]";
            ParticleMaterialUniform["SIZE_CURVE_MAX_Z"] = "u_sizeCurveMaxZ[0]";
            ParticleMaterialUniform["ROTATION_CONST"] = "u_rotationConst";
            ParticleMaterialUniform["ROTATION_CONST_SEPRARATE"] = "u_rotationConstSeprarate";
            ParticleMaterialUniform["ROTATION_CURVE"] = "u_rotationCurve[0]";
            ParticleMaterialUniform["ROTATE_CURVE_X"] = "u_rotationCurveX[0]";
            ParticleMaterialUniform["ROTATE_CURVE_y"] = "u_rotationCurveY[0]";
            ParticleMaterialUniform["ROTATE_CURVE_Z"] = "u_rotationCurveZ[0]";
            ParticleMaterialUniform["ROTATE_CURVE_W"] = "u_rotationCurveW[0]";
            ParticleMaterialUniform["ROTATION_CONST_MAX"] = "u_rotationConstMax";
            ParticleMaterialUniform["ROTATION_CONST_MAX_SEPRARATE"] = "u_rotationConstMaxSeprarate";
            ParticleMaterialUniform["ROTATION_CURVE_MAX"] = "u_rotationCurveMax[0]";
            ParticleMaterialUniform["ROTATION_CURVE_MAX_X"] = "u_rotationCurveMaxX[0]";
            ParticleMaterialUniform["ROTATION_CURVE_MAX_Y"] = "u_rotationCurveMaxY[0]";
            ParticleMaterialUniform["ROTATION_CURVE_MAX_Z"] = "u_rotationCurveMaxZ[0]";
            ParticleMaterialUniform["ROTATION_CURVE_MAX_W"] = "u_rotationCurveMaxW[0]";
            ParticleMaterialUniform["CYCLES"] = "u_cycles";
            ParticleMaterialUniform["SUB_UV"] = "u_subUV";
            ParticleMaterialUniform["UV_CURVE"] = "u_uvCurve[0]";
            ParticleMaterialUniform["UV_CURVE_MAX"] = "u_uvCurveMax[0]";
            ParticleMaterialUniform["LENGTH_SCALE"] = "u_lengthScale";
            ParticleMaterialUniform["SPEED_SCALE"] = "u_speeaScale";
        })(ParticleMaterialUniform = particle.ParticleMaterialUniform || (particle.ParticleMaterialUniform = {}));
        /**
         * 粒子着色器的宏定义。
         * @internal
         */
        var ParticleMaterialDefine;
        (function (ParticleMaterialDefine) {
            ParticleMaterialDefine["SPHERHBILLBOARD"] = "SPHERHBILLBOARD";
            ParticleMaterialDefine["STRETCHEDBILLBOARD"] = "STRETCHEDBILLBOARD";
            ParticleMaterialDefine["HORIZONTALBILLBOARD"] = "HORIZONTALBILLBOARD";
            ParticleMaterialDefine["VERTICALBILLBOARD"] = "VERTICALBILLBOARD";
            ParticleMaterialDefine["ROTATIONOVERLIFETIME"] = "ROTATIONOVERLIFETIME";
            ParticleMaterialDefine["ROTATIONCONSTANT"] = "ROTATIONCONSTANT";
            ParticleMaterialDefine["ROTATIONTWOCONSTANTS"] = "ROTATIONTWOCONSTANTS";
            ParticleMaterialDefine["ROTATIONSEPERATE"] = "ROTATIONSEPERATE";
            ParticleMaterialDefine["ROTATIONCURVE"] = "ROTATIONCURVE";
            ParticleMaterialDefine["ROTATIONTWOCURVES"] = "ROTATIONTWOCURVES";
            ParticleMaterialDefine["TEXTURESHEETANIMATIONCURVE"] = "TEXTURESHEETANIMATIONCURVE";
            ParticleMaterialDefine["TEXTURESHEETANIMATIONTWOCURVE"] = "TEXTURESHEETANIMATIONTWOCURVE";
            ParticleMaterialDefine["VELOCITYCONSTANT"] = "VELOCITYCONSTANT";
            ParticleMaterialDefine["VELOCITYCURVE"] = "VELOCITYCURVE";
            ParticleMaterialDefine["VELOCITYTWOCONSTANT"] = "VELOCITYTWOCONSTANT";
            ParticleMaterialDefine["VELOCITYTWOCURVE"] = "VELOCITYTWOCURVE";
            ParticleMaterialDefine["COLOROGRADIENT"] = "COLOROGRADIENT";
            ParticleMaterialDefine["COLORTWOGRADIENTS"] = "COLORTWOGRADIENTS";
            ParticleMaterialDefine["SIZECURVE"] = "SIZECURVE";
            ParticleMaterialDefine["SIZETWOCURVES"] = "SIZETWOCURVES";
            ParticleMaterialDefine["SIZECURVESEPERATE"] = "SIZECURVESEPERATE";
            ParticleMaterialDefine["SIZETWOCURVESSEPERATE"] = "SIZETWOCURVESSEPERATE";
            ParticleMaterialDefine["RENDERMESH"] = "RENDERMESH";
            ParticleMaterialDefine["SHAPE"] = "SHAPE";
        })(ParticleMaterialDefine = particle.ParticleMaterialDefine || (particle.ParticleMaterialDefine = {}));
        /**
         * 粒子渲染器。
         */
        var ParticleRenderer = (function (_super) {
            __extends(ParticleRenderer, _super);
            function ParticleRenderer() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * TODO
                 */
                _this.frustumCulled = false;
                _this.velocityScale = 1.0;
                _this.lengthScale = 1.0;
                _this._renderMode = 0 /* Billboard */;
                _this._mesh = null;
                return _this;
            }
            ParticleRenderer.prototype.uninitialize = function () {
                _super.prototype.uninitialize.call(this);
                if (this._mesh) {
                    this._mesh.release();
                }
                if (this.batchMesh) {
                    this.batchMesh.release();
                }
                if (this.batchMaterial) {
                    this.batchMaterial.release();
                }
                this._renderMode = 0 /* Billboard */;
                this.velocityScale = 1.0;
                this.lengthScale = 1.0;
                this._mesh = null;
                this.batchMesh = null;
                this.batchMaterial = null;
            };
            ParticleRenderer.prototype.recalculateLocalBox = function () {
                this._localBoundingBox.copy(egret3d.Box.ONE);
            };
            ParticleRenderer.prototype.raycast = function (ray, raycastInfo) {
                if (raycastInfo === void 0) { raycastInfo = null; }
                var localRay = egret3d.helpRay.applyMatrix(this.gameObject.transform.worldToLocalMatrix, ray);
                var localBoundingBox = this.localBoundingBox;
                if (localBoundingBox.raycast(localRay, raycastInfo)) {
                    if (raycastInfo) {
                        var worldMatrix = this.gameObject.transform.localToWorldMatrix;
                        raycastInfo.position.applyMatrix(worldMatrix);
                        raycastInfo.distance = ray.origin.getDistance(raycastInfo.position);
                    }
                    return true;
                }
                return false;
            };
            Object.defineProperty(ParticleRenderer.prototype, "renderMode", {
                /**
                 *
                 */
                get: function () {
                    return this._renderMode;
                },
                set: function (value) {
                    if (this._renderMode === value) {
                        return;
                    }
                    this._renderMode = value;
                    ParticleRenderer.onRenderModeChanged.dispatch(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleRenderer.prototype, "mesh", {
                /**
                 *
                 */
                get: function () {
                    return this._mesh;
                },
                set: function (value) {
                    if (this._mesh === value) {
                        return;
                    }
                    if (this._mesh) {
                        this._mesh.release();
                    }
                    if (value) {
                        value.retain();
                    }
                    this._mesh = value;
                    ParticleRenderer.onMeshChanged.dispatch(this);
                },
                enumerable: true,
                configurable: true
            });
            /**
             * 渲染模式改变
             */
            ParticleRenderer.onRenderModeChanged = new signals.Signal();
            /**
             * TODO
             */
            ParticleRenderer.onVelocityScaleChanged = new signals.Signal();
            /**
             * TODO
             */
            ParticleRenderer.onLengthScaleChanged = new signals.Signal();
            /**
             *
             */
            ParticleRenderer.onMeshChanged = new signals.Signal();
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "velocityScale", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "lengthScale", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "_renderMode", void 0);
            __decorate([
                paper.editor.property("MESH" /* MESH */),
                paper.serializedField("_mesh")
            ], ParticleRenderer.prototype, "mesh", null);
            return ParticleRenderer;
        }(paper.BaseRenderer));
        particle.ParticleRenderer = ParticleRenderer;
        __reflect(ParticleRenderer.prototype, "egret3d.particle.ParticleRenderer");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        /**
         *
         */
        var ParticleSystem = (function (_super) {
            __extends(ParticleSystem, _super);
            function ParticleSystem() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.interests = [
                    {
                        componentClass: particle.ParticleComponent,
                        listeners: [
                            { type: particle.onStartSize3DChanged, listener: function (comp) { _this._onMainUpdate(comp, particle.onStartSize3DChanged); } },
                            { type: particle.onStartRotation3DChanged, listener: function (comp) { _this._onMainUpdate(comp, particle.onStartRotation3DChanged); } },
                            { type: particle.onSimulationSpaceChanged, listener: function (comp) { _this._onMainUpdate(comp, particle.onSimulationSpaceChanged); } },
                            { type: particle.onScaleModeChanged, listener: function (comp) { _this._onMainUpdate(comp, particle.onScaleModeChanged); } },
                            { type: particle.onVelocityChanged, listener: function (comp) { _this._onVelocityOverLifetime(comp); } },
                            { type: particle.onColorChanged, listener: function (comp) { _this._onColorOverLifetime(comp); } },
                            { type: particle.onSizeChanged, listener: function (comp) { _this._onSizeOverLifetime(comp); } },
                            { type: particle.onRotationChanged, listener: function (comp) { _this._onRotationOverLifetime(comp); } },
                            { type: particle.onTextureSheetChanged, listener: function (comp) { _this._onTextureSheetAnimation(comp); } },
                        ]
                    },
                    {
                        componentClass: particle.ParticleRenderer,
                        listeners: [
                            { type: particle.ParticleRenderer.onMeshChanged, listener: function (comp) { _this._updateDrawCalls(comp.gameObject); } },
                            { type: particle.ParticleRenderer.onMaterialsChanged, listener: function (comp) { _this._updateDrawCalls(comp.gameObject); } },
                            // { type: ParticleRendererEventType.LengthScaleChanged, listener: (comp: ParticleRenderer) => { this._onRenderUpdate(comp, ParticleRendererEventType.LengthScaleChanged); } },
                            // { type: ParticleRendererEventType.VelocityScaleChanged, listener: (comp: ParticleRenderer) => { this._onRenderUpdate(comp, ParticleRendererEventType.VelocityScaleChanged); } },
                            { type: particle.ParticleRenderer.onRenderModeChanged, listener: function (comp) { _this._onRenderUpdate(comp, particle.ParticleRenderer.onRenderModeChanged); } },
                        ]
                    }
                ];
                _this._drawCallCollecter = paper.Application.sceneManager.globalEntity.getComponent(egret3d.DrawCallCollecter);
                return _this;
            }
            /**
            * Buffer改变的时候，有可能是初始化，也有可能是mesh改变，此时全部刷一下
            */
            ParticleSystem.prototype._onUpdateBatchMesh = function (comp, cleanPlayState) {
                if (cleanPlayState === void 0) { cleanPlayState = true; }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                comp.initBatcher(cleanPlayState);
                //
                this._onRenderUpdate(renderer, particle.ParticleRenderer.onRenderModeChanged);
                this._onRenderUpdate(renderer, particle.ParticleRenderer.onVelocityScaleChanged);
                this._onRenderUpdate(renderer, particle.ParticleRenderer.onLengthScaleChanged);
                //
                this._onMainUpdate(comp, particle.onSizeChanged);
                this._onMainUpdate(comp, particle.onStartRotation3DChanged);
                this._onMainUpdate(comp, particle.onSimulationSpaceChanged);
                this._onMainUpdate(comp, particle.onScaleModeChanged);
                this._onShapeChanged(comp);
                this._onVelocityOverLifetime(comp);
                this._onColorOverLifetime(comp);
                this._onSizeOverLifetime(comp);
                this._onRotationOverLifetime(comp);
                this._onTextureSheetAnimation(comp);
            };
            ParticleSystem.prototype._onRenderUpdate = function (render, type) {
                if (!this.enabled || !this.groups[0].hasGameObject(render.gameObject)) {
                    return;
                }
                var material = render.batchMaterial;
                switch (type) {
                    case particle.ParticleRenderer.onRenderModeChanged: {
                        this._onRenderMode(render);
                        break;
                    }
                    case particle.ParticleRenderer.onLengthScaleChanged: {
                        material.setFloat("u_lengthScale" /* LENGTH_SCALE */, render.lengthScale);
                        break;
                    }
                    case particle.ParticleRenderer.onVelocityScaleChanged: {
                        material.setFloat("u_speeaScale" /* SPEED_SCALE */, render.velocityScale);
                        break;
                    }
                }
            };
            /**
             *
             * @param render 渲染模式改变
             */
            ParticleSystem.prototype._onRenderMode = function (render) {
                var material = render.batchMaterial;
                material.removeDefine("SPHERHBILLBOARD" /* SPHERHBILLBOARD */);
                material.removeDefine("STRETCHEDBILLBOARD" /* STRETCHEDBILLBOARD */);
                material.removeDefine("HORIZONTALBILLBOARD" /* HORIZONTALBILLBOARD */);
                material.removeDefine("VERTICALBILLBOARD" /* VERTICALBILLBOARD */);
                material.removeDefine("RENDERMESH" /* RENDERMESH */);
                var mode = render.renderMode;
                switch (mode) {
                    case 0 /* Billboard */: {
                        material.addDefine("SPHERHBILLBOARD" /* SPHERHBILLBOARD */);
                        break;
                    }
                    case 1 /* Stretch */: {
                        material.addDefine("STRETCHEDBILLBOARD" /* STRETCHEDBILLBOARD */);
                        break;
                    }
                    case 2 /* HorizontalBillboard */: {
                        material.addDefine("HORIZONTALBILLBOARD" /* HORIZONTALBILLBOARD */);
                        break;
                    }
                    case 3 /* VerticalBillboard */: {
                        material.addDefine("VERTICALBILLBOARD" /* VERTICALBILLBOARD */);
                        break;
                    }
                    case 4 /* Mesh */: {
                        material.addDefine("RENDERMESH" /* RENDERMESH */);
                        break;
                    }
                    default: {
                        throw "_onRenderMode:invalid renderMode";
                    }
                }
            };
            ParticleSystem.prototype._onMainUpdate = function (component, type) {
                if (!this.enabled || !this.groups[0].hasGameObject(component.gameObject)) {
                    return;
                }
                var renderer = component.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                var mainModule = component.main;
                switch (type) {
                    case particle.onStartSize3DChanged: {
                        material.setBoolean("START_SIZE3D" /* START_SIZE3D */, mainModule.startSize3D);
                        break;
                    }
                    case particle.onStartRotation3DChanged: {
                        material.setBoolean("u_startRotation3D" /* START_ROTATION3D */, mainModule.startRotation3D);
                        break;
                    }
                    case particle.onSimulationSpaceChanged: {
                        material.setInt("u_simulationSpace" /* SIMULATION_SPACE */, mainModule.simulationSpace);
                        break;
                    }
                    case particle.onScaleModeChanged: {
                        material.setInt("u_scalingMode" /* SCALING_MODE */, mainModule.scaleMode);
                        break;
                    }
                }
            };
            /**
             * 更新速率模块
             * @param component
             */
            ParticleSystem.prototype._onShapeChanged = function (comp) {
                if (!this.enabled || !this.groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("SHAPE" /* SHAPE */);
                if (comp.shape.enable) {
                    material.addDefine("SHAPE" /* SHAPE */);
                }
            };
            /**
             * 更新速率模块
             * @param component
             */
            ParticleSystem.prototype._onVelocityOverLifetime = function (comp) {
                if (!this.enabled || !this.groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("VELOCITYCONSTANT" /* VELOCITYCONSTANT */);
                material.removeDefine("VELOCITYCURVE" /* VELOCITYCURVE */);
                material.removeDefine("VELOCITYTWOCONSTANT" /* VELOCITYTWOCONSTANT */);
                material.removeDefine("VELOCITYTWOCURVE" /* VELOCITYTWOCURVE */);
                var velocityModule = comp.velocityOverLifetime;
                if (velocityModule.enable) {
                    var mode = velocityModule.mode;
                    switch (mode) {
                        case 0 /* Constant */: {
                            material.addDefine("VELOCITYCONSTANT" /* VELOCITYCONSTANT */);
                            //
                            var vec3 = new egret3d.Vector3(velocityModule.x.evaluate(), velocityModule.y.evaluate(), velocityModule.z.evaluate());
                            material.setVector3("u_velocityConst" /* VELOCITY_CONST */, vec3);
                            break;
                        }
                        case 1 /* Curve */: {
                            material.addDefine("VELOCITYCURVE" /* VELOCITYCURVE */);
                            //
                            material.setVector2v("u_velocityCurveX[0]" /* VELOCITY_CURVE_X */, velocityModule.x.curve.floatValues);
                            material.setVector2v("u_velocityCurveY[0]" /* VELOCITY_CURVE_Y */, velocityModule.y.curve.floatValues);
                            material.setVector2v("u_velocityCurveZ[0]" /* VELOCITY_CURVE_Z */, velocityModule.z.curve.floatValues);
                            break;
                        }
                        case 3 /* TwoConstants */: {
                            material.addDefine("VELOCITYTWOCONSTANT" /* VELOCITYTWOCONSTANT */);
                            //
                            var minVec3 = new egret3d.Vector3(velocityModule.x.constantMin, velocityModule.y.constantMin, velocityModule.z.constantMin);
                            var maxVec3 = new egret3d.Vector3(velocityModule.x.constantMax, velocityModule.y.constantMax, velocityModule.z.constantMax);
                            material.setVector3("u_velocityConst" /* VELOCITY_CONST */, minVec3);
                            material.setVector3("u_velocityConstMax" /* VELOCITY_CONST_MAX */, maxVec3);
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            material.addDefine("VELOCITYTWOCURVE" /* VELOCITYTWOCURVE */);
                            //
                            material.setVector2v("u_velocityCurveX[0]" /* VELOCITY_CURVE_X */, velocityModule.x.curveMin.floatValues);
                            material.setVector2v("u_velocityCurveY[0]" /* VELOCITY_CURVE_Y */, velocityModule.y.curveMin.floatValues);
                            material.setVector2v("u_velocityCurveZ[0]" /* VELOCITY_CURVE_Z */, velocityModule.z.curveMin.floatValues);
                            material.setVector2v("u_velocityCurveMaxX[0]" /* VELOCITY_CURVE_MAX_X */, velocityModule.x.curveMax.floatValues);
                            material.setVector2v("u_velocityCurveMaxY[0]" /* VELOCITY_CURVE_MAX_Y */, velocityModule.y.curveMax.floatValues);
                            material.setVector2v("u_velocityCurveMaxZ[0]" /* VELOCITY_CURVE_MAX_Z */, velocityModule.z.curveMax.floatValues);
                            break;
                        }
                    }
                    material.setInt("u_spaceType" /* SPACE_TYPE */, velocityModule.space);
                }
            };
            /**
             * 更新颜色模块
             * @param component
             */
            ParticleSystem.prototype._onColorOverLifetime = function (comp) {
                if (!this.enabled || !this.groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("COLOROGRADIENT" /* COLOROGRADIENT */);
                material.removeDefine("COLORTWOGRADIENTS" /* COLORTWOGRADIENTS */);
                var colorModule = comp.colorOverLifetime;
                if (colorModule.enable) {
                    var color = colorModule.color;
                    switch (color.mode) {
                        case 1 /* Gradient */: {
                            material.addDefine("COLOROGRADIENT" /* COLOROGRADIENT */);
                            //
                            material.setVector2v("u_alphaGradient[0]" /* ALPHAS_GRADIENT */, color.gradient.alphaValues);
                            material.setVector4v("u_colorGradient[0]" /* COLOR_GRADIENT */, color.gradient.colorValues);
                            break;
                        }
                        case 3 /* TwoGradients */: {
                            material.addDefine("COLORTWOGRADIENTS" /* COLORTWOGRADIENTS */);
                            //
                            material.setVector2v("u_alphaGradient[0]" /* ALPHAS_GRADIENT */, color.gradientMin.alphaValues);
                            material.setVector2v("u_alphaGradientMax[0]" /* ALPHA_GRADIENT_MAX */, color.gradientMax.alphaValues);
                            material.setVector4v("u_colorGradient[0]" /* COLOR_GRADIENT */, color.gradientMin.colorValues);
                            material.setVector4v("u_colorGradientMax[0]" /* COLOR_GRADIENT_MAX */, color.gradientMax.colorValues);
                            break;
                        }
                    }
                }
            };
            /**
             * 更新大小模块
             * @param component
             */
            ParticleSystem.prototype._onSizeOverLifetime = function (comp) {
                if (!this.enabled || !this.groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("SIZECURVE" /* SIZECURVE */);
                material.removeDefine("SIZECURVESEPERATE" /* SIZECURVESEPERATE */);
                material.removeDefine("SIZETWOCURVES" /* SIZETWOCURVES */);
                material.removeDefine("SIZETWOCURVESSEPERATE" /* SIZETWOCURVESSEPERATE */);
                var sizeModule = comp.sizeOverLifetime;
                if (sizeModule.enable) {
                    var separateAxes = sizeModule.separateAxes;
                    var mode = sizeModule.x.mode;
                    switch (mode) {
                        case 1 /* Curve */: {
                            if (separateAxes) {
                                material.addDefine("SIZECURVESEPERATE" /* SIZECURVESEPERATE */);
                                //
                                material.setVector2v("u_sizeCurveX[0]" /* SIZE_CURVE_X */, sizeModule.x.curve.floatValues);
                                material.setVector2v("u_sizeCurveY[0]" /* SIZE_CURVE_Y */, sizeModule.y.curve.floatValues);
                                material.setVector2v("u_sizeCurveZ[0]" /* SIZE_CURVE_Z */, sizeModule.z.curve.floatValues);
                            }
                            else {
                                material.addDefine("SIZECURVE" /* SIZECURVE */);
                                //
                                material.setVector2v("u_sizeCurve[0]" /* SIZE_CURVE */, sizeModule.size.curve.floatValues);
                            }
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            if (separateAxes) {
                                material.addDefine("SIZETWOCURVESSEPERATE" /* SIZETWOCURVESSEPERATE */);
                                //
                                material.setVector2v("u_sizeCurveX[0]" /* SIZE_CURVE_X */, sizeModule.x.curveMin.floatValues);
                                material.setVector2v("u_sizeCurveY[0]" /* SIZE_CURVE_Y */, sizeModule.y.curveMin.floatValues);
                                material.setVector2v("u_sizeCurveZ[0]" /* SIZE_CURVE_Z */, sizeModule.z.curveMin.floatValues);
                                material.setVector2v("u_sizeCurveMaxX[0]" /* SIZE_CURVE_MAX_X */, sizeModule.x.curveMax.floatValues);
                                material.setVector2v("u_sizeCurveMaxY[0]" /* SIZE_CURVE_MAX_Y */, sizeModule.y.curveMax.floatValues);
                                material.setVector2v("u_sizeCurveMaxZ[0]" /* SIZE_CURVE_MAX_Z */, sizeModule.z.curveMax.floatValues);
                            }
                            else {
                                material.addDefine("SIZETWOCURVES" /* SIZETWOCURVES */);
                                //
                                material.setVector2v("u_sizeCurve[0]" /* SIZE_CURVE */, sizeModule.size.curveMin.floatValues);
                                material.setVector2v("u_sizeCurveMax[0]" /* SIZE_CURVE_MAX */, sizeModule.size.curveMax.floatValues);
                            }
                            break;
                        }
                    }
                }
            };
            /**
             * 更新旋转模块
             * @param comp
             */
            ParticleSystem.prototype._onRotationOverLifetime = function (comp) {
                if (!this.enabled || !this.groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("ROTATIONOVERLIFETIME" /* ROTATIONOVERLIFETIME */);
                material.removeDefine("ROTATIONCONSTANT" /* ROTATIONCONSTANT */);
                material.removeDefine("ROTATIONTWOCONSTANTS" /* ROTATIONTWOCONSTANTS */);
                material.removeDefine("ROTATIONSEPERATE" /* ROTATIONSEPERATE */);
                material.removeDefine("ROTATIONCURVE" /* ROTATIONCURVE */);
                material.removeDefine("ROTATIONTWOCURVES" /* ROTATIONTWOCURVES */);
                var rotationModule = comp.rotationOverLifetime;
                if (rotationModule.enable) {
                    var mode = comp.rotationOverLifetime.x.mode;
                    var separateAxes = rotationModule.separateAxes;
                    if (separateAxes) {
                        material.addDefine("ROTATIONSEPERATE" /* ROTATIONSEPERATE */);
                    }
                    else {
                        material.addDefine("ROTATIONOVERLIFETIME" /* ROTATIONOVERLIFETIME */);
                    }
                    switch (mode) {
                        case 0 /* Constant */: {
                            material.addDefine("ROTATIONCONSTANT" /* ROTATIONCONSTANT */);
                            //
                            if (separateAxes) {
                                material.setVector3("u_rotationConstSeprarate" /* ROTATION_CONST_SEPRARATE */, new egret3d.Vector3(rotationModule.x.constant, rotationModule.y.constant, rotationModule.z.constant));
                            }
                            else {
                                material.setFloat("u_rotationConst" /* ROTATION_CONST */, rotationModule.z.constant);
                            }
                            break;
                        }
                        case 3 /* TwoConstants */: {
                            material.addDefine("ROTATIONTWOCONSTANTS" /* ROTATIONTWOCONSTANTS */);
                            //
                            if (separateAxes) {
                                material.setVector3("u_rotationConstSeprarate" /* ROTATION_CONST_SEPRARATE */, new egret3d.Vector3(rotationModule.x.constantMin, rotationModule.y.constantMin, rotationModule.z.constantMin));
                                material.setVector3("u_rotationConstMaxSeprarate" /* ROTATION_CONST_MAX_SEPRARATE */, new egret3d.Vector3(rotationModule.x.constantMax, rotationModule.y.constantMax, rotationModule.z.constantMax));
                            }
                            else {
                                material.setFloat("u_rotationConst" /* ROTATION_CONST */, rotationModule.z.constantMin);
                                material.setFloat("u_rotationConstMax" /* ROTATION_CONST_MAX */, rotationModule.z.constantMax);
                            }
                            break;
                        }
                        case 1 /* Curve */: {
                            material.addDefine("ROTATIONCURVE" /* ROTATIONCURVE */);
                            //
                            if (separateAxes) {
                                material.setVector2v("u_rotationCurveX[0]" /* ROTATE_CURVE_X */, rotationModule.x.curve.floatValues);
                                material.setVector2v("u_rotationCurveY[0]" /* ROTATE_CURVE_y */, rotationModule.y.curve.floatValues);
                                material.setVector2v("u_rotationCurveZ[0]" /* ROTATE_CURVE_Z */, rotationModule.z.curve.floatValues);
                            }
                            else {
                                material.setVector2v("u_rotationCurve[0]" /* ROTATION_CURVE */, rotationModule.z.curve.floatValues);
                            }
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            material.addDefine("ROTATIONTWOCURVES" /* ROTATIONTWOCURVES */);
                            //
                            if (separateAxes) {
                                material.setVector2v("u_rotationCurveX[0]" /* ROTATE_CURVE_X */, rotationModule.x.curveMin.floatValues);
                                material.setVector2v("u_rotationCurveY[0]" /* ROTATE_CURVE_y */, rotationModule.y.curveMin.floatValues);
                                material.setVector2v("u_rotationCurveZ[0]" /* ROTATE_CURVE_Z */, rotationModule.z.curveMin.floatValues);
                                material.setVector2v("u_rotationCurveMaxX[0]" /* ROTATION_CURVE_MAX_X */, rotationModule.x.curveMax.floatValues);
                                material.setVector2v("u_rotationCurveMaxY[0]" /* ROTATION_CURVE_MAX_Y */, rotationModule.y.curveMax.floatValues);
                                material.setVector2v("u_rotationCurveMaxZ[0]" /* ROTATION_CURVE_MAX_Z */, rotationModule.z.curveMax.floatValues);
                            }
                            else {
                                material.setVector2v("u_rotationCurve[0]" /* ROTATION_CURVE */, rotationModule.z.curveMin.floatValues);
                                material.setVector2v("u_rotationCurveMax[0]" /* ROTATION_CURVE_MAX */, rotationModule.z.curveMin.floatValues);
                            }
                            break;
                        }
                    }
                }
            };
            ParticleSystem.prototype._onTextureSheetAnimation = function (comp) {
                if (!this.enabled || !this.groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("TEXTURESHEETANIMATIONCURVE" /* TEXTURESHEETANIMATIONCURVE */);
                material.removeDefine("TEXTURESHEETANIMATIONTWOCURVE" /* TEXTURESHEETANIMATIONTWOCURVE */);
                var module = comp.textureSheetAnimation;
                if (module.enable) {
                    var type = module.frameOverTime.mode;
                    switch (type) {
                        case 1 /* Curve */: {
                            material.addDefine("TEXTURESHEETANIMATIONCURVE" /* TEXTURESHEETANIMATIONCURVE */);
                            //
                            material.setVector2v("u_uvCurve[0]" /* UV_CURVE */, module.frameOverTime.curve.floatValues);
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            material.addDefine("TEXTURESHEETANIMATIONTWOCURVE" /* TEXTURESHEETANIMATIONTWOCURVE */);
                            //
                            material.setVector2v("u_uvCurve[0]" /* UV_CURVE */, module.frameOverTime.curveMin.floatValues);
                            material.setVector2v("u_uvCurveMax[0]" /* UV_CURVE_MAX */, module.frameOverTime.curveMax.floatValues);
                            break;
                        }
                    }
                    if (type === 1 /* Curve */ || type === 2 /* TwoCurves */) {
                        material.setFloat("u_cycles" /* CYCLES */, module.cycleCount);
                        material.setVector4v("u_subUV" /* SUB_UV */, module.floatValues);
                    }
                }
            };
            ParticleSystem.prototype._updateDrawCalls = function (gameObject, cleanPlayState) {
                if (cleanPlayState === void 0) { cleanPlayState = true; }
                if (!this.enabled || !this.groups[0].hasGameObject(gameObject)) {
                    return;
                }
                var drawCallCollecter = this._drawCallCollecter;
                var component = gameObject.getComponent(particle.ParticleComponent);
                var renderer = gameObject.getComponent(particle.ParticleRenderer);
                //
                drawCallCollecter.removeDrawCalls(gameObject);
                if (!renderer.material) {
                    console.error("ParticleSystem : material is null");
                    return;
                }
                if (renderer.renderMode === 4 /* Mesh */ && !renderer.mesh) {
                    console.error("ParticleSystem : mesh is null");
                    return;
                }
                if (renderer.renderMode === 5 /* None */) {
                    console.error("ParticleSystem : error renderMode");
                    renderer.renderMode = 0 /* Billboard */;
                }
                this._onUpdateBatchMesh(component, cleanPlayState);
                //
                var subMeshIndex = 0;
                for (var _i = 0, _a = renderer.batchMesh.glTFMesh.primitives; _i < _a.length; _i++) {
                    var _primitive = _a[_i];
                    var drawCall = egret3d.DrawCall.create();
                    drawCall.entity = gameObject;
                    drawCall.renderer = renderer;
                    drawCall.matrix = gameObject.transform.localToWorldMatrix;
                    drawCall.subMeshIndex = subMeshIndex++;
                    drawCall.mesh = renderer.batchMesh;
                    drawCall.material = renderer.batchMaterial;
                    drawCallCollecter.addDrawCall(drawCall);
                }
            };
            ParticleSystem.prototype.onEntityAdded = function (entity) {
                this._updateDrawCalls(entity, false);
                var component = entity.getComponent(particle.ParticleComponent);
                if (component.main.playOnAwake) {
                    component.play();
                }
            };
            ParticleSystem.prototype.onEntityRemoved = function (entity) {
                this._drawCallCollecter.removeDrawCalls(entity);
                // component.stop();
            };
            ParticleSystem.prototype.onFrame = function (deltaTime) {
                // if (deltaTime > 0.3) {
                //     deltaTime = 0.3;//防止dt过大，引起周期错乱
                // }
                var dt = 0.016 * paper.clock.timeScale;
                for (var _i = 0, _a = this.groups[0].entities; _i < _a.length; _i++) {
                    var entity = _a[_i];
                    entity.getComponent(particle.ParticleComponent).update(dt);
                }
            };
            return ParticleSystem;
        }(paper.BaseSystem));
        particle.ParticleSystem = ParticleSystem;
        __reflect(ParticleSystem.prototype, "egret3d.particle.ParticleSystem");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
// namespace egret3d {
//     export class Audio extends paper.BaseComponent {
//     }
// } 
var egret3d;
(function (egret3d) {
    //最大允许合并的顶点数，超过就是下一批次
    egret3d.MAX_VERTEX_COUNT_PER_BUFFER = 50000;
    //
    var helpVec3_1 = egret3d.Vector3.create();
    var helpInverseMatrix = egret3d.Matrix4.create();
    //缓存已经校验过的对象，用于过滤
    var cacheUUIDs = [];
    var beforeCombineCount = 0;
    var CombineInstance = (function () {
        function CombineInstance() {
            this.verticesCount = 0;
            this.indicesCount = 0;
            this.lightmapIndex = -1;
            this.primitiveIndices = [];
            this.meshAttribute = {};
            this.materials = [];
            this.instances = [];
        }
        return CombineInstance;
    }());
    __reflect(CombineInstance.prototype, "CombineInstance");
    function _copyAccessorBuffer(mesh, accessor, target, offset) {
        var buffer = mesh.createTypeArrayFromAccessor(mesh.getAccessor(accessor));
        var count = buffer.length;
        for (var i = 0; i < count; i++) {
            target[offset + i] = buffer[i];
        }
    }
    function _fillBuffer(target, offset, count, defaultValue) {
        var defaultValueCount = defaultValue.length;
        for (var i = 0; i < count; i++) {
            for (var j = 0; j < defaultValueCount; j++) {
                target[offset++] = defaultValue[j];
            }
        }
    }
    /**
     * 尝试对场景内所有静态对象合并
     */
    function combineScene(scene) {
        combine(scene.gameObjects);
    }
    egret3d.combineScene = combineScene;
    /**
     * 尝试合并静态对象列表。
     * @param instances
     * @param root
     */
    function combine(instances) {
        cacheUUIDs.length = 0;
        beforeCombineCount = 0;
        var allCombines = {};
        //1.通过材质填充合并列表
        for (var _i = 0, instances_1 = instances; _i < instances_1.length; _i++) {
            var obj = instances_1[_i];
            _colletCombineInstance(obj, allCombines);
        }
        var afterCombineCount = 0;
        //2.相同材质的合并
        for (var key in allCombines) {
            var combines = allCombines[key];
            for (var _a = 0, combines_1 = combines; _a < combines_1.length; _a++) {
                var combine_1 = combines_1[_a];
                _combineInstance(combine_1);
                afterCombineCount++;
            }
        }
        console.log("combine", beforeCombineCount, "to", afterCombineCount, "save", beforeCombineCount - afterCombineCount);
        cacheUUIDs.length = 0;
    }
    egret3d.combine = combine;
    /**
     * TODO(root暂时不支持)尝试合并静态对象列表，如果root有值，合并后可以操作root对象的transform，来实现整体移动，旋转，缩放；反之，相同材质列表的第一个对象为合并节点。
     * @param instances
     * @param root
     */
    function _colletCombineInstance(target, out, root) {
        //过滤重复的对象
        if (cacheUUIDs.indexOf(target.uuid) >= 0) {
            return;
        }
        cacheUUIDs.push(target.uuid);
        //
        for (var _i = 0, _a = target.transform.children; _i < _a.length; _i++) {
            var child = _a[_i];
            if (child) {
                _colletCombineInstance(child.gameObject, out, root);
            }
        }
        //不是静态的不考虑合并
        if (!target.isStatic) {
            return;
        }
        var meshFilter = target.getComponent(egret3d.MeshFilter);
        var meshRenderer = target.getComponent(egret3d.MeshRenderer);
        //合并条件判断
        if (!meshFilter || !meshFilter.mesh || !meshRenderer || !meshRenderer.materials || meshRenderer.materials.length < 1) {
            return;
        }
        beforeCombineCount++;
        var materials = meshRenderer.materials;
        var meshData = meshFilter.mesh;
        //合并筛选的条件:层级_光照贴图索引_材质0_材质1... ：256_0_234_532...
        var key = target.layer + "_" + meshRenderer.lightmapIndex + "_";
        materials.forEach(function (e) { key = key + "_" + e.uuid; });
        if (!out[key]) {
            out[key] = [];
            out[key].push(new CombineInstance());
        }
        var combines = out[key];
        //找相同材质合成列表的最后一个，如果最后一个顶点超过允许最大数了，就新建一个，下个批次处理
        var combine = combines[combines.length - 1];
        if (combine.verticesCount + meshData.vertexCount > egret3d.MAX_VERTEX_COUNT_PER_BUFFER) {
            combine = new CombineInstance();
            out[key].push(combine);
        }
        //合并节点以传入的对象为优先，如果没有传入，那么以每种材质的第一个对象为准
        if (!combine.root) {
            combine.root = root ? root : target;
            combine.lightmapIndex = meshRenderer.lightmapIndex;
            for (var _b = 0, materials_5 = materials; _b < materials_5.length; _b++) {
                var mat = materials_5[_b];
                combine.materials.push(mat);
            }
        }
        //适配最大格式
        var primitives = meshData.glTFMesh.primitives;
        for (var i = 0; i < primitives.length; i++) {
            var primitive = primitives[i];
            for (var attStr in primitives[i].attributes) {
                var attrType = attStr;
                if (!combine.meshAttribute[attrType]) {
                    combine.meshAttribute[attrType] = attrType;
                }
            }
            //
            // if (!combine.primitiveIndices[i]) {
            //     combine.primitiveIndices[i] = 0;
            // }
            var indicesCount = meshData.getBufferLength(meshData.getAccessor(primitive.indices)) / Uint16Array.BYTES_PER_ELEMENT;
            // combine.primitiveIndices[i] += indicesCount;
            combine.indicesCount += indicesCount;
        }
        //
        combine.verticesCount += meshData.vertexCount;
        combine.instances.push(target);
    }
    /**
     * 合并拥有共享材质的渲染对象
     * @param combineInstance
     */
    function _combineInstance(combineInstance) {
        var combineMesh = _combineMesh(combineInstance);
        var combineRoot = combineInstance.root;
        //把合成好的放入root中，重新绘制
        var meshFilter = combineRoot.getOrAddComponent(egret3d.MeshFilter);
        meshFilter.mesh = combineMesh;
        var meshRenderer = combineRoot.getOrAddComponent(egret3d.MeshRenderer);
        meshRenderer.materials = combineInstance.materials;
    }
    /**
     * 合并拥有共享材质的渲染对象
     * @param combineInstance
     * @param root
     */
    function _combineMesh(combineInstance) {
        //
        var root = combineInstance.root;
        var meshAttribute = combineInstance.meshAttribute;
        var lightmapScaleOffset = root.renderer.lightmapScaleOffset;
        var combineAttributes = [];
        for (var key in meshAttribute) {
            combineAttributes.push(key);
        }
        //
        var combineMesh = egret3d.Mesh.create(combineInstance.verticesCount, combineInstance.primitiveIndices[0], combineAttributes);
        combineMesh.drawMode = 35048 /* Dynamic */;
        var combinePosition = combineMesh.getVertices();
        var combineNormal = combineMesh.getNormals();
        var combineUV0 = combineMesh.getUVs();
        var combineUV1 = combineMesh.getAttributes("TEXCOORD_1" /* TEXCOORD_1 */);
        var combineColor0 = combineMesh.getColors();
        var combineJoint0 = combineMesh.getAttributes("JOINTS_0" /* JOINTS_0 */);
        var combineWeight0 = combineMesh.getAttributes("WEIGHTS_0" /* WEIGHTS_0 */);
        var combineIndices = combineMesh.getIndices();
        //
        helpInverseMatrix.copy(root.transform.worldToLocalMatrix);
        var subIndexBuffersCount = [];
        //
        var positonIndex = 0, normalIndex = 0, color0Index = 0, color1Index = 0, uv0Index = 0, uv1Index = 0, jointIndex = 0, weightIndex = 0, indexIndex = 0;
        var startIndex = 0;
        var endIndex = 0;
        for (var _i = 0, _a = combineInstance.instances; _i < _a.length; _i++) {
            var instance = _a[_i];
            var meshFilter = instance.getComponent(egret3d.MeshFilter);
            var meshRenderer = instance.getComponent(egret3d.MeshRenderer);
            var worldMatrix = instance.transform.localToWorldMatrix;
            var mesh = meshFilter.mesh;
            var orginLightmapScaleOffset = meshRenderer.lightmapScaleOffset;
            var primitives = mesh.glTFMesh.primitives;
            //共享一个的buffer，vbo只处理一个submesh就可以了
            var combineOnce = true;
            for (var i = 0; i < primitives.length; i++) {
                var primitive = primitives[i];
                if (combineOnce) {
                    combineOnce = false;
                    var orginVertexCount = mesh.vertexCount;
                    var orginAttributes = primitives[i].attributes;
                    var positionBuffer = mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.POSITION));
                    for (var j = 0, l = positionBuffer.length; j < l; j += 3) {
                        //转换成世界坐标后在转换为合并节点的本地坐标
                        helpVec3_1.fromArray(positionBuffer, j).applyMatrix(worldMatrix).applyMatrix(helpInverseMatrix);
                        combinePosition[positonIndex++] = helpVec3_1.x;
                        combinePosition[positonIndex++] = helpVec3_1.y;
                        combinePosition[positonIndex++] = helpVec3_1.z;
                    }
                    if (meshAttribute["NORMAL" /* NORMAL */]) {
                        if (orginAttributes.NORMAL) {
                            var normalBuffer = mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.NORMAL));
                            for (var j = 0, l = normalBuffer.length; j < l; j += 3) {
                                helpVec3_1.fromArray(normalBuffer, j).applyDirection(worldMatrix).applyDirection(helpInverseMatrix);
                                combineNormal[normalIndex++] = helpVec3_1.x;
                                combineNormal[normalIndex++] = helpVec3_1.y;
                                combineNormal[normalIndex++] = helpVec3_1.z;
                            }
                        }
                        else {
                            _fillBuffer(combineNormal, normalIndex, orginVertexCount, [0, 0, 0]);
                            normalIndex += orginVertexCount * 3;
                        }
                    }
                    if (meshAttribute["TEXCOORD_0" /* TEXCOORD_0 */]) {
                        if (orginAttributes.TEXCOORD_0) {
                            _copyAccessorBuffer(mesh, orginAttributes.TEXCOORD_0, combineUV0, uv0Index);
                        }
                        else {
                            _fillBuffer(combineUV0, uv0Index, orginVertexCount, [0, 0]);
                        }
                        uv0Index += orginVertexCount * 2;
                    }
                    if (meshAttribute["TEXCOORD_1" /* TEXCOORD_1 */]) {
                        if (combineInstance.lightmapIndex >= 0) {
                            //如果有lightmap,那么将被合并的uv1的坐标转换为root下的坐标,有可能uv1没有，那用uv0来算
                            var uvAccessor = orginAttributes.TEXCOORD_1 ? mesh.getAccessor(orginAttributes.TEXCOORD_1) : mesh.getAccessor(orginAttributes.TEXCOORD_0);
                            var uvBuffer = mesh.createTypeArrayFromAccessor(uvAccessor);
                            //
                            for (var j = 0, l = uvBuffer.length; j < l; j += 2) {
                                var u = uvBuffer[j + 0];
                                var v = uvBuffer[j + 1];
                                u = ((u * orginLightmapScaleOffset.x + orginLightmapScaleOffset.z) - lightmapScaleOffset.z) / lightmapScaleOffset.x;
                                v = ((v * orginLightmapScaleOffset.y - orginLightmapScaleOffset.y - orginLightmapScaleOffset.w) + lightmapScaleOffset.w + lightmapScaleOffset.x) / lightmapScaleOffset.x;
                                combineUV1[uv1Index++] = u;
                                combineUV1[uv1Index++] = v;
                            }
                        }
                        else {
                            if (orginAttributes.TEXCOORD_1 !== undefined) {
                                _copyAccessorBuffer(mesh, orginAttributes.TEXCOORD_1, combineUV1, uv1Index);
                            }
                            else {
                                _fillBuffer(combineUV1, uv1Index, orginVertexCount, [0, 0]);
                            }
                            uv1Index += orginVertexCount * 2;
                        }
                    }
                    if (meshAttribute["COLOR_0" /* COLOR_0 */]) {
                        if (orginAttributes.COLOR_0) {
                            _copyAccessorBuffer(mesh, orginAttributes.COLOR_0, combineColor0, color0Index);
                        }
                        else {
                            _fillBuffer(combineColor0, color0Index, orginVertexCount, [1, 1, 1, 1]);
                        }
                        color0Index += orginVertexCount * 4;
                    }
                    if (meshAttribute["COLOR_1" /* COLOR_1 */]) {
                        if (orginAttributes.COLOR_1) {
                            _copyAccessorBuffer(mesh, orginAttributes.COLOR_1, combineColor0, color1Index);
                        }
                        else {
                            _fillBuffer(combineColor0, color1Index, orginVertexCount, [1, 1, 1, 1]);
                        }
                        color1Index += orginVertexCount * 4;
                    }
                    if (meshAttribute["JOINTS_0" /* JOINTS_0 */]) {
                        if (orginAttributes.JOINTS_0) {
                            _copyAccessorBuffer(mesh, orginAttributes.JOINTS_0, combineJoint0, jointIndex);
                        }
                        else {
                            _fillBuffer(combineJoint0, jointIndex, orginVertexCount, [0, 0, 0, 0]);
                        }
                        jointIndex += orginVertexCount * 4;
                    }
                    if (meshAttribute["WEIGHTS_0" /* WEIGHTS_0 */]) {
                        if (orginAttributes.WEIGHTS_0) {
                            _copyAccessorBuffer(mesh, orginAttributes.WEIGHTS_0, combineWeight0, weightIndex);
                        }
                        else {
                            _fillBuffer(combineWeight0, weightIndex, orginVertexCount, [1, 0, 0, 0]);
                        }
                        weightIndex += orginVertexCount * 4;
                    }
                }
                var indicesBuffer = mesh.createTypeArrayFromAccessor(mesh.getAccessor(primitive.indices));
                for (var j = 0, l = indicesBuffer.length; j < l; j++) {
                    var index = indicesBuffer[j] + startIndex;
                    combineIndices[indexIndex++] = index;
                    endIndex = index > endIndex ? index : endIndex;
                }
                if (!subIndexBuffersCount[i]) {
                    subIndexBuffersCount[i] = 0;
                }
                subIndexBuffersCount[i] += indicesBuffer.length;
            }
            startIndex = endIndex + 1;
            meshFilter.mesh = null;
        }
        //TODO submesh创建有问题
        for (var i = 1, l = subIndexBuffersCount.length; i < l; i++) {
            var subLen = subIndexBuffersCount[i];
            //第一个submesh在构造函数中已经添加，需要手动添加后续的
            combineMesh.addSubMesh(subLen, i);
        }
        return combineMesh;
    }
    /**
     * 尝试对场景内所有静态对象合并
     * @deprecated
     */
    function autoCombine(scene) {
        combine(scene.gameObjects);
    }
    egret3d.autoCombine = autoCombine;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var creater;
    (function (creater) {
        /**
         * 根据提供的参数，快速创建一个带有网格渲染组件的实体。
         */
        function createGameObject(name, _a) {
            if (name === void 0) { name = "NoName" /* NoName */; }
            var _b = _a === void 0 ? {} : _a, _c = _b.tag, tag = _c === void 0 ? "Untagged" /* Untagged */ : _c, _d = _b.scene, scene = _d === void 0 ? null : _d, _e = _b.mesh, mesh = _e === void 0 ? null : _e, _f = _b.material, material = _f === void 0 ? null : _f, _g = _b.materials, materials = _g === void 0 ? null : _g, _h = _b.castShadows, castShadows = _h === void 0 ? false : _h, _j = _b.receiveShadows, receiveShadows = _j === void 0 ? false : _j;
            var gameObject = paper.GameObject.create(name, tag, scene);
            var meshFilter = gameObject.addComponent(egret3d.MeshFilter);
            var meshRenderer = gameObject.addComponent(egret3d.MeshRenderer);
            meshRenderer.castShadows = castShadows;
            meshRenderer.receiveShadows = receiveShadows;
            if (mesh) {
                meshFilter.mesh = mesh;
            }
            if (materials) {
                meshRenderer.materials = materials;
            }
            else if (material) {
                meshRenderer.material = material;
            }
            return gameObject;
        }
        creater.createGameObject = createGameObject;
    })(creater = egret3d.creater || (egret3d.creater = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     * 贝塞尔曲线，目前定义了三种：线性贝塞尔曲线(两个点形成),二次方贝塞尔曲线（三个点形成），三次方贝塞尔曲线（四个点形成）
     */
    var Curve3 = (function () {
        /**
         * @internal
         */
        function Curve3(beizerPoints, bezierPointNum) {
            this.beizerPoints = beizerPoints;
            this.bezierPointNum = bezierPointNum;
        }
        /**
         * 线性贝塞尔曲线
         */
        Curve3.createLinearBezier = function (start, end, indices) {
            indices = indices > 2 ? indices : 3;
            var bez = new Array();
            var equation = function (t, va10, va11) {
                var res = (1.0 - t) * va10 + t * va11;
                return res;
            };
            bez.push(start);
            for (var i = 1; i <= indices; i++) {
                bez.push(new egret3d.Vector3(equation(i / indices, start.x, end.x), equation(i / indices, start.y, start.y), equation(i / indices, start.z, start.z)));
            }
            return new Curve3(bez, indices);
        };
        /**
         * 二次方贝塞尔曲线路径
         * @param v0 起始点
         * @param v1 选中的节点
         * @param v2 结尾点
         * @param bezierPointNum 将贝塞尔曲线拆分bezierPointNum段，一共有bezierPointNum + 1个点
         * @returns 贝塞尔曲线对象
         */
        Curve3.createQuadraticBezier = function (v0, v1, v2, bezierPointNum) {
            bezierPointNum = bezierPointNum > 2 ? bezierPointNum : 3;
            var beizerPoint = new Array();
            var equation = function (t, val0, val1, val2) {
                var res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;
                return res;
            };
            for (var i = 1; i <= bezierPointNum; i++) {
                beizerPoint.push(new egret3d.Vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z)));
            }
            return new Curve3(beizerPoint, bezierPointNum);
        };
        /**
         * 三次方贝塞尔曲线路径
         * @param v0 起始点
         * @param v1 第一个插值点
         * @param v2 第二个插值点
         * @param v3 终点
         * @param bezierPointNum 将贝塞尔曲线拆分bezierPointNum段，一共有bezierPointNum + 1个点
         * @returns 贝塞尔曲线对象
         */
        Curve3.createCubicBezier = function (v0, v1, v2, v3, bezierPointNum) {
            bezierPointNum = bezierPointNum > 3 ? bezierPointNum : 4;
            var beizerPoint = new Array();
            var equation = function (t, val0, val1, val2, val3) {
                var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;
                return res;
            };
            for (var i = 1; i <= bezierPointNum; i++) {
                beizerPoint.push(new egret3d.Vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x, v3.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y, v3.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z, v3.z)));
            }
            return new Curve3(beizerPoint, bezierPointNum);
        };
        return Curve3;
    }());
    egret3d.Curve3 = Curve3;
    __reflect(Curve3.prototype, "egret3d.Curve3");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 射线。
     */
    var Ray = (function (_super) {
        __extends(Ray, _super);
        /**
         * 请使用 `egret3d.Ray.create()` 创建实例。
         * @see egret3d.Ray.create()
         */
        function Ray() {
            var _this = _super.call(this) || this;
            /**
             * 射线的起点。
             */
            _this.origin = egret3d.Vector3.create();
            /**
             * 射线的方向。
             */
            _this.direction = egret3d.Vector3.create();
            return _this;
        }
        /**
         * 创建一个射线。
         * @param origin 射线的起点。
         * @param direction 射线的方向。
         */
        Ray.create = function (origin, direction) {
            if (origin === void 0) { origin = egret3d.Vector3.ZERO; }
            if (direction === void 0) { direction = egret3d.Vector3.FORWARD; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(origin, direction);
                instance._released = false;
                return instance;
            }
            return new Ray().set(origin, direction);
        };
        Ray.prototype.serialize = function () {
            return [this.origin.x, this.origin.y, this.origin.z, this.direction.x, this.direction.y, this.direction.z];
        };
        Ray.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Ray.prototype.copy = function (value) {
            return this.set(value.origin, value.direction);
        };
        Ray.prototype.clone = function () {
            return Ray.create(this.origin, this.direction);
        };
        Ray.prototype.set = function (origin, direction) {
            this.origin.copy(origin);
            this.direction.copy(direction);
            return this;
        };
        Ray.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this.origin.fromArray(value, offset);
            this.direction.fromArray(value, offset + 3);
            return this;
        };
        /**
         * 设置该射线，使其从起点出发，经过终点。
         * @param from 起点。
         * @param to 终点。
         */
        Ray.prototype.fromPoints = function (from, to) {
            this.direction.subtract(to, this.origin.copy(from)).normalize();
            return this;
        };
        Ray.prototype.applyMatrix = function (matrix, input) {
            this.origin.applyMatrix(matrix, (input || this).origin);
            this.direction.applyDirection(matrix, (input || this).direction);
            return this;
        };
        /**
         * 获取一个点到该射线的最近点。
         * @param point 一个点。
         * @param out 最近点。
         */
        Ray.prototype.getClosestPointToPoint = function (point, out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            var origin = out !== this.origin ? this.origin : egret3d.helpVector3A.copy(this.origin);
            var direction = this.direction;
            var directionDistance = out.subtract(point, origin).dot(direction);
            if (directionDistance < 0.0) {
                return out.copy(origin);
            }
            return out.copy(direction).multiplyScalar(directionDistance).add(origin);
        };
        /**
         * 获取从该射线的起点沿着射线方向移动一段距离的一个点。
         * - out = ray.origin + ray.direction * distanceDelta
         * @param distanceDelta 移动距离。
         * @param out 一个点。
         */
        Ray.prototype.getPointAt = function (distanceDelta, out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            var origin = out !== this.origin ? this.origin : egret3d.helpVector3A.copy(this.origin);
            return out.multiplyScalar(distanceDelta, this.direction).add(origin);
        };
        /**
         * 获取一个点到该射线的最近距离的平方。
         * @param point 一个点。
         */
        Ray.prototype.getSquaredDistance = function (point) {
            var origin = this.origin;
            var directionDistance = egret3d.helpVector3A.subtract(point, origin).dot(this.direction);
            // point behind the ray
            if (directionDistance < 0.0) {
                return origin.getSquaredDistance(point);
            }
            return this.getPointAt(directionDistance, egret3d.helpVector3A).getSquaredDistance(point);
        };
        /**
         * 获取一个点到该射线的最近距离。
         * @param point 一个点。
         */
        Ray.prototype.getDistance = function (point) {
            return Math.sqrt(this.getSquaredDistance(point));
        };
        /**
         * 获取该射线起点到一个平面的最近距离。
         * - 如果射线并不与平面相交，则返回 -1。
         * @param plane 一个平面。
         */
        Ray.prototype.getDistanceToPlane = function (plane) {
            var origin = this.origin;
            var planeNormal = plane.normal;
            var denominator = planeNormal.dot(this.direction);
            if (denominator === 0.0) {
                // line is coplanar, return origin
                if (plane.getDistance(origin) === 0.0) {
                    return 0.0;
                }
                // Null is preferable to undefined since undefined means.... it is undefined
                return -1.0;
            }
            var t = -(origin.dot(planeNormal) + plane.constant) / denominator;
            // Return if the ray never intersects the plane
            return t >= 0.0 ? t : -1.0;
        };
        Ray._instances = [];
        return Ray;
    }(paper.BaseRelease));
    egret3d.Ray = Ray;
    __reflect(Ray.prototype, "egret3d.Ray", ["paper.ICCS", "paper.ISerializable"]);
    /**
     * @internal
     */
    egret3d.helpRay = Ray.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 应用程序。
     *
     * ### 自动刷新和被动刷新
     *
     * 默认情况下
     *
     * - 自动刷新: 会以无限循环方式刷新, `PlayerMode.Player` 模式默认为自动刷新
     * - 被动刷新: 不会启动循环, 需要刷新时需调用 `update()` 方法, `PlayerMode.Editor` 模式为被动刷新
     *
     * 在运行过程中可随时调用 `resume()` 切换到自动刷新, 或者调用 `pause()` 切换为被动刷新
     *
     * ### 限制帧频
     *
     * - 通过设置 `clock.frameInterval` 来设置渲染帧间隔(秒)
     * - 通过设置 `clock.tickInterval` 来设置逻辑帧间隔(秒)
     * - 在帧补偿的时候, 为了尽快达到同步, `clock.update()` 会在同步之前忽略此间隔, 也就是说在这种情况下, 帧率会增加, 只有逻辑帧会补偿
     */
    var ECS = (function () {
        function ECS() {
            /**
             * 当应用程序的播放模式改变时派发事件。
             */
            this.onPlayerModeChanged = new signals.Signal();
            // /**
            //  * 
            //  */
            // public delayStatrup: uint = 0;
            /**
             * 引擎版本。
             */
            this.version = "1.5.1.001";
            /**
             * 程序启动项。
             */
            this.options = null;
            /**
             * 系统管理器。
             */
            this.systemManager = paper.SystemManager.getInstance();
            /**
             * 场景管理器。
             */
            this.sceneManager = paper.SceneManager.getInstance();
            /**
             *
             */
            this.gameObjectContext = paper.Context.create(paper.GameObject);
            this._isFocused = false;
            this._isRunning = false;
            this._playerMode = 1 /* Player */;
            this._loop = this._loop.bind(this);
        }
        /**
         * 应用程序单例。
         */
        ECS.getInstance = function () {
            if (!this._instance) {
                this._instance = new ECS();
            }
            return this._instance;
        };
        // private _runOptions: RunOptions | null = null;
        /**
         * core updating loop
         */
        ECS.prototype._loop = function (timestamp) {
            if (!this._isRunning) {
                return;
            }
            if (!timestamp) {
                requestAnimationFrame(this._loop);
                return;
            }
            // 由 clock 组件计算此次循环可以产生多少个逻辑帧和多少个渲染帧
            var result = paper.clock.update(timestamp) || { tickCount: 1, frameCount: 1 };
            // 根据上述结果进行更新
            this._update(result);
            // 下一次循环
            requestAnimationFrame(this._loop);
        };
        /**
         * including calculating, status updating, rerendering and logical updating
         */
        ECS.prototype._update = function (_a) {
            var _b = _a === void 0 ? { tickCount: 1, frameCount: 1 } : _a, tickCount = _b.tickCount, frameCount = _b.frameCount;
            // TOFIX: 只有逻辑帧不为零的时候, systemManager 的以下部分才做才有意义
            if (!tickCount) {
                return;
            }
            var systemManager = this.systemManager;
            systemManager._startup();
            systemManager._execute(tickCount, frameCount);
            systemManager._cleanup(frameCount);
            systemManager._teardown();
        };
        /**
         * 初始化程序。
         */
        ECS.prototype.initialize = function (options) {
            console.info("Egret", this.version, "start.");
            this.options = options;
            this._playerMode = options.playerMode;
        };
        /**
         * 注册程序系统。
         */
        ECS.prototype.registerSystems = function () {
            var _a = this, systemManager = _a.systemManager, gameObjectContext = _a.gameObjectContext;
            systemManager.register(paper.EnableSystem, gameObjectContext, 1000 /* Enable */, this.options);
            systemManager.register(paper.StartSystem, gameObjectContext, 2000 /* Start */);
            systemManager.register(paper.FixedUpdateSystem, gameObjectContext, 3000 /* FixedUpdate */);
            systemManager.register(paper.UpdateSystem, gameObjectContext, 4000 /* Update */);
            systemManager.register(paper.LateUpdateSystem, gameObjectContext, 6000 /* LateUpdate */);
            systemManager.register(paper.DisableSystem, gameObjectContext, 9000 /* Disable */);
            systemManager.preRegisterSystems();
        };
        /**
         * TODO
         * @internal
         */
        ECS.prototype.pause = function () {
            this._isRunning = false;
            paper.clock.reset();
        };
        /**
         * TODO
         * @internal
         */
        ECS.prototype.resume = function () {
            if (this._isRunning) {
                return;
            }
            this._isRunning = true;
            paper.clock.reset();
            requestAnimationFrame(this._loop);
        };
        /**
         * engine start
         *
         * TODO:
         */
        ECS.prototype.start = function () {
            switch (this._playerMode) {
                case 4 /* Editor */:
                    this.pause();
                    this._update();
                    break;
                case 1 /* Player */:
                // breakthrough
                case 2 /* DebugPlayer */:
                    this.resume();
                    break;
                default:
                    break;
            }
            console.info("Egret start complete.");
        };
        /**
         * 显式更新
         *
         * - 在暂停的情况下才有意义 (`this.isRunning === false`), 因为在运行的情况下下一帧自动会刷新
         * - 主要应用在类似编辑器模式下, 大多数情况只有数据更新的时候界面才需要刷新
         */
        ECS.prototype.update = function () {
            // if it is running, updating will occur in next frame
            if (this._isRunning) {
                return;
            }
            this._update();
        };
        Object.defineProperty(ECS.prototype, "isMobile", {
            /**
             *
             */
            get: function () {
                var userAgent = (navigator && navigator.userAgent) ? navigator.userAgent.toLowerCase() : "";
                return userAgent.indexOf("mobile") >= 0 || userAgent.indexOf("android") >= 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ECS.prototype, "isFocused", {
            /**
             * TODO
             * @internal
             */
            get: function () {
                return this._isFocused;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ECS.prototype, "isRunning", {
            /**
             * TODO
             * @internal
             */
            get: function () {
                return this._isRunning;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ECS.prototype, "playerMode", {
            /**
             * 程序的运行模式。
             */
            get: function () {
                return this._playerMode;
            },
            set: function (value) {
                if (this._playerMode === value) {
                    return;
                }
                this._playerMode = value;
                this.onPlayerModeChanged.dispatch(this.playerMode);
            },
            enumerable: true,
            configurable: true
        });
        ECS._instance = null;
        return ECS;
    }());
    paper.ECS = ECS;
    __reflect(ECS.prototype, "paper.ECS");
    /**
     * 应用程序单例。
     */
    paper.Application = ECS.getInstance();
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var _index = 0;
    var _mask = 0x80000000;
    var _allDefines = {};
    function _get(name, context, order) {
        var key = context ? (typeof context === "number" ? name + " " + context : context) : name;
        var defines = _allDefines;
        var define = defines[key];
        if (define) {
            return define;
        }
        define = defines[key] = new Define(_index, _mask, name, context);
        if (order) {
            define.order = order;
        }
        _mask >>>= 1;
        if (_mask === 0) {
            _index++;
            _mask = 0x80000000;
        }
        return define;
    }
    /**
     * @private
     */
    var DefineLocation;
    (function (DefineLocation) {
        DefineLocation[DefineLocation["None"] = 0] = "None";
        DefineLocation[DefineLocation["All"] = 3] = "All";
        DefineLocation[DefineLocation["Vertex"] = 1] = "Vertex";
        DefineLocation[DefineLocation["Fragment"] = 2] = "Fragment";
    })(DefineLocation = egret3d.DefineLocation || (egret3d.DefineLocation = {}));
    /**
     * @private
     */
    var Define = (function () {
        function Define(index, mask, name, context) {
            this.index = index;
            this.mask = mask;
            this.name = name;
            this.context = context;
        }
        return Define;
    }());
    egret3d.Define = Define;
    __reflect(Define.prototype, "egret3d.Define");
    /**
     * @private
     */
    var Defines = (function () {
        function Defines() {
            this.definesMask = "";
            // mask, string, array,
            this._defines = [];
            this._defineLinks = {};
        }
        Defines.link = function (definess, location) {
            var linked = [];
            var linkedName = {};
            for (var _i = 0, definess_1 = definess; _i < definess_1.length; _i++) {
                var defines = definess_1[_i];
                if (!defines) {
                    continue;
                }
                for (var _a = 0, _b = defines._defines; _a < _b.length; _a++) {
                    var define = _b[_a];
                    if (define.type === undefined || (define.type & location)) {
                        var already = linkedName[define.name];
                        if (!already) {
                            linkedName[define.name] = define;
                            linked.push(define);
                        }
                        else {
                            var index = linked.indexOf(already);
                            if (index >= 0) {
                                linked[index] = define;
                            }
                        }
                    }
                }
            }
            var definesString = "";
            linked.sort(this._sortDefine);
            for (var _c = 0, linked_1 = linked; _c < linked_1.length; _c++) {
                var define = linked_1[_c];
                var context = define.context;
                if (context) {
                    // if (typeof context === "number") {
                    if (!define.isCode) {
                        context = define.name + " " + context;
                    }
                }
                else {
                    context = define.name;
                }
                if (define.isCode) {
                    definesString += context + " \n";
                }
                else {
                    definesString += "#define " + context + " \n";
                }
            }
            return definesString;
        };
        Defines._sortDefine = function (a, b) {
            if (a.order && b.order) {
                return a.order - b.order;
            }
            var d = a.index - b.index;
            if (d === 0) {
                d = (b.order || b.mask) - (a.order || a.mask); // Define 顺序。
            }
            return d;
        };
        Defines.prototype._update = function () {
            var index = 0;
            var mask = 0;
            var definesMask = "";
            var defines = this._defines;
            defines.sort(Defines._sortDefine);
            for (var _i = 0, defines_1 = defines; _i < defines_1.length; _i++) {
                var define = defines_1[_i];
                if (define.index !== index) {
                    if (mask < 0) {
                        mask += 0xFFFFFFFF;
                        mask += 1;
                    }
                    definesMask += index + "x" + mask.toString(16);
                    index = define.index;
                    mask = 0;
                }
                mask |= define.mask;
            }
            if (mask < 0) {
                mask += 0xFFFFFFFF;
                mask += 1;
            }
            definesMask += index + "x" + mask.toString(32);
            this.definesMask = definesMask;
        };
        /**
         *
         */
        Defines.prototype.clear = function () {
            this.definesMask = "";
            this._defines.length = 0;
            for (var k in this._defineLinks) {
                delete this._defineLinks[k];
            }
        };
        /**
         *
         */
        Defines.prototype.copy = function (value) {
            this.definesMask = value.definesMask;
            this._defines.length = 0;
            for (var _i = 0, _a = value._defines; _i < _a.length; _i++) {
                var define = _a[_i];
                this._defines.push(define);
            }
            for (var k in value._defineLinks) {
                this._defineLinks[k] = value._defineLinks[k];
            }
        };
        /**
         *
         */
        Defines.prototype.addDefine = function (name, context, order) {
            var define = this._defineLinks[name];
            if (define) {
                if (define.context === context) {
                    return define;
                }
                else {
                    this.removeDefine(name, false);
                }
            }
            //
            define = _get(name, context, order);
            var defines = this._defines;
            if (defines.indexOf(define) < 0) {
                defines.push(define);
                this._defineLinks[name] = define;
                this._update();
                return define;
            }
            return null;
        };
        Defines.prototype.removeDefine = function (name, needUpdate) {
            if (needUpdate === void 0) { needUpdate = true; }
            var define = this._defineLinks[name];
            if (define) {
                var index = this._defines.indexOf(define);
                if (index >= 0) {
                    this._defines.splice(index, 1);
                }
                delete this._defineLinks[name];
                //
                needUpdate && this._update();
            }
            return null;
        };
        return Defines;
    }());
    egret3d.Defines = Defines;
    __reflect(Defines.prototype, "egret3d.Defines");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    //TODO 运行时DrawCall排序优化使用
    var _hashCode = 0;
    var _uvTransformMatrix = egret3d.Matrix3.create();
    /**
     *
     */
    var MaterialDirty;
    (function (MaterialDirty) {
        MaterialDirty[MaterialDirty["All"] = 1] = "All";
        MaterialDirty[MaterialDirty["None"] = 0] = "None";
        MaterialDirty[MaterialDirty["UVTransform"] = 1] = "UVTransform";
    })(MaterialDirty = egret3d.MaterialDirty || (egret3d.MaterialDirty = {}));
    /**
     * 材质资源。
     */
    var Material = (function (_super) {
        __extends(Material, _super);
        function Material() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.defines = new egret3d.Defines();
            /**
             * @internal
             */
            _this._id = _hashCode++;
            /**
             * @internal
             */
            _this._version = 0;
            /**
             * @internal
             */
            _this._dirty = 0 /* None */;
            /**
             * 仅为更高的访问性能，该值存在于 config 中，是否有必要保留该值。
             * @internal
             */
            _this._renderQueue = 2000 /* Geometry */;
            _this._uvTransform = [0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0];
            /**
             * @internal
             */
            _this._technique = null;
            /**
             * @internal
             */
            _this._shader = null;
            _this.needUpdate = function (dirty) {
                _this._dirty |= dirty;
                _this._version++;
            };
            return _this;
        }
        Material.create = function (shaderOrName, shaderOrConfig) {
            var hasName = typeof shaderOrName === "string";
            var name = (shaderOrName && hasName) ? shaderOrName : "";
            //
            if (shaderOrName === undefined) {
                shaderOrConfig = shaderOrConfig || egret3d.DefaultShaders.MESH_BASIC;
            }
            else if (!hasName) {
                shaderOrConfig = shaderOrName || shaderOrConfig || egret3d.DefaultShaders.MESH_BASIC;
            }
            //
            var material = new Material();
            material.initialize(name, null, null);
            material._reset(shaderOrConfig);
            return material;
        };
        Material.prototype._createTechnique = function (shader, glTFMaterial) {
            var _a = shader.config.extensions.KHR_techniques_webgl.techniques[0], sourceAttributes = _a.attributes, sourceUniforms = _a.uniforms;
            var materialUniformValues = glTFMaterial.extensions.KHR_techniques_webgl.values;
            var shaderDefines = shader._defines;
            var materialDefines = glTFMaterial.extensions.paper.defines;
            var technique = {
                attributes: {},
                uniforms: {},
            };
            // Remove redundant material uniform values.
            if (materialUniformValues) {
                for (var k in materialUniformValues) {
                    if (!(k in sourceUniforms)) {
                        delete materialUniformValues[k];
                    }
                }
            }
            // Copy attributes.
            for (var k in sourceAttributes) {
                var attribute = sourceAttributes[k];
                technique.attributes[k] = {
                    semantic: attribute.semantic,
                };
            }
            // Copy uniforms.
            for (var k in sourceUniforms) {
                var sourceUniform = sourceUniforms[k];
                var sourceValue = (materialUniformValues && (k in materialUniformValues)) ? materialUniformValues[k] : sourceUniform.value; // shader -> material -> technique.
                var type = sourceUniform.type;
                var value = void 0;
                if (type === 35678 /* SAMPLER_2D */ || type === 35680 /* SAMPLER_CUBE */) {
                    if (sourceValue) {
                        value = paper.Asset.find(sourceValue) || egret3d.DefaultTextures.WHITE; // Missing texture.
                    }
                    // else if (!value) {
                    //     value = DefaultTextures.WHITE; // 非法数据.
                    // }
                }
                else if (Array.isArray(sourceValue)) {
                    value = sourceValue ? sourceValue.concat() : []; // TODO
                }
                else {
                    value = sourceValue ? sourceValue : (sourceValue === 0 ? 0 : []); // TODO 不应是数组。
                    // value = sourceValue ? sourceValue : 0; //
                }
                var targetUniform = technique.uniforms[k] = { type: type, value: value };
                if (sourceUniform.semantic) {
                    targetUniform.semantic = sourceUniform.semantic;
                }
            }
            //
            if (glTFMaterial.extensions.paper.states) {
                var states = technique.states = glTFMaterial.extensions.paper.states; // TODO 如果编辑器编辑该值，最简单的方式是做关联。
                // TODO
                if (!states.enable) {
                    states.enable = [];
                }
                if (!states.functions) {
                    states.functions = {};
                }
            }
            else {
                var shaderStates = shader._states || shader.config.extensions.KHR_techniques_webgl.techniques[0].states;
                if (shaderStates) {
                    technique.states = {
                        enable: [],
                        functions: {},
                    };
                    egret3d.Shader.copyStates(shaderStates, technique.states);
                }
                else {
                    technique.states = egret3d.Shader.createDefaultStates();
                }
            }
            //
            if (technique.states.enable.indexOf(2884 /* CullFace */) >= 0) {
                var frontFaceValue = technique.states.functions.frontFace;
                var cullFaceValue = technique.states.functions.cullFace;
                var frontFace = frontFaceValue && frontFaceValue.length > 0 ? frontFaceValue[0] : 2305 /* CCW */;
                var cullFace = cullFaceValue && cullFaceValue.length > 0 ? cullFaceValue[0] : 1029 /* Back */;
                this.defines.removeDefine("DOUBLE_SIDED" /* DOUBLE_SIDED */);
                if (frontFace !== 2305 /* CCW */ || cullFace !== 1029 /* Back */) {
                    this.defines.addDefine("FLIP_SIDED" /* FLIP_SIDED */);
                }
                else {
                    this.defines.removeDefine("FLIP_SIDED" /* FLIP_SIDED */);
                }
            }
            else {
                this.defines.removeDefine("FLIP_SIDED" /* FLIP_SIDED */);
                this.defines.addDefine("DOUBLE_SIDED" /* DOUBLE_SIDED */);
            }
            // Copy defines.
            if (materialDefines) {
                for (var _i = 0, materialDefines_1 = materialDefines; _i < materialDefines_1.length; _i++) {
                    var define = materialDefines_1[_i];
                    this.defines.addDefine(define);
                }
            }
            //TODO 兼容以前的
            if (shaderDefines) {
                for (var _b = 0, shaderDefines_1 = shaderDefines; _b < shaderDefines_1.length; _b++) {
                    var define = shaderDefines_1[_b];
                    this.defines.addDefine(define);
                }
            }
            return technique;
        };
        Material.prototype._reset = function (shaderOrConfig) {
            var glTFMaterial;
            var shader = null;
            //
            if (shaderOrConfig instanceof egret3d.Shader) {
                if (this.config) {
                    this._retainOrReleaseTextures(false, false);
                    this._addOrRemoveTexturesDefine(false);
                    glTFMaterial = this.config.materials[0];
                }
                else {
                    var config = this.config = Material.createConfig();
                    glTFMaterial = {
                        extensions: {
                            KHR_techniques_webgl: { technique: shaderOrConfig.name },
                            paper: { renderQueue: shaderOrConfig._renderQueue ? shaderOrConfig._renderQueue : 2000 /* Geometry */ }
                        }
                    };
                    config.materials = [glTFMaterial];
                }
                shader = shaderOrConfig;
            }
            else {
                var config = this.config = shaderOrConfig;
                glTFMaterial = config.materials[0];
                shader = paper.Asset.find(glTFMaterial.extensions.KHR_techniques_webgl.technique) || egret3d.DefaultShaders.MESH_BASIC;
            }
            //
            this._renderQueue = glTFMaterial.extensions.paper.renderQueue;
            this._technique = this._createTechnique(shader, glTFMaterial);
            this._shader = shader;
            this._retainOrReleaseTextures(true, false);
            this._addOrRemoveTexturesDefine(true);
        };
        Material.prototype._retainOrReleaseTextures = function (isRatain, isOnce) {
            var uniforms = this._technique.uniforms;
            for (var k in uniforms) {
                var uniform = uniforms[k];
                if (uniform.value &&
                    (uniform.type === 35678 /* SAMPLER_2D */ || uniform.type === 35680 /* SAMPLER_CUBE */)) {
                    if (isOnce) {
                        isRatain ? uniform.value.retain() : uniform.value.release();
                    }
                    else {
                        var i = this.referenceCount;
                        while (i--) {
                            isRatain ? uniform.value.retain() : uniform.value.release();
                        }
                    }
                }
            }
            // isRatain ? this._shader.retain() : this._shader.release(); TODO
        };
        Material.prototype._addOrRemoveTexturesDefine = function (add) {
            if (add === void 0) { add = true; }
            var uniforms = this._technique.uniforms;
            for (var k in uniforms) {
                var uniform = uniforms[k];
                if (uniform.value &&
                    (uniform.type === 35678 /* SAMPLER_2D */ || uniform.type === 35680 /* SAMPLER_CUBE */)) {
                    var texture = uniform.value;
                    egret3d.renderState._updateTextureDefines(k, add ? texture : null, this.defines);
                }
            }
        };
        /**
         * @internal
         */
        Material.prototype._update = function () {
            if (this._dirty & 1 /* UVTransform */) {
                this.setUVTransform(_uvTransformMatrix.fromUVTransform.apply(_uvTransformMatrix, this._uvTransform));
                this._dirty &= ~1 /* UVTransform */;
            }
        };
        Material.prototype.initialize = function (name, config, buffers) {
            var args = [];
            for (var _i = 3; _i < arguments.length; _i++) {
                args[_i - 3] = arguments[_i];
            }
            _super.prototype.initialize.call(this, name, config, buffers, args);
            egret3d.renderState.onGammaInputChanged.add(this._addOrRemoveTexturesDefine, this);
        };
        Material.prototype.retain = function () {
            _super.prototype.retain.call(this);
            this._retainOrReleaseTextures(true, true);
            return this;
        };
        Material.prototype.release = function () {
            _super.prototype.release.call(this);
            if (this._referenceCount >= 0) {
                this._retainOrReleaseTextures(false, true);
            }
            return this;
        };
        Material.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            egret3d.renderState.onGammaInputChanged.remove(this._addOrRemoveTexturesDefine, this);
            this._retainOrReleaseTextures(false, false);
            //
            this.defines.clear();
            this._technique = null;
            this._shader = null;
            return true;
        };
        /**
         * 拷贝。
         * TODO
         */
        Material.prototype.copy = function (value) {
            this._retainOrReleaseTextures(false, false);
            //
            this._renderQueue = value.renderQueue;
            this._shader = value._shader;
            this.defines.copy(value.defines);
            // Copy uniforms.
            var sourceUniforms = value._technique.uniforms;
            var targetUniforms = this._technique.uniforms = {};
            for (var k in sourceUniforms) {
                var uniform = sourceUniforms[k];
                var uniformValue = uniform.value;
                targetUniforms[k] = {
                    type: uniform.type,
                    semantic: uniform.semantic,
                    value: Array.isArray(uniformValue) ? uniformValue.concat() : uniformValue,
                };
            }
            // Copy states and functions.
            var sourceStates = value._technique.states;
            var targetStates = this._technique.states;
            targetStates.enable = sourceStates.enable.concat();
            for (var k in sourceStates.functions) {
                var stateFunction = sourceStates.functions[k];
                targetStates.functions[k] = Array.isArray(stateFunction) ? stateFunction.concat() : stateFunction;
            }
            //
            this._retainOrReleaseTextures(true, false);
            return this;
        };
        /**
         * 克隆该材质。
         */
        Material.prototype.clone = function () {
            return Material.create(this._shader).copy(this);
        };
        Material.prototype.setBoolean = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setInt = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setIntv = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setFloat = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setFloatv = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector2 = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value[0] = value.x;
                uniform.value[1] = value.y;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector2v = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector3 = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value[0] = value.x;
                uniform.value[1] = value.y;
                uniform.value[2] = value.z;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector3v = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector4 = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value[0] = value.x;
                uniform.value[1] = value.y;
                uniform.value[2] = value.z;
                uniform.value[3] = value.w;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector4v = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setMatrix = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value.rawData;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setMatrixv = function (id, value) {
            var uniform = this._technique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        /**
         * 为该材质添加指定的 define。
         * @param defineString define 字符串。
         */
        Material.prototype.addDefine = function (defineString, value) {
            this.defines.addDefine(defineString, value);
            return this;
        };
        /**
         * 从该材质移除指定的 define。
         * @param defineString define 字符串。
         */
        Material.prototype.removeDefine = function (defineString, value) {
            // if (value !== undefined) {
            //     defineString += " " + value;
            // }
            this.defines.removeDefine(defineString);
            return this;
        };
        Material.prototype.setBlend = function (p0, p1, p2, p3) {
            var _a = this._technique.states, enable = _a.enable, functions = _a.functions;
            var blend = Array.isArray(p0) ? -1 /* Custom */ : p0;
            var renderQueue;
            var opacity = undefined;
            if (blend === -1 /* Custom */) {
                functions.blendEquationSeparate = p0;
                functions.blendFuncSeparate = p1;
                renderQueue = p2;
                opacity = p3;
            }
            else {
                switch (blend) {
                    case 4 /* Additive */:
                        functions.blendEquationSeparate = [32774 /* Add */, 32774 /* Add */];
                        functions.blendFuncSeparate = [770 /* SRC_ALPHA */, 1 /* ONE */, 770 /* SRC_ALPHA */, 1 /* ONE */];
                        break;
                    case 5 /* Additive_PreMultiply */:
                        functions.blendEquationSeparate = [32774 /* Add */, 32774 /* Add */];
                        functions.blendFuncSeparate = [1 /* ONE */, 1 /* ONE */, 1 /* ONE */, 1 /* ONE */];
                        break;
                    case 2 /* Normal */:
                        functions.blendEquationSeparate = [32774 /* Add */, 32774 /* Add */];
                        functions.blendFuncSeparate = [770 /* SRC_ALPHA */, 771 /* ONE_MINUS_SRC_ALPHA */, 1 /* ONE */, 771 /* ONE_MINUS_SRC_ALPHA */];
                        break;
                    case 3 /* Normal_PreMultiply */:
                        functions.blendEquationSeparate = [32774 /* Add */, 32774 /* Add */];
                        functions.blendFuncSeparate = [1 /* ONE */, 32772 /* ONE_MINUS_CONSTANT_ALPHA */, 1 /* ONE */, 32772 /* ONE_MINUS_CONSTANT_ALPHA */];
                        break;
                    case 8 /* Subtractive */:
                        functions.blendEquationSeparate = [32774 /* Add */, 32774 /* Add */];
                        functions.blendFuncSeparate = [0 /* ZERO */, 769 /* ONE_MINUS_SRC_COLOR */, 0 /* ZERO */, 769 /* ONE_MINUS_SRC_COLOR */];
                        break;
                    case 9 /* Subtractive_PreMultiply */:
                        functions.blendEquationSeparate = [32774 /* Add */, 32774 /* Add */];
                        functions.blendFuncSeparate = [0 /* ZERO */, 0 /* ZERO */, 769 /* ONE_MINUS_SRC_COLOR */, 771 /* ONE_MINUS_SRC_ALPHA */];
                        break;
                    case 16 /* Multiply */:
                        functions.blendEquationSeparate = [32774 /* Add */, 32774 /* Add */];
                        functions.blendFuncSeparate = [0 /* ZERO */, 768 /* SRC_COLOR */, 0 /* ZERO */, 768 /* SRC_COLOR */];
                        break;
                    case 17 /* Multiply_PreMultiply */:
                        functions.blendEquationSeparate = [32774 /* Add */, 32774 /* Add */];
                        functions.blendFuncSeparate = [0 /* ZERO */, 768 /* SRC_COLOR */, 0 /* ZERO */, 770 /* SRC_ALPHA */];
                        break;
                    default:
                        delete functions.blendEquationSeparate;
                        delete functions.blendFuncSeparate;
                        break;
                }
                renderQueue = p1;
                opacity = p2;
            }
            var index = enable.indexOf(3042 /* Blend */);
            if (blend === 0 /* None */) {
                if (index >= 0) {
                    enable.splice(index, 1);
                }
                //
                functions.depthMask = [true];
            }
            else {
                if (index < 0) {
                    enable.push(3042 /* Blend */);
                }
                //
                functions.depthMask = [false];
            }
            if (renderQueue) {
                this.renderQueue = renderQueue;
            }
            if (opacity !== undefined) {
                this.opacity = opacity;
            }
            return this;
        };
        /**
         * 设置该材质剔除面片的模式。
         * @param cullEnabled 是否开启剔除。
         * @param frontFace 正面的顶点顺序。
         * @param cullFace 剔除模式。
         */
        Material.prototype.setCullFace = function (cullEnabled, frontFace, cullFace) {
            if (frontFace === void 0) { frontFace = 2305 /* CCW */; }
            if (cullFace === void 0) { cullFace = 1029 /* Back */; }
            var _a = this._technique.states, enable = _a.enable, functions = _a.functions;
            var index = enable.indexOf(2884 /* CullFace */);
            if (cullEnabled) {
                if (index < 0) {
                    enable.push(2884 /* CullFace */);
                }
                functions.frontFace = [frontFace];
                functions.cullFace = [cullFace];
                this.defines.removeDefine("DOUBLE_SIDED" /* DOUBLE_SIDED */);
                if (frontFace !== 2305 /* CCW */ || cullFace !== 1029 /* Back */) {
                    this.defines.addDefine("FLIP_SIDED" /* FLIP_SIDED */);
                }
                else {
                    this.defines.removeDefine("FLIP_SIDED" /* FLIP_SIDED */);
                }
            }
            else if (index >= 0) {
                enable.splice(index, 1);
                delete functions.frontFace;
                delete functions.cullFace;
                this.defines.removeDefine("FLIP_SIDED" /* FLIP_SIDED */);
                this.defines.addDefine("DOUBLE_SIDED" /* DOUBLE_SIDED */);
            }
            return this;
        };
        /**
         * 设置该材质的深度检测和深度缓冲。
         * @param depthTest 深度检测。
         * @param depthWrite 深度缓冲。
         */
        Material.prototype.setDepth = function (depthTest, depthWrite) {
            var _a = this._technique.states, enable = _a.enable, functions = _a.functions;
            var index = enable.indexOf(2929 /* DepthTest */);
            if (depthTest) {
                if (index < 0) {
                    enable.push(2929 /* DepthTest */);
                    functions.depthFunc = [515 /* Lequal */];
                }
            }
            else if (index >= 0) {
                enable.splice(index, 1);
                delete functions.depthFunc;
            }
            if (depthWrite) {
                functions.depthMask = [true];
            }
            else {
                functions.depthMask = [false];
            }
            return this;
        };
        /**
         *
         */
        Material.prototype.setStencil = function (value) {
            var enable = this._technique.states.enable;
            var index = enable.indexOf(2960 /* StencilTest */);
            if (value) {
                if (index < 0) {
                    enable.push(2960 /* StencilTest */);
                }
            }
            else if (index >= 0) {
                enable.splice(index);
            }
            return this;
        };
        /**
         * TODO
         * @private
         */
        Material.prototype.clearStates = function () {
            var _a = this._technique.states, enable = _a.enable, functions = _a.functions;
            enable.length = 0;
            for (var k in functions) {
                delete functions[k];
            }
            return this;
        };
        Material.prototype.getColor = function (p1, p2) {
            var uniformName;
            if (!p1) {
                uniformName = "diffuse" /* Diffuse */;
                p2 = egret3d.Color.create();
            }
            else if (p1 instanceof egret3d.Color) {
                uniformName = "diffuse" /* Diffuse */;
                p2 = p1;
            }
            else {
                uniformName = p1;
                if (!p2) {
                    p2 = egret3d.Color.create();
                }
            }
            var uniform = this._technique.uniforms[uniformName];
            if (uniform && uniform.value && Array.isArray(uniform.value)) {
                p2.r = uniform.value[0];
                p2.g = uniform.value[1];
                p2.b = uniform.value[2];
            }
            else if (true) {
                console.error("Invalid glTF technique uniform.");
            }
            return p2;
        };
        Material.prototype.setColor = function (p1, p2) {
            if (typeof p1 !== "string") {
                p2 = p1;
                p1 = "diffuse" /* Diffuse */;
            }
            if (typeof p2 === "number") {
                var color = egret3d.Color.create().fromHex(p2).release();
                this.setVector3(p1, egret3d.Vector3.create(color.r, color.g, color.b).release());
            }
            else {
                this.setVector3(p1, egret3d.Vector3.create(p2.r, p2.g, p2.b).release());
            }
            return this;
        };
        /**
         * 获取该材质的 UV 变换矩阵。
         * @param out 矩阵。
         */
        Material.prototype.getUVTransform = function (out) {
            if (!out) {
                out = egret3d.Matrix3.create();
            }
            var uniform = this._technique.uniforms["uvTransform" /* UVTransform */];
            if (uniform && uniform.value && Array.isArray(uniform.value)) {
                out.fromArray(uniform.value);
            }
            else if (true) {
                console.error("Invalid glTF technique uniform.");
            }
            return out;
        };
        /**
         * 设置该材质的 UV 变换矩阵。
         * @param matrix 矩阵。
         */
        Material.prototype.setUVTransform = function (matrix) {
            var uniform = this._technique.uniforms["uvTransform" /* UVTransform */];
            if (uniform) {
                var array = (uniform.value && Array.isArray(uniform.value)) ? uniform.value : new Array(9);
                matrix.toArray(array);
                this.setMatrixv("uvTransform" /* UVTransform */, array);
            }
            else if (true) {
                console.error("Invalid glTF technique uniform.");
            }
            return this;
        };
        Material.prototype.getTexture = function (uniformName) {
            if (!uniformName) {
                uniformName = "map" /* Map */;
            }
            var uniform = this._technique.uniforms[uniformName];
            if (uniform) {
                return uniform.value || null; // TODO
            }
            else {
                console.error("Invalid glTF technique uniform.", uniformName);
            }
            return null;
        };
        Material.prototype.setTexture = function (p1, p2) {
            if (p1 === null || p1 instanceof egret3d.BaseTexture) {
                p2 = p1;
                p1 = "map" /* Map */;
            }
            // if (!p2) { // null to white.
            //     p2 = DefaultTextures.WHITE;
            // }
            var uniform = this._technique.uniforms[p1];
            if (uniform) {
                if (uniform.value !== p2) {
                    var existingTexture = uniform.value;
                    if (existingTexture) {
                        var i = this.referenceCount;
                        while (i--) {
                            existingTexture.release();
                        }
                        egret3d.renderState._updateTextureDefines(p1, null, this.defines);
                    }
                    if (p2) {
                        var i = this.referenceCount;
                        while (i--) {
                            p2.retain();
                        }
                        egret3d.renderState._updateTextureDefines(p1, p2, this.defines);
                    }
                    uniform.value = p2;
                    this._version++;
                }
            }
            else {
                console.error("Invalid glTF technique uniform.", p1);
            }
            return this;
        };
        Object.defineProperty(Material.prototype, "renderQueue", {
            /**
             * 该材质的渲染排序。
             */
            get: function () {
                return this._renderQueue;
            },
            set: function (value) {
                if (this._renderQueue === value) {
                    return;
                }
                this.config.materials[0].extensions.paper.renderQueue = value;
                this._renderQueue = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "opacity", {
            /**
             * 该材质的透明度。
             */
            get: function () {
                var uniformName = "opacity" /* Opacity */;
                var uniform = this._technique.uniforms[uniformName];
                if (uniform) {
                    var value = uniform.value;
                    return (value !== value) ? 1.0 : value;
                }
                else {
                    console.error("Invalid glTF technique uniform.", uniformName);
                }
                return 1.0;
            },
            set: function (value) {
                this.setFloat("opacity" /* Opacity */, value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "shader", {
            /**
             * 该材质的 shader。
             */
            get: function () {
                return this._shader;
            },
            set: function (value) {
                if (!value) {
                    console.error("Set shader error.");
                    value = egret3d.DefaultShaders.MESH_BASIC;
                }
                if (this._shader === value) {
                    return;
                }
                this._reset(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "technique", {
            /**
             * 该材质的渲染技术。
             */
            get: function () {
                return this._technique;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        Material.prototype.setRenderQueue = function (value) {
            this.renderQueue = value;
            return this;
        };
        /**
         * @deprecated
         */
        Material.prototype.setOpacity = function (value) {
            return this.setFloat("opacity" /* Opacity */, value);
        };
        /**
         * @deprecated
         */
        Material.prototype.setShader = function (value) {
            if (!value) {
                if (true) {
                    console.warn("Set shader error.");
                }
                value = egret3d.DefaultShaders.MESH_BASIC;
            }
            if (this._shader === value) {
                return;
            }
            this._reset(value);
            return this;
        };
        __decorate([
            paper.editor.property("UINT" /* UINT */)
        ], Material.prototype, "renderQueue", null);
        __decorate([
            paper.editor.property("SHADER" /* SHADER */)
        ], Material.prototype, "shader", null);
        return Material;
    }(egret3d.GLTFAsset));
    egret3d.Material = Material;
    __reflect(Material.prototype, "egret3d.Material");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3 = egret3d.Vector3.create();
    /**
     * 几何截头锥体。
     */
    var Frustum = (function (_super) {
        __extends(Frustum, _super);
        /**
         * 请使用 `egret3d.Frustum.create()` 创建实例。
         * @see egret3d.Frustum.create()
         */
        function Frustum() {
            var _this = _super.call(this) || this;
            /**
             * 构成该锥体的平面。
             */
            _this.planes = [
                egret3d.Plane.create(),
                egret3d.Plane.create(),
                egret3d.Plane.create(),
                egret3d.Plane.create(),
                egret3d.Plane.create(),
                egret3d.Plane.create(),
            ];
            return _this;
        }
        /**
         * 创建一个几何截头锥体。
         */
        Frustum.create = function () {
            if (this._instances.length > 0) {
                var instance = this._instances.pop();
                instance._released = false;
                return instance;
            }
            return new Frustum();
        };
        Frustum.prototype.serialize = function () {
            var index = 0;
            var array = [];
            for (var _i = 0, _a = this.planes; _i < _a.length; _i++) {
                var plane = _a[_i];
                plane.toArray(array, index++);
            }
            return array;
        };
        Frustum.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Frustum.prototype.clone = function () {
            return Frustum.create().set(this.planes);
        };
        Frustum.prototype.copy = function (value) {
            return this.set(value.planes);
        };
        Frustum.prototype.set = function (planes) {
            var index = 0;
            for (var _i = 0, planes_2 = planes; _i < planes_2.length; _i++) {
                var plane = planes_2[_i];
                this.planes[index++].copy(plane);
            }
            return this;
        };
        Frustum.prototype.fromArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            for (var _i = 0, _a = this.planes; _i < _a.length; _i++) {
                var plane = _a[_i];
                plane.fromArray(array, offset);
                offset += 4;
            }
            return this;
        };
        /**
         * 通过一个矩阵设置该锥体。
         * @param matrix 一个矩阵。
         */
        Frustum.prototype.fromMatrix = function (matrix) {
            var planes = this.planes;
            var me = matrix.rawData;
            var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
            var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
            var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
            var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
            var helpVector3 = _helpVector3;
            planes[0].set(helpVector3.set(me3 - me0, me7 - me4, me11 - me8), me15 - me12).normalize();
            planes[1].set(helpVector3.set(me3 + me0, me7 + me4, me11 + me8), me15 + me12).normalize();
            planes[2].set(helpVector3.set(me3 + me1, me7 + me5, me11 + me9), me15 + me13).normalize();
            planes[3].set(helpVector3.set(me3 - me1, me7 - me5, me11 - me9), me15 - me13).normalize();
            planes[4].set(helpVector3.set(me3 - me2, me7 - me6, me11 - me10), me15 - me14).normalize();
            planes[5].set(helpVector3.set(me3 + me2, me7 + me6, me11 + me10), me15 + me14).normalize();
            return this;
        };
        /**
         * 该锥体是否包含指定点。
         * @param point 一个点。
         */
        Frustum.prototype.containsPoint = function (point) {
            for (var _i = 0, _a = this.planes; _i < _a.length; _i++) {
                var plane = _a[_i];
                if (plane.getDistance(point) < 0.0) {
                    return false;
                }
            }
            return true;
        };
        Frustum.prototype.intersectsSphere = function (sphere) {
            var center = sphere.center;
            var negRadius = -sphere.radius;
            for (var _i = 0, _a = this.planes; _i < _a.length; _i++) {
                var plane = _a[_i];
                var distance = plane.getDistance(center);
                if (distance < negRadius) {
                    return false;
                }
            }
            return true;
        };
        Frustum._instances = [];
        return Frustum;
    }(paper.BaseRelease));
    egret3d.Frustum = Frustum;
    __reflect(Frustum.prototype, "egret3d.Frustum", ["paper.ICCS", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 几何平面。
     */
    var Plane = (function (_super) {
        __extends(Plane, _super);
        /**
         * 请使用 `egret3d.Plane.create()` 创建实例。
         * @see egret3d.Plane.create()
         */
        function Plane() {
            var _this = _super.call(this) || this;
            /**
             * 二维平面到原点的距离。
             */
            _this.constant = 0.0;
            /**
             * 平面的法线。
             */
            _this.normal = egret3d.Vector3.create();
            return _this;
        }
        /**
         * 创建一个几何平面。
         * @param normal 法线。
         * @param constant 二维平面离原点的距离。
         */
        Plane.create = function (normal, constant) {
            if (normal === void 0) { normal = egret3d.Vector3.ZERO; }
            if (constant === void 0) { constant = 0.0; }
            if (this._instances.length > 0) {
                var instance = this._instances.pop().set(normal, constant);
                instance._released = false;
                return instance;
            }
            return new Plane().set(normal, constant);
        };
        Plane.prototype.serialize = function () {
            return this.toArray();
        };
        Plane.prototype.deserialize = function (value) {
            this.normal.fromArray(value);
            this.constant = value[3];
            return this;
        };
        Plane.prototype.clone = function () {
            return Plane.create(this.normal, this.constant);
        };
        Plane.prototype.copy = function (value) {
            return this.set(value.normal, value.constant);
        };
        Plane.prototype.set = function (normal, constant) {
            if (constant === void 0) { constant = 0.0; }
            this.constant = constant;
            this.normal.copy(normal);
            return this;
        };
        Plane.prototype.fromArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            this.normal.fromArray(array, offset);
            this.constant = array[offset + 3];
            return this;
        };
        Plane.prototype.fromPoint = function (point, normal) {
            if (normal === void 0) { normal = egret3d.Vector3.UP; }
            this.constant = -normal.dot(point);
            this.normal.copy(normal);
            return this;
        };
        Plane.prototype.fromPoints = function (valueA, valueB, valueC) {
            var normal = egret3d.helpVector3A.subtract(valueC, valueB).cross(egret3d.helpVector3B.subtract(valueA, valueB)).normalize();
            this.fromPoint(valueA, normal);
            return this;
        };
        Plane.prototype.normalize = function (input) {
            if (!input) {
                input = this;
            }
            var inverseNormalLength = 1.0 / input.normal.length;
            this.constant = input.constant * inverseNormalLength;
            this.normal.multiplyScalar(inverseNormalLength, input.normal);
            return this;
        };
        Plane.prototype.negate = function (input) {
            if (!input) {
                input = this;
            }
            this.constant = -input.constant;
            this.normal.negate(input.normal);
            return this;
        };
        Plane.prototype.applyMatrix = function (matrix, normalMatrix) {
            if (!normalMatrix) {
                normalMatrix = egret3d.helpMatrix3A.getNormalMatrix(matrix);
            }
            var referencePoint = this.getCoplanarPoint(egret3d.helpVector3A).applyMatrix(matrix);
            var normal = this.normal.applyMatrix3(normalMatrix).normalize();
            this.constant = -referencePoint.dot(normal);
            return this;
        };
        Plane.prototype.getDistance = function (point) {
            return this.normal.dot(point) + this.constant;
        };
        Plane.prototype.getProjectionPoint = function (point, output) {
            if (!output) {
                output = egret3d.Vector3.create();
            }
            return output.multiplyScalar(-this.getDistance(point), this.normal).add(point);
        };
        Plane.prototype.getCoplanarPoint = function (output) {
            if (!output) {
                output = egret3d.Vector3.create();
            }
            return output.copy(this.normal).multiplyScalar(-this.constant);
        };
        Plane.prototype.raycast = function (ray, raycastInfo) {
            if (raycastInfo === void 0) { raycastInfo = null; }
            var t = ray.getDistanceToPlane(this);
            if (t > 0.0) {
                if (raycastInfo) {
                    var normal = raycastInfo.normal;
                    raycastInfo.distance = t;
                    ray.getPointAt(t, raycastInfo.position);
                    if (normal) {
                        // TODO
                        normal.copy(this.normal);
                    }
                }
                return true;
            }
            return false;
        };
        Plane.prototype.toArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            if (!array) {
                array = [];
            }
            this.normal.toArray(array, offset);
            array[offset + 3] = this.constant;
            return array;
        };
        Plane.UP = new Plane().set(egret3d.Vector3.UP, 0.0);
        Plane.DOWN = new Plane().set(egret3d.Vector3.DOWN, 0.0);
        Plane.LEFT = new Plane().set(egret3d.Vector3.BACK, 0.0);
        Plane.RIGHT = new Plane().set(egret3d.Vector3.BACK, 0.0);
        Plane.FORWARD = new Plane().set(egret3d.Vector3.FORWARD, 0.0);
        Plane.BACK = new Plane().set(egret3d.Vector3.BACK, 0.0);
        Plane._instances = [];
        return Plane;
    }(paper.BaseRelease));
    egret3d.Plane = Plane;
    __reflect(Plane.prototype, "egret3d.Plane", ["paper.ICCS", "paper.ISerializable", "egret3d.IRaycast"]);
    /**
     * @internal
     */
    var helpPlane = Plane.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var GroupComponent = (function (_super) {
        __extends(GroupComponent, _super);
        function GroupComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.componentIndex = -1;
            _this.components = [];
            return _this;
        }
        GroupComponent.prototype.initialize = function (componentIndex) {
            _super.prototype.initialize.call(this);
            this.componentIndex = componentIndex;
        };
        GroupComponent.prototype.uninitialize = function () {
            this.componentIndex = -1;
            this.components.length = 0;
            this.entity = null;
            this._lifeStates = 0 /* None */;
        };
        GroupComponent.prototype.addComponent = function (component) {
            this.components.push(component);
        };
        GroupComponent.prototype.removeComponent = function (component) {
            var index = this.components.indexOf(component);
            if (index >= 0) {
                this.components.splice(index, 1);
                return true;
            }
            return false;
        };
        return GroupComponent;
    }(paper.Component));
    paper.GroupComponent = GroupComponent;
    __reflect(GroupComponent.prototype, "paper.GroupComponent");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * 动画资源。
     */
    var AnimationAsset = (function (_super) {
        __extends(AnimationAsset, _super);
        function AnimationAsset() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @private
         */
        AnimationAsset.create = function (name, config, buffers) {
            var animationAsset = new AnimationAsset();
            animationAsset.initialize(name, config);
            for (var _i = 0, buffers_2 = buffers; _i < buffers_2.length; _i++) {
                var b = buffers_2[_i];
                animationAsset.buffers.push(b);
            }
            return animationAsset;
        };
        /**
         * @internal
         */
        AnimationAsset.prototype.initialize = function (name, config) {
            _super.prototype.initialize.call(this, name, config, null);
            this.updateAccessorTypeCount();
        };
        /*
         * 获取动画剪辑。
         */
        AnimationAsset.prototype.getAnimationClip = function (name) {
            if (!this.config.animations ||
                this.config.animations.length === 0) {
                return null;
            }
            var animation = this.config.animations[0];
            if (animation.extensions.paper.clips.length === 0) {
                return null;
            }
            if (!name) {
                return animation.extensions.paper.clips[0];
            }
            for (var _i = 0, _a = this.config.animations; _i < _a.length; _i++) {
                var animation_1 = _a[_i];
                for (var _b = 0, _c = animation_1.extensions.paper.clips; _b < _c.length; _b++) {
                    var animationClip = _c[_b];
                    if (animationClip.name === name) {
                        return animationClip;
                    }
                }
            }
            return null;
        };
        return AnimationAsset;
    }(egret3d.GLTFAsset));
    egret3d.AnimationAsset = AnimationAsset;
    __reflect(AnimationAsset.prototype, "egret3d.AnimationAsset");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     */
    var AnimationController = (function (_super) {
        __extends(AnimationController, _super);
        function AnimationController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AnimationController.create = function (name, config) {
            var animationController;
            if (!config) {
                config = this.createConfig();
                config.extensions = {
                    paper: {
                        animationControllers: [{
                                layers: [],
                                parameters: []
                            }]
                    },
                };
            }
            animationController = new AnimationController();
            animationController.initialize(name, config, null);
            return animationController;
        };
        /**
         * 添加一个新的动画层。
         */
        AnimationController.prototype.addLayer = function (name) {
            var layers = this.layers;
            var layer = {
                additive: false,
                weight: 1.0,
                name: name,
                machine: {
                    name: "Default" /* Default */,
                    nodes: [],
                },
            };
            layers.push(layer);
            return layer;
        };
        AnimationController.prototype.createAnimationTree = function (machineOrTreen, name) {
            var animationTree = {
                blendType: 0 /* E1D */,
                timeScale: 1.0,
                name: name,
                parameters: [],
                nodes: []
            };
            var nodes = machineOrTreen.nodes;
            if (nodes.indexOf(animationTree) < 0) {
                nodes.push(animationTree);
            }
            return animationTree;
        };
        AnimationController.prototype.createAnimationNode = function (machineOrTreen, asset, name) {
            var animationNode = {
                asset: asset,
                name: name,
                timeScale: 1.0,
            };
            var nodes = machineOrTreen.nodes;
            if (nodes.indexOf(animationNode) < 0) {
                nodes.push(animationNode);
            }
            return animationNode;
        };
        /**
         * 获取或添加一个动画层。
         * - 层索引强制连续。
         */
        AnimationController.prototype.getOrAddLayer = function (layerIndex) {
            var layers = this.layers;
            if (layerIndex >= layers.length) {
                layerIndex = layers.length;
                this.addLayer("NoName" /* NoName */);
            }
            return layers[layerIndex];
        };
        Object.defineProperty(AnimationController.prototype, "layers", {
            get: function () {
                return this.config.extensions.paper.animationControllers[0].layers;
            },
            enumerable: true,
            configurable: true
        });
        return AnimationController;
    }(egret3d.GLTFAsset));
    egret3d.AnimationController = AnimationController;
    __reflect(AnimationController.prototype, "egret3d.AnimationController");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     */
    var AnimationMask = (function (_super) {
        __extends(AnimationMask, _super);
        function AnimationMask() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @internal
             */
            _this._dirty = false;
            _this._jointNamesDirty = false;
            _this._jointNames = [];
            return _this;
        }
        AnimationMask.create = function (name, config) {
            var animationMask;
            if (!config) {
                config = this.createConfig();
                config.nodes = [];
                config.extensions = {
                    paper: {
                        animationMasks: [{
                                retargeting: [],
                                joints: []
                            }]
                    },
                };
            }
            animationMask = new AnimationMask();
            animationMask.initialize(name, config, null);
            return animationMask;
        };
        AnimationMask.prototype._addJoint = function (nodes, joints, jointIndex, recursive) {
            if (joints.indexOf(jointIndex) < 0) {
                joints.push(jointIndex);
                this._dirty = true;
                this._jointNamesDirty = true;
            }
            if (recursive) {
                var node = nodes[jointIndex];
                var children = node.children;
                if (!children) {
                    return;
                }
                for (var _i = 0, children_6 = children; _i < children_6.length; _i++) {
                    var index = children_6[_i];
                    this._addJoint(nodes, joints, index, recursive);
                }
            }
        };
        AnimationMask.prototype.createJoints = function (mesh) {
            var nodes = this.config.nodes;
            nodes.length = 0;
            for (var _i = 0, _a = mesh.config.nodes; _i < _a.length; _i++) {
                var meshNode = _a[_i];
                var node = {
                    name: meshNode.name
                };
                if (meshNode.children) {
                    node.children = meshNode.children.concat();
                }
                nodes.push(node);
            }
            return this;
        };
        AnimationMask.prototype.addJoint = function (name, recursive) {
            if (recursive === void 0) { recursive = true; }
            var index = 0;
            var nodes = this.config.nodes;
            var joints = this.config.extensions.paper.animationMasks[0].joints;
            for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                var node = nodes_1[_i];
                if (node.name === name) {
                    this._addJoint(nodes, joints, index, recursive);
                    return this;
                }
                index++;
            }
            console.warn("Invalid joint mask name.", name);
            return this;
        };
        AnimationMask.prototype.removeJoint = function (name, recursive) {
            if (recursive === void 0) { recursive = true; }
            var index = 0;
            var nodes = this.config.nodes;
            var joints = this.config.extensions.paper.animationMasks[0].joints;
            for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {
                var node = nodes_2[_i];
                if (node.name === name) {
                    if (joints.indexOf(index) >= 0) {
                        joints.splice(index, 1);
                    }
                    break;
                }
                index++;
            }
            // recursive // TODO
            return this;
        };
        AnimationMask.prototype.removeJoints = function () {
            var joints = this.config.extensions.paper.animationMasks[0].joints;
            joints.length = 0;
            this._dirty = true;
            this._jointNamesDirty = true;
            return this;
        };
        Object.defineProperty(AnimationMask.prototype, "jointNames", {
            get: function () {
                var jointNames = this._jointNames;
                if (this._jointNamesDirty) {
                    var nodes = this.config.nodes;
                    var joints = this.config.extensions.paper.animationMasks[0].joints;
                    jointNames.length = 0;
                    for (var _i = 0, joints_1 = joints; _i < joints_1.length; _i++) {
                        var index = joints_1[_i];
                        var node = nodes[index];
                        jointNames.push(node.name);
                    }
                    this._jointNamesDirty = false;
                }
                return jointNames;
            },
            enumerable: true,
            configurable: true
        });
        return AnimationMask;
    }(egret3d.GLTFAsset));
    egret3d.AnimationMask = AnimationMask;
    __reflect(AnimationMask.prototype, "egret3d.AnimationMask");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 提供默认的几何网格资源，以及创建几何网格或几何网格实体的方式。
     */
    var MeshBuilder = (function () {
        function MeshBuilder() {
        }
        /**
         * 创建圆形网格。
         */
        MeshBuilder.createCircle = function (radius, arc, axis) {
            if (radius === void 0) { radius = 0.5; }
            if (arc === void 0) { arc = 1.0; }
            if (axis === void 0) { axis = 3; }
            var PI = 3.141592653589793 /* PI */;
            // buffers
            var vertices = [];
            //
            for (var i = 0; i <= 64 * arc; ++i) {
                switch (axis) {
                    case 1:
                        vertices.push(0.0, Math.cos(i / 32 * PI) * radius, -Math.sin(i / 32 * PI) * radius);
                        break;
                    case 2:
                        vertices.push(Math.cos(i / 32 * PI) * radius, 0.0, -Math.sin(i / 32 * PI) * radius);
                        break;
                    case 3:
                        vertices.push(Math.cos(i / 32 * PI) * radius, Math.sin(i / 32 * PI) * radius, -0.0);
                        break;
                }
            }
            //
            var mesh = egret3d.Mesh.create(vertices.length / 3, 0, ["POSITION" /* POSITION */]);
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.glTFMesh.primitives[0].mode = 3 /* LineStrip */;
            return mesh;
        };
        /**
         * 创建平面网格。
         * @param width 宽度。
         * @param height 高度。
         * @param centerOffsetX 中心点偏移 X。
         * @param centerOffsetY 中心点偏移 Y。
         * @param widthSegments 宽度分段。
         * @param heightSegments 高度分段。
         */
        MeshBuilder.createPlane = function (width, height, centerOffsetX, centerOffsetY, widthSegments, heightSegments) {
            if (width === void 0) { width = 1.0; }
            if (height === void 0) { height = 1.0; }
            if (centerOffsetX === void 0) { centerOffsetX = 0.0; }
            if (centerOffsetY === void 0) { centerOffsetY = 0.0; }
            if (widthSegments === void 0) { widthSegments = 1; }
            if (heightSegments === void 0) { heightSegments = 1; }
            var widthHalf = width / 2;
            var heightHalf = height / 2;
            var gridX1 = widthSegments + 1;
            var gridY1 = heightSegments + 1;
            var segmentWidth = width / widthSegments;
            var segmentHeight = height / heightSegments;
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // generate vertices, normals and uvs
            for (var iy = 0; iy < gridY1; iy++) {
                var y = iy * segmentHeight - heightHalf;
                for (var ix = 0; ix < gridX1; ix++) {
                    var x = ix * segmentWidth - widthHalf;
                    vertices.push(x + centerOffsetX, -y + centerOffsetY, 0.0);
                    normals.push(0.0, 0.0, -1.0);
                    uvs.push(ix / widthSegments, iy / heightSegments);
                }
            }
            // indices
            for (var iy = 0; iy < heightSegments; iy++) {
                for (var ix = 0; ix < widthSegments; ix++) {
                    var a = ix + gridX1 * iy;
                    var b = ix + gridX1 * (iy + 1);
                    var c = (ix + 1) + gridX1 * (iy + 1);
                    var d = (ix + 1) + gridX1 * iy;
                    // faces
                    // a - d
                    // | / |
                    // b - c
                    indices.push(a, b, d, d, b, c);
                }
            }
            //
            var mesh = egret3d.Mesh.create(vertices.length / 3, indices.length);
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.setAttributes("NORMAL" /* NORMAL */, normals);
            mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
            mesh.setIndices(indices);
            return mesh;
        };
        /**
         * 创建立方体网格。
         * @param width 宽度。
         * @param height 高度。
         * @param depth 深度。
         * @param centerOffsetX 中心点偏移 X。
         * @param centerOffsetY 中心点偏移 Y。
         * @param centerOffsetZ 中心点偏移 Z。
         * @param widthSegments 宽度分段。
         * @param heightSegments 高度分段。
         * @param depthSegments 深度分段。
         * @param differentFace 是否使用不同材质。
         */
        MeshBuilder.createCube = function (width, height, depth, centerOffsetX, centerOffsetY, centerOffsetZ, widthSegments, heightSegments, depthSegments, differentFace) {
            if (width === void 0) { width = 1.0; }
            if (height === void 0) { height = 1.0; }
            if (depth === void 0) { depth = 1.0; }
            if (centerOffsetX === void 0) { centerOffsetX = 0.0; }
            if (centerOffsetY === void 0) { centerOffsetY = 0.0; }
            if (centerOffsetZ === void 0) { centerOffsetZ = 0.0; }
            if (widthSegments === void 0) { widthSegments = 1; }
            if (heightSegments === void 0) { heightSegments = 1; }
            if (depthSegments === void 0) { depthSegments = 1; }
            if (differentFace === void 0) { differentFace = false; }
            // helper variables
            var meshVertexCount = 0;
            var vertex = egret3d.Vector3.create().release();
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            //
            function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY) {
                var vertexCount = 0;
                var segmentWidth = width / gridX;
                var segmentHeight = height / gridY;
                var widthHalf = width / 2;
                var heightHalf = height / 2;
                var depthHalf = depth / 2;
                var gridX1 = gridX + 1;
                var gridY1 = gridY + 1;
                // generate vertices, normals and uvs
                for (var iy = 0; iy < gridY1; iy++) {
                    var y = iy * segmentHeight - heightHalf;
                    for (var ix = 0; ix < gridX1; ix++) {
                        var x = ix * segmentWidth - widthHalf;
                        // set values to correct vector component
                        vertex[u] = x * udir;
                        vertex[v] = y * vdir;
                        vertex[w] = depthHalf;
                        vertices.push(vertex.x + centerOffsetX, vertex.y + centerOffsetY, vertex.z + centerOffsetZ);
                        // set values to correct vector component
                        vertex[u] = 0.0;
                        vertex[v] = 0.0;
                        vertex[w] = depth > 0.0 ? 1.0 : -1.0;
                        normals.push(vertex.x, vertex.y, vertex.z);
                        // uvs
                        uvs.push(ix / gridX, iy / gridY);
                        // counters
                        vertexCount += 1;
                    }
                }
                // indices
                // 1. you need three indices to draw a single face
                // 2. a single segment consists of two faces
                // 3. so we need to generate six (2*3) indices per segment
                for (var iy = 0; iy < gridY; iy++) {
                    for (var ix = 0; ix < gridX; ix++) {
                        var a = meshVertexCount + ix + gridX1 * iy;
                        var b = meshVertexCount + ix + gridX1 * (iy + 1);
                        var c = meshVertexCount + (ix + 1) + gridX1 * (iy + 1);
                        var d = meshVertexCount + (ix + 1) + gridX1 * iy;
                        // faces
                        // a - d
                        // | / |
                        // b - c
                        indices.push(a, b, d, b, c, d);
                    }
                }
                // update total number of vertices
                meshVertexCount += vertexCount;
            }
            // build each side of the box geometry
            buildPlane("z", "y", "x", -1, -1, depth, height, -width, depthSegments, heightSegments); // px
            buildPlane("z", "y", "x", 1, -1, depth, height, width, depthSegments, heightSegments); // nx
            buildPlane("x", "z", "y", 1, 1, width, depth, -height, widthSegments, depthSegments); // py
            buildPlane("x", "z", "y", 1, -1, width, depth, height, widthSegments, depthSegments); // ny
            buildPlane("x", "y", "z", 1, -1, width, height, -depth, widthSegments, heightSegments); // pz
            buildPlane("x", "y", "z", -1, -1, width, height, depth, widthSegments, heightSegments); // nz
            // build geometry
            if (differentFace) {
                var faceIndexCount = indices.length / 6;
                var mesh_1 = egret3d.Mesh.create(vertices.length / 3, 0);
                mesh_1.setAttributes("POSITION" /* POSITION */, vertices);
                mesh_1.setAttributes("NORMAL" /* NORMAL */, normals);
                mesh_1.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
                for (var i = 0; i < 6; ++i) {
                    mesh_1.addSubMesh(faceIndexCount, i);
                    mesh_1.setIndices(indices, i, faceIndexCount * i);
                }
                return mesh_1;
            }
            //
            var mesh = egret3d.Mesh.create(vertices.length / 3, indices.length);
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.setAttributes("NORMAL" /* NORMAL */, normals);
            mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
            mesh.setIndices(indices);
            return mesh;
        };
        /**
         * 创建圆柱体网格。
         * @param radiusTop 顶部半径。
         * @param radiusBottom 底部半径。
         * @param height 高度。
         * @param centerOffsetX 中心点偏移 X。
         * @param centerOffsetY 中心点偏移 Y。
         * @param centerOffsetZ 中心点偏移 Z。
         * @param radialSegments 径向分段。
         * @param heightSegments 高度分段。
         * @param openEnded 是否开口。
         * @param thetaStart 起始弧度。
         * @param thetaLength 覆盖弧度。
         * @param differentFace 是否使用不同材质。
         */
        MeshBuilder.createCylinder = function (radiusTop, radiusBottom, height, centerOffsetX, centerOffsetY, centerOffsetZ, radialSegments, heightSegments, openEnded, thetaStart, thetaLength, differentFace) {
            if (radiusTop === void 0) { radiusTop = 0.5; }
            if (radiusBottom === void 0) { radiusBottom = 0.5; }
            if (height === void 0) { height = 1.0; }
            if (centerOffsetX === void 0) { centerOffsetX = 0.0; }
            if (centerOffsetY === void 0) { centerOffsetY = 0.0; }
            if (centerOffsetZ === void 0) { centerOffsetZ = 0.0; }
            if (radialSegments === void 0) { radialSegments = 10; }
            if (heightSegments === void 0) { heightSegments = 1; }
            if (openEnded === void 0) { openEnded = false; }
            if (thetaStart === void 0) { thetaStart = 0.0; }
            if (thetaLength === void 0) { thetaLength = 6.283185307179586 /* PI_DOUBLE */; }
            if (differentFace === void 0) { differentFace = false; }
            // helper variables
            var index = 0;
            var groupStart = 0;
            var halfHeight = height / 2;
            var vertex = egret3d.Vector3.create().release();
            var indexArray = [];
            var subIndices = [];
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            //
            function generateTorso() {
                var groupCount = 0;
                // this will be used to calculate the normal
                var slope = (radiusBottom - radiusTop) / height;
                // generate vertices, normals and uvs
                for (var iY = 0; iY <= heightSegments; iY++) {
                    var indexRow = [];
                    var v = iY / heightSegments;
                    // calculate the radius of the current row
                    var radius = v * (radiusBottom - radiusTop) + radiusTop;
                    for (var iX = 0; iX <= radialSegments; iX++) {
                        var u = iX / radialSegments;
                        var theta = u * thetaLength + thetaStart;
                        var sinTheta = Math.sin(theta);
                        var cosTheta = Math.cos(theta);
                        // vertex
                        vertex.x = radius * sinTheta;
                        vertex.y = -v * height + halfHeight;
                        // vertex.z = radius * cosTheta; // Right-hand coordinates system.
                        vertex.z = -radius * cosTheta; // Left-hand coordinates system.
                        vertices.push(vertex.x + centerOffsetX, vertex.y + centerOffsetY, vertex.z + centerOffsetZ);
                        // normal
                        vertex.set(sinTheta, slope, cosTheta).normalize();
                        // normals.push(vertex.x, vertex.y, vertex.z); // Right-hand coordinates system.
                        normals.push(vertex.x, vertex.y, -vertex.z); // Left-hand coordinates system.
                        // uv
                        uvs.push(u, v);
                        // save index of vertex in respective row
                        indexRow.push(index++);
                    }
                    // now save vertices of the row in our index array
                    indexArray.push(indexRow);
                }
                // generate indices
                for (var iX = 0; iX < radialSegments; iX++) {
                    for (var iY = 0; iY < heightSegments; iY++) {
                        // we use the index array to access the correct indices
                        var a = indexArray[iY][iX];
                        var b = indexArray[iY + 1][iX];
                        var c = indexArray[iY + 1][iX + 1];
                        var d = indexArray[iY][iX + 1];
                        // faces
                        indices.push(a, b, d, b, c, d);
                        // update group counter
                        groupCount += 6;
                    }
                }
                // add a group to the geometry. this will ensure multi material support
                subIndices.push(groupStart, groupCount, 0);
                // calculate new start value for groups
                groupStart += groupCount;
            }
            //
            function generateCap(top) {
                var centerIndexStart = 0, centerIndexEnd = 0;
                var groupCount = 0;
                var radius = top ? radiusTop : radiusBottom;
                var sign = top ? 1 : -1;
                // save the index of the first center vertex
                centerIndexStart = index;
                // first we generate the center vertex data of the cap.
                // because the geometry needs one set of uvs per face,
                // we must generate a center vertex per face/segment
                for (var iX = 1; iX <= radialSegments; iX++) {
                    // vertex
                    vertices.push(0.0, halfHeight * sign, 0.0);
                    // normal
                    normals.push(0.0, sign, 0.0);
                    // uv
                    uvs.push(0.5, 0.5);
                    // increase index
                    index++;
                }
                // save the index of the last center vertex
                centerIndexEnd = index;
                // now we generate the surrounding vertices, normals and uvs
                for (var iX = 0; iX <= radialSegments; iX++) {
                    var u = iX / radialSegments;
                    var theta = u * thetaLength + thetaStart;
                    var cosTheta = Math.cos(theta);
                    var sinTheta = Math.sin(theta);
                    // vertex
                    vertex.x = radius * sinTheta;
                    vertex.y = halfHeight * sign;
                    // vertex.z = radius * cosTheta; // Right-hand coordinates system.
                    vertex.z = -radius * cosTheta; // Left-hand coordinates system.
                    vertices.push(vertex.x + centerOffsetX, vertex.y + centerOffsetY, vertex.z + centerOffsetZ);
                    // normal
                    normals.push(0.0, sign, 0.0);
                    // uv
                    uvs.push((sinTheta * 0.5 * sign) + 0.5, (cosTheta * 0.5) + 0.5);
                    // increase index
                    index++;
                }
                // generate indices
                for (var iX = 0; iX < radialSegments; iX++) {
                    var c = centerIndexStart + iX;
                    var i = centerIndexEnd + iX;
                    if (top === true) {
                        // face top
                        indices.push(i, i + 1, c);
                    }
                    else {
                        // face bottom
                        indices.push(i + 1, i, c);
                    }
                    groupCount += 3;
                }
                // add a group to the geometry. this will ensure multi material support
                subIndices.push(groupStart, groupCount, top === true ? 1 : 2);
                // calculate new start value for groups
                groupStart += groupCount;
            }
            // generate geometry
            generateTorso();
            //
            if (!openEnded) {
                if (radiusTop > 0.0)
                    generateCap(true);
                if (radiusBottom > 0.0)
                    generateCap(false);
            }
            // build geometry
            if (differentFace) {
                var mesh_2 = egret3d.Mesh.create(vertices.length / 3, 0);
                mesh_2.setAttributes("POSITION" /* POSITION */, vertices);
                mesh_2.setAttributes("NORMAL" /* NORMAL */, normals);
                mesh_2.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
                for (var i = 0; i < subIndices.length; i += 3) {
                    mesh_2.addSubMesh(subIndices[1], subIndices[2]);
                    mesh_2.setIndices(indices, i, subIndices[0]);
                }
                return mesh_2;
            }
            var mesh = egret3d.Mesh.create(vertices.length / 3, indices.length);
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.setAttributes("NORMAL" /* NORMAL */, normals);
            mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
            mesh.setIndices(indices);
            return mesh;
        };
        /**
         * 创建圆环网格。
         */
        MeshBuilder.createTorus = function (radius, tube, radialSegments, tubularSegments, arc, axis) {
            if (radius === void 0) { radius = 0.5; }
            if (tube === void 0) { tube = 0.1; }
            if (radialSegments === void 0) { radialSegments = 10; }
            if (tubularSegments === void 0) { tubularSegments = 10; }
            if (arc === void 0) { arc = 1.0; }
            if (axis === void 0) { axis = 3; }
            // helper variables
            var vertex = egret3d.Vector3.create().release();
            var normal = egret3d.Vector3.create().release();
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // generate vertices, normals and uvs
            for (var j = 0; j <= radialSegments; j++) {
                for (var i = 0; i <= tubularSegments; i++) {
                    var u = i / tubularSegments * 6.283185307179586 /* PI_DOUBLE */ * arc;
                    var v = j / radialSegments * 6.283185307179586 /* PI_DOUBLE */;
                    // vertex
                    switch (axis) {
                        case 1:
                            vertex.x = tube * Math.sin(v);
                            vertex.y = (radius + tube * Math.cos(v)) * Math.cos(u);
                            vertex.z = -(radius + tube * Math.cos(v)) * Math.sin(u);
                            break;
                        case 2:
                            vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                            vertex.y = -tube * Math.sin(v);
                            vertex.z = -(radius + tube * Math.cos(v)) * Math.sin(u);
                            break;
                        case 3:
                            vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                            vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
                            vertex.z = -tube * Math.sin(v);
                    }
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    // normal
                    normal.x = radius * Math.cos(u);
                    normal.y = radius * Math.sin(u);
                    normal.z = 0.0;
                    normal.subtract(vertex, normal).normalize();
                    normals.push(normal.x, normal.y, -normal.z);
                    // uv
                    uvs.push(i / tubularSegments);
                    uvs.push(j / radialSegments);
                }
            }
            // generate indices
            for (var j = 1; j <= radialSegments; j++) {
                for (var i = 1; i <= tubularSegments; i++) {
                    // indices
                    var a = (tubularSegments + 1) * j + i - 1;
                    var b = (tubularSegments + 1) * (j - 1) + i - 1;
                    var c = (tubularSegments + 1) * (j - 1) + i;
                    var d = (tubularSegments + 1) * j + i;
                    // faces
                    indices.push(a, b, d, b, c, d);
                }
            }
            // build geometry
            var mesh = egret3d.Mesh.create(vertices.length / 3, indices.length, ["POSITION" /* POSITION */, "NORMAL" /* NORMAL */, "TEXCOORD_0" /* TEXCOORD_0 */]);
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.setAttributes("NORMAL" /* NORMAL */, normals);
            mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
            mesh.setIndices(indices);
            return mesh;
        };
        /**
        * 创建球体网格。
        * @param radius 半径。
        * @param centerOffsetX 中心点偏移 X。
        * @param centerOffsetY 中心点偏移 Y。
        * @param centerOffsetZ 中心点偏移 Z。
        * @param widthSegments 宽度分段。
        * @param heightSegments 高度分段。
        * @param phiStart 水平起始弧度。
        * @param phiLength 水平覆盖弧度。
        * @param thetaStart 垂直起始弧度。
        * @param thetaLength 垂直覆盖弧度。
        */
        MeshBuilder.createSphere = function (radius, centerOffsetX, centerOffsetY, centerOffsetZ, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
            if (radius === void 0) { radius = 0.5; }
            if (centerOffsetX === void 0) { centerOffsetX = 0.0; }
            if (centerOffsetY === void 0) { centerOffsetY = 0.0; }
            if (centerOffsetZ === void 0) { centerOffsetZ = 0.0; }
            if (widthSegments === void 0) { widthSegments = 10; }
            if (heightSegments === void 0) { heightSegments = 10; }
            if (phiStart === void 0) { phiStart = 0.0; }
            if (phiLength === void 0) { phiLength = 6.283185307179586 /* PI_DOUBLE */; }
            if (thetaStart === void 0) { thetaStart = 0.0; }
            if (thetaLength === void 0) { thetaLength = 3.141592653589793 /* PI */; }
            widthSegments = Math.max(3, widthSegments);
            heightSegments = Math.max(2, heightSegments);
            // generate vertices, normals and uvs
            var index = 0;
            var thetaEnd = thetaStart + thetaLength;
            var vertex = egret3d.Vector3.create().release();
            var grid = [];
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            //
            for (var iY = 0; iY <= heightSegments; iY++) {
                var v = iY / heightSegments;
                var verticesRow = [];
                for (var iX = 0; iX <= widthSegments; iX++) {
                    var u = iX / widthSegments;
                    var t = radius * Math.sin(thetaStart + v * thetaLength);
                    // vertex
                    vertex.x = -t * Math.cos(phiStart + u * phiLength);
                    vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
                    vertex.z = t * Math.sin(phiStart + u * phiLength);
                    vertices.push(vertex.x + centerOffsetX, vertex.y + centerOffsetY, -vertex.z + centerOffsetZ);
                    // normal
                    vertex.normalize();
                    normals.push(vertex.x, vertex.y, -vertex.z);
                    // uv
                    uvs.push(u, v);
                    verticesRow.push(index++);
                }
                grid.push(verticesRow);
            }
            // indices
            for (var iy = 0; iy < heightSegments; iy++) {
                for (var ix = 0; ix < widthSegments; ix++) {
                    var a = grid[iy][ix + 1];
                    var b = grid[iy][ix];
                    var c = grid[iy + 1][ix];
                    var d = grid[iy + 1][ix + 1];
                    if (iy !== 0 || thetaStart > 0)
                        indices.push(a, b, d);
                    if (iy !== heightSegments - 1 || thetaEnd < 3.141592653589793 /* PI */)
                        indices.push(b, c, d);
                }
            }
            // build geometry
            var mesh = egret3d.Mesh.create(vertices.length / 3, indices.length, ["POSITION" /* POSITION */, "NORMAL" /* NORMAL */, "TEXCOORD_0" /* TEXCOORD_0 */]);
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.setAttributes("NORMAL" /* NORMAL */, normals);
            mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
            mesh.setIndices(indices);
            return mesh;
        };
        /**
         *
         * @param radius
         * @param tube
         * @param tubularSegments
         * @param radialSegments
         * @param p
         * @param q
         */
        MeshBuilder.createTorusKnot = function (radius, tube, tubularSegments, radialSegments, p, q) {
            if (radius === void 0) { radius = 0.5; }
            if (tube === void 0) { tube = 0.2; }
            if (tubularSegments === void 0) { tubularSegments = 64; }
            if (radialSegments === void 0) { radialSegments = 8; }
            if (p === void 0) { p = 2.0; }
            if (q === void 0) { q = 3.0; }
            // helper variables
            var vertex = egret3d.Vector3.create().release();
            var normal = egret3d.Vector3.create().release();
            var P1 = egret3d.Vector3.create().release();
            var P2 = egret3d.Vector3.create().release();
            var B = egret3d.Vector3.create().release();
            var T = egret3d.Vector3.create().release();
            var N = egret3d.Vector3.create().release();
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // this function calculates the current position on the torus curve
            function calculatePositionOnCurve(u, p, q, radius, position) {
                var cu = Math.cos(u);
                var su = Math.sin(u);
                var quOverP = q / p * u;
                var cs = Math.cos(quOverP);
                position.x = radius * (2 + cs) * 0.5 * cu;
                position.y = radius * (2 + cs) * su * 0.5;
                position.z = radius * Math.sin(quOverP) * 0.5;
            }
            // generate vertices, normals and uvs
            for (var i = 0; i <= tubularSegments; ++i) {
                // the radian "u" is used to calculate the position on the torus curve of the current tubular segement
                var u = i / tubularSegments * p * 6.283185307179586 /* PI_DOUBLE */;
                // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
                // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
                calculatePositionOnCurve(u, p, q, radius, P1);
                calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
                // calculate orthonormal basis
                T.subtract(P2, P1);
                N.add(P2, P1);
                B.cross(T, N);
                N.cross(B, T);
                // normalize B, N. T can be ignored, we don't use it
                B.normalize();
                N.normalize();
                //
                for (var j = 0; j <= radialSegments; ++j) {
                    // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
                    // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
                    var v = j / radialSegments * 6.283185307179586 /* PI_DOUBLE */;
                    var cx = -tube * Math.cos(v);
                    var cy = tube * Math.sin(v);
                    // now calculate the final vertex position.
                    // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
                    vertex.x = P1.x + (cx * N.x + cy * B.x);
                    vertex.y = P1.y + (cx * N.y + cy * B.y);
                    vertex.z = P1.z + (cx * N.z + cy * B.z);
                    vertices.push(vertex.x, vertex.y, -vertex.z); //
                    // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
                    normal.subtract(vertex, P1).normalize();
                    normals.push(normal.x, normal.y, -normal.z); //
                    // uv
                    uvs.push(i / tubularSegments, j / radialSegments);
                }
            }
            // generate indices
            for (var j = 1; j <= tubularSegments; j++) {
                for (var i = 1; i <= radialSegments; i++) {
                    // indices
                    var a = (radialSegments + 1) * (j - 1) + (i - 1);
                    var b = (radialSegments + 1) * j + (i - 1);
                    var c = (radialSegments + 1) * j + i;
                    var d = (radialSegments + 1) * (j - 1) + i;
                    // faces
                    indices.push(a, b, d, b, c, d);
                }
            }
            // build geometry
            var mesh = egret3d.Mesh.create(vertices.length / 3, indices.length, ["POSITION" /* POSITION */, "NORMAL" /* NORMAL */, "TEXCOORD_0" /* TEXCOORD_0 */]);
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.setAttributes("NORMAL" /* NORMAL */, normals);
            mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
            mesh.setIndices(indices);
            return mesh;
        };
        /**
         * 创建胶囊体网格。
         * @param radius 半径。
         * @param height 圆柱体高度。
         * @param centerOffsetX 中心点偏移 X。
         * @param centerOffsetY 中心点偏移 Y。
         * @param centerOffsetZ 中心点偏移 Z。
         * @param widthSegments 球体宽度分段。
         * @param heightSegments 球体高度分段。
         * @param middleSegments 圆柱体高度分段。
         * @param phiStart 水平起始弧度。
         * @param phiLength 水平覆盖弧度。
         * @param thetaStart 垂直起始弧度。
         * @param thetaLength 垂直覆盖弧度。
         */
        MeshBuilder.createCapsule = function (radius, height, centerOffsetX, centerOffsetY, centerOffsetZ, widthSegments, heightSegments, middleSegments, phiStart, phiLength, thetaStart, thetaLength) {
            if (radius === void 0) { radius = 0.25; }
            if (height === void 0) { height = 0.5; }
            if (centerOffsetX === void 0) { centerOffsetX = 0.0; }
            if (centerOffsetY === void 0) { centerOffsetY = 0.0; }
            if (centerOffsetZ === void 0) { centerOffsetZ = 0.0; }
            if (widthSegments === void 0) { widthSegments = 10; }
            if (heightSegments === void 0) { heightSegments = 10; }
            if (middleSegments === void 0) { middleSegments = 1; }
            if (phiStart === void 0) { phiStart = 0.0; }
            if (phiLength === void 0) { phiLength = 6.283185307179586 /* PI_DOUBLE */; }
            if (thetaStart === void 0) { thetaStart = 0.0; }
            if (thetaLength === void 0) { thetaLength = 3.141592653589793 /* PI */; }
            if (heightSegments % 2) {
                heightSegments++;
            }
            widthSegments = Math.max(3, widthSegments);
            heightSegments = Math.max(2, heightSegments);
            // generate vertices, normals and uvs
            var index = 0;
            var allHeightSegments = heightSegments + (middleSegments ? 1 : 0); // TODO middleSegments
            var middleHeight = (heightSegments + 1) * 0.5;
            var thetaEnd = thetaStart + thetaLength;
            var vertex = egret3d.Vector3.create().release();
            var grid = [];
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            //
            for (var iY = 0; iY <= allHeightSegments; iY++) {
                var v = iY / allHeightSegments;
                var vS = iY < middleHeight ? (iY / heightSegments) : ((iY - 1) / heightSegments); // TODO middleSegments
                var verticesRow = [];
                grid.push(verticesRow);
                for (var iX = 0; iX <= widthSegments; iX++) {
                    var u = iX / widthSegments;
                    var t = radius * Math.sin(thetaStart + v * thetaLength);
                    vertex.x = -t * Math.cos(phiStart + u * phiLength);
                    vertex.z = t * Math.sin(phiStart + u * phiLength);
                    vertex.y = radius * Math.cos(thetaStart + vS * thetaLength);
                    if (iY < middleHeight) {
                        vertices.push(vertex.x + centerOffsetX, vertex.y + height * 0.5 + centerOffsetY, -vertex.z + centerOffsetZ);
                    }
                    else {
                        vertices.push(vertex.x + centerOffsetX, vertex.y - height * 0.5 + centerOffsetY, -vertex.z + centerOffsetZ);
                    }
                    vertex.normalize();
                    normals.push(vertex.x, vertex.y, -vertex.z);
                    uvs.push(u, v);
                    verticesRow.push(index++);
                }
            }
            // indices
            for (var iY = 0; iY < allHeightSegments; iY++) {
                for (var iX = 0; iX < widthSegments; iX++) {
                    var a = grid[iY][iX + 1];
                    var b = grid[iY][iX];
                    var c = grid[iY + 1][iX];
                    var d = grid[iY + 1][iX + 1];
                    if (iY !== 0 || thetaStart > 0.0)
                        indices.push(a, b, d);
                    if (iY !== allHeightSegments - 1 || thetaEnd < 3.141592653589793 /* PI */)
                        indices.push(b, c, d);
                }
            }
            // build geometry
            var mesh = egret3d.Mesh.create(vertices.length / 3, indices.length, ["POSITION" /* POSITION */, "NORMAL" /* NORMAL */, "TEXCOORD_0" /* TEXCOORD_0 */]);
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.setAttributes("NORMAL" /* NORMAL */, normals);
            mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
            mesh.setIndices(indices);
            return mesh;
        };
        MeshBuilder._createPolyhedron = function (vertices, indices, radius, detail) {
            var vertexBuffer = [];
            var uvBuffer = [];
            // // the subdivision creates the vertex buffer data
            // subdivide(detail);
            // // all vertices should lie on a conceptual sphere with a given radius
            // appplyRadius(radius);
            // // finally, create the uv data
            // generateUVs();
            // // build non-indexed geometry
            // this.addAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
            // this.addAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
            // this.addAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));
            // if (detail === 0) {
            //     this.computeVertexNormals(); // flat normals
            // } else {
            //     this.normalizeNormals(); // smooth normals
            // }
            // return 
            // // helper functions
            // function subdivide(detail) {
            //     var a = new Vector3();
            //     var b = new Vector3();
            //     var c = new Vector3();
            //     // iterate over all faces and apply a subdivison with the given detail value
            //     for (var i = 0; i < indices.length; i += 3) {
            //         // get the vertices of the face
            //         getVertexByIndex(indices[i + 0], a);
            //         getVertexByIndex(indices[i + 1], b);
            //         getVertexByIndex(indices[i + 2], c);
            //         // perform subdivision
            //         subdivideFace(a, b, c, detail);
            //     }
            // }
            // function subdivideFace(a, b, c, detail) {
            //     var cols = Math.pow(2, detail);
            //     // we use this multidimensional array as a data structure for creating the subdivision
            //     var v = [];
            //     var i, j;
            //     // construct all of the vertices for this subdivision
            //     for (i = 0; i <= cols; i++) {
            //         v[i] = [];
            //         var aj = a.clone().lerp(c, i / cols);
            //         var bj = b.clone().lerp(c, i / cols);
            //         var rows = cols - i;
            //         for (j = 0; j <= rows; j++) {
            //             if (j === 0 && i === cols) {
            //                 v[i][j] = aj;
            //             } else {
            //                 v[i][j] = aj.clone().lerp(bj, j / rows);
            //             }
            //         }
            //     }
            //     // construct all of the faces
            //     for (i = 0; i < cols; i++) {
            //         for (j = 0; j < 2 * (cols - i) - 1; j++) {
            //             var k = Math.floor(j / 2);
            //             if (j % 2 === 0) {
            //                 pushVertex(v[i][k + 1]);
            //                 pushVertex(v[i + 1][k]);
            //                 pushVertex(v[i][k]);
            //             } else {
            //                 pushVertex(v[i][k + 1]);
            //                 pushVertex(v[i + 1][k + 1]);
            //                 pushVertex(v[i + 1][k]);
            //             }
            //         }
            //     }
            // }
            // function appplyRadius(radius) {
            //     var vertex = new Vector3();
            //     // iterate over the entire buffer and apply the radius to each vertex
            //     for (var i = 0; i < vertexBuffer.length; i += 3) {
            //         vertex.x = vertexBuffer[i + 0];
            //         vertex.y = vertexBuffer[i + 1];
            //         vertex.z = vertexBuffer[i + 2];
            //         vertex.normalize().multiplyScalar(radius);
            //         vertexBuffer[i + 0] = vertex.x;
            //         vertexBuffer[i + 1] = vertex.y;
            //         vertexBuffer[i + 2] = vertex.z;
            //     }
            // }
            // function generateUVs() {
            //     var vertex = new Vector3();
            //     for (var i = 0; i < vertexBuffer.length; i += 3) {
            //         vertex.x = vertexBuffer[i + 0];
            //         vertex.y = vertexBuffer[i + 1];
            //         vertex.z = vertexBuffer[i + 2];
            //         var u = azimuth(vertex) / 2 / Math.PI + 0.5;
            //         var v = inclination(vertex) / Math.PI + 0.5;
            //         uvBuffer.push(u, 1 - v);
            //     }
            //     correctUVs();
            //     correctSeam();
            // }
            // function correctSeam() {
            //     // handle case when face straddles the seam, see #3269
            //     for (var i = 0; i < uvBuffer.length; i += 6) {
            //         // uv data of a single face
            //         var x0 = uvBuffer[i + 0];
            //         var x1 = uvBuffer[i + 2];
            //         var x2 = uvBuffer[i + 4];
            //         var max = Math.max(x0, x1, x2);
            //         var min = Math.min(x0, x1, x2);
            //         // 0.9 is somewhat arbitrary
            //         if (max > 0.9 && min < 0.1) {
            //             if (x0 < 0.2) uvBuffer[i + 0] += 1;
            //             if (x1 < 0.2) uvBuffer[i + 2] += 1;
            //             if (x2 < 0.2) uvBuffer[i + 4] += 1;
            //         }
            //     }
            // }
            // function pushVertex(vertex) {
            //     vertexBuffer.push(vertex.x, vertex.y, vertex.z);
            // }
            // function getVertexByIndex(index, vertex) {
            //     var stride = index * 3;
            //     vertex.x = vertices[stride + 0];
            //     vertex.y = vertices[stride + 1];
            //     vertex.z = vertices[stride + 2];
            // }
            // function correctUVs() {
            //     var a = new Vector3();
            //     var b = new Vector3();
            //     var c = new Vector3();
            //     var centroid = new Vector3();
            //     var uvA = new Vector2();
            //     var uvB = new Vector2();
            //     var uvC = new Vector2();
            //     for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
            //         a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
            //         b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
            //         c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
            //         uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
            //         uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
            //         uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
            //         centroid.copy(a).add(b).add(c).divideScalar(3);
            //         var azi = azimuth(centroid);
            //         correctUV(uvA, j + 0, a, azi);
            //         correctUV(uvB, j + 2, b, azi);
            //         correctUV(uvC, j + 4, c, azi);
            //     }
            // }
            // function correctUV(uv, stride, vector, azimuth) {
            //     if ((azimuth < 0) && (uv.x === 1)) {
            //         uvBuffer[stride] = uv.x - 1;
            //     }
            //     if ((vector.x === 0) && (vector.z === 0)) {
            //         uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
            //     }
            // }
            // // Angle around the Y axis, counter-clockwise when looking from above.
            // function azimuth(vector) {
            //     return Math.atan2(vector.z, - vector.x);
            // }
            // // Angle above the XZ plane.
            // function inclination(vector) {
            //     return Math.atan2(- vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));
            // }
        };
        return MeshBuilder;
    }());
    egret3d.MeshBuilder = MeshBuilder;
    __reflect(MeshBuilder.prototype, "egret3d.MeshBuilder");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ShaderLib;
    (function (ShaderLib) {
        ShaderLib.copy = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "copy_vert", "type": 35633, "uri": "varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}" }, { "name": "copy_frag", "type": 35632, "uri": "uniform float opacity;\nuniform sampler2D map;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texel = texture2D( map, vUv );\n\tgl_FragColor = opacity * texel;\n}" }], "techniques": [{ "name": "copy", "attributes": {}, "uniforms": { "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 } } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.cube = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "cube_vert", "type": 35633, "uri": "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n" }, { "name": "cube_frag", "type": 35632, "uri": "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n" }], "techniques": [{ "name": "cube", "attributes": {}, "uniforms": { "tCube": { "type": 35680 }, "tFlip": { "type": 5126, "value": 1 }, "opacity": { "type": 5126, "value": 1 } } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.depth = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "depth_vert", "type": 35633, "uri": "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n" }, { "name": "depth_frag", "type": 35632, "uri": "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n" }], "techniques": [{ "name": "depth", "attributes": {}, "uniforms": { "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126, "value": 1 }, "displacementBias": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.distanceRGBA = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "distanceRGBA_vert", "type": 35633, "uri": "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\t\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tgl_Position.x *= -1.0;\n\t\n\tvWorldPosition = worldPosition.xyz;\n}\n" }, { "name": "distanceRGBA_frag", "type": 35632, "uri": "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n" }], "techniques": [{ "name": "distanceRGBA", "attributes": {}, "uniforms": { "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126, "value": 1 }, "displacementBias": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.equirect = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "equirect_vert", "type": 35633, "uri": "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n" }, { "name": "equirect_frag", "type": 35632, "uri": "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.y = 1.0 - sampleUV.y;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n" }], "techniques": [{ "name": "equirect", "attributes": {}, "uniforms": { "tEquirect": { "type": 35678 } } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.fxaa1 = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "fxaa1_vert", "type": 35633, "uri": "varying vec2 vUv;\nvoid main(){\n    vUv=uv;\n    gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);\n}" }, { "name": "fxaa1_frag", "type": 35632, "uri": "precision highp float;\nuniform sampler2D map;\nuniform vec2 resolution;\nvarying vec2 vUv;\n#define FXAA_PC 1\n#define FXAA_GLSL_100 1\n#define FXAA_QUALITY_PRESET 12\n#define FXAA_GREEN_AS_LUMA 1\n#ifndef FXAA_PC_CONSOLE\n    #define FXAA_PC_CONSOLE 0\n#endif\n#ifndef FXAA_GLSL_120\n    #define FXAA_GLSL_120 0\n#endif\n#ifndef FXAA_GLSL_130\n    #define FXAA_GLSL_130 0\n#endif\n#ifndef FXAA_HLSL_3\n    #define FXAA_HLSL_3 0\n#endif\n#ifndef FXAA_HLSL_4\n    #define FXAA_HLSL_4 0\n#endif\n#ifndef FXAA_HLSL_5\n    #define FXAA_HLSL_5 0\n#endif\n#ifndef FXAA_GREEN_AS_LUMA\n    #define FXAA_GREEN_AS_LUMA 0\n#endif\n#ifndef FXAA_EARLY_EXIT\n    #define FXAA_EARLY_EXIT 1\n#endif\n#ifndef FXAA_DISCARD\n    #define FXAA_DISCARD 0\n#endif\n#ifndef FXAA_FAST_PIXEL_OFFSET\n    #ifdef GL_EXT_gpu_shader4\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifdef GL_NV_gpu_shader5\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifdef GL_ARB_gpu_shader5\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifndef FXAA_FAST_PIXEL_OFFSET\n        #define FXAA_FAST_PIXEL_OFFSET 0\n    #endif\n#endif\n#ifndef FXAA_GATHER4_ALPHA\n    #if (FXAA_HLSL_5 == 1)\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifdef GL_ARB_gpu_shader5\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifdef GL_NV_gpu_shader5\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifndef FXAA_GATHER4_ALPHA\n        #define FXAA_GATHER4_ALPHA 0\n    #endif\n#endif\n#ifndef FXAA_QUALITY_PRESET\n    #define FXAA_QUALITY_PRESET 12\n#endif\n#if (FXAA_QUALITY_PRESET == 10)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 3.0\n    #define FXAA_QUALITY_P2 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 11)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 3.0\n    #define FXAA_QUALITY_P3 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 12)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 4.0\n    #define FXAA_QUALITY_P4 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 13)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 4.0\n    #define FXAA_QUALITY_P5 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 14)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 4.0\n    #define FXAA_QUALITY_P6 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 15)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 20)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 2.0\n    #define FXAA_QUALITY_P2 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 21)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 22)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 23)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 24)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 3.0\n    #define FXAA_QUALITY_P6 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 25)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 26)\n    #define FXAA_QUALITY_PS 9\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 4.0\n    #define FXAA_QUALITY_P8 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 27)\n    #define FXAA_QUALITY_PS 10\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 4.0\n    #define FXAA_QUALITY_P9 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 28)\n    #define FXAA_QUALITY_PS 11\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 4.0\n    #define FXAA_QUALITY_P10 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 29)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 39)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.0\n    #define FXAA_QUALITY_P2 1.0\n    #define FXAA_QUALITY_P3 1.0\n    #define FXAA_QUALITY_P4 1.0\n    #define FXAA_QUALITY_P5 1.5\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n    #define FxaaBool bool\n    #define FxaaDiscard discard\n    #define FxaaFloat float\n    #define FxaaFloat2 vec2\n    #define FxaaFloat3 vec3\n    #define FxaaFloat4 vec4\n    #define FxaaHalf float\n    #define FxaaHalf2 vec2\n    #define FxaaHalf3 vec3\n    #define FxaaHalf4 vec4\n    #define FxaaInt2 ivec2\n    #define FxaaSat(x) clamp(x, 0.0, 1.0)\n    #define FxaaTex sampler2D\n#else\n    #define FxaaBool bool\n    #define FxaaDiscard clip(-1)\n    #define FxaaFloat float\n    #define FxaaFloat2 float2\n    #define FxaaFloat3 float3\n    #define FxaaFloat4 float4\n    #define FxaaHalf half\n    #define FxaaHalf2 half2\n    #define FxaaHalf3 half3\n    #define FxaaHalf4 half4\n    #define FxaaSat(x) saturate(x)\n#endif\n#if (FXAA_GLSL_100 == 1)\n  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n#endif\n#if (FXAA_GLSL_120 == 1)\n    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n    #if (FXAA_FAST_PIXEL_OFFSET == 1)\n        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n    #else\n        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n    #endif\n    #if (FXAA_GATHER4_ALPHA == 1)\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n    #endif\n#endif\n#if (FXAA_GLSL_130 == 1)\n    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n    #if (FXAA_GATHER4_ALPHA == 1)\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n    #endif\n#endif\n#if (FXAA_HLSL_3 == 1)\n    #define FxaaInt2 float2\n    #define FxaaTex sampler2D\n    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n#endif\n#if (FXAA_HLSL_4 == 1)\n    #define FxaaInt2 int2\n    struct FxaaTex { SamplerState smpl; Texture2D tex; };\n    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n#endif\n#if (FXAA_HLSL_5 == 1)\n    #define FxaaInt2 int2\n    struct FxaaTex { SamplerState smpl; Texture2D tex; };\n    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n#endif\n#if (FXAA_GREEN_AS_LUMA == 0)\n    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n#else\n    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n#endif\n#if (FXAA_PC == 1)\nFxaaFloat4 FxaaPixelShader(\n    FxaaFloat2 pos,\n    FxaaFloat4 fxaaConsolePosPos,\n    FxaaTex tex,\n    FxaaTex fxaaConsole360TexExpBiasNegOne,\n    FxaaTex fxaaConsole360TexExpBiasNegTwo,\n    FxaaFloat2 fxaaQualityRcpFrame,\n    FxaaFloat4 fxaaConsoleRcpFrameOpt,\n    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n    FxaaFloat fxaaQualitySubpix,\n    FxaaFloat fxaaQualityEdgeThreshold,\n    FxaaFloat fxaaQualityEdgeThresholdMin,\n    FxaaFloat fxaaConsoleEdgeSharpness,\n    FxaaFloat fxaaConsoleEdgeThreshold,\n    FxaaFloat fxaaConsoleEdgeThresholdMin,\n    FxaaFloat4 fxaaConsole360ConstDir\n) {\n    FxaaFloat2 posM;\n    posM.x = pos.x;\n    posM.y = pos.y;\n    #if (FXAA_GATHER4_ALPHA == 1)\n        #if (FXAA_DISCARD == 0)\n            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n            #if (FXAA_GREEN_AS_LUMA == 0)\n                #define lumaM rgbyM.w\n            #else\n                #define lumaM rgbyM.y\n            #endif\n        #endif\n        #if (FXAA_GREEN_AS_LUMA == 0)\n            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n        #else\n            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n        #endif\n        #if (FXAA_DISCARD == 1)\n            #define lumaM luma4A.w\n        #endif\n        #define lumaE luma4A.z\n        #define lumaS luma4A.x\n        #define lumaSE luma4A.y\n        #define lumaNW luma4B.w\n        #define lumaN luma4B.z\n        #define lumaW luma4B.x\n    #else\n        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n        #if (FXAA_GREEN_AS_LUMA == 0)\n            #define lumaM rgbyM.w\n        #else\n            #define lumaM rgbyM.y\n        #endif\n        #if (FXAA_GLSL_100 == 1)\n          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n        #else\n          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n        #endif\n    #endif\n    FxaaFloat maxSM = max(lumaS, lumaM);\n    FxaaFloat minSM = min(lumaS, lumaM);\n    FxaaFloat maxESM = max(lumaE, maxSM);\n    FxaaFloat minESM = min(lumaE, minSM);\n    FxaaFloat maxWN = max(lumaN, lumaW);\n    FxaaFloat minWN = min(lumaN, lumaW);\n    FxaaFloat rangeMax = max(maxWN, maxESM);\n    FxaaFloat rangeMin = min(minWN, minESM);\n    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n    FxaaFloat range = rangeMax - rangeMin;\n    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    FxaaBool earlyExit = range < rangeMaxClamped;\n    if(earlyExit)\n        #if (FXAA_DISCARD == 1)\n            FxaaDiscard;\n        #else\n            return rgbyM;\n        #endif\n    #if (FXAA_GATHER4_ALPHA == 0)\n        #if (FXAA_GLSL_100 == 1)\n          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n        #else\n          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n        #endif\n    #else\n        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n    #endif\n    FxaaFloat lumaNS = lumaN + lumaS;\n    FxaaFloat lumaWE = lumaW + lumaE;\n    FxaaFloat subpixRcpRange = 1.0/range;\n    FxaaFloat subpixNSWE = lumaNS + lumaWE;\n    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n    FxaaFloat lumaNESE = lumaNE + lumaSE;\n    FxaaFloat lumaNWNE = lumaNW + lumaNE;\n    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n    FxaaFloat lumaNWSW = lumaNW + lumaSW;\n    FxaaFloat lumaSWSE = lumaSW + lumaSE;\n    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n    FxaaBool horzSpan = edgeHorz >= edgeVert;\n    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n    if(!horzSpan) lumaN = lumaW;\n    if(!horzSpan) lumaS = lumaE;\n    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n    FxaaFloat gradientN = lumaN - lumaM;\n    FxaaFloat gradientS = lumaS - lumaM;\n    FxaaFloat lumaNN = lumaN + lumaM;\n    FxaaFloat lumaSS = lumaS + lumaM;\n    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n    if(pairN) lengthSign = -lengthSign;\n    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n    FxaaFloat2 posB;\n    posB.x = posM.x;\n    posB.y = posM.y;\n    FxaaFloat2 offNP;\n    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n    if(!horzSpan) posB.x += lengthSign * 0.5;\n    if( horzSpan) posB.y += lengthSign * 0.5;\n    FxaaFloat2 posN;\n    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat2 posP;\n    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n    FxaaFloat subpixE = subpixC * subpixC;\n    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n    if(!pairN) lumaNN = lumaSS;\n    FxaaFloat gradientScaled = gradient * 1.0/4.0;\n    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n    FxaaFloat subpixF = subpixD * subpixE;\n    FxaaBool lumaMLTZero = lumaMM < 0.0;\n    lumaEndN -= lumaNN * 0.5;\n    lumaEndP -= lumaNN * 0.5;\n    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n    FxaaBool doneNP = (!doneN) || (!doneP);\n    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n        #if (FXAA_QUALITY_PS > 3)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n            #if (FXAA_QUALITY_PS > 4)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n                #if (FXAA_QUALITY_PS > 5)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n                    #if (FXAA_QUALITY_PS > 6)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n                        #if (FXAA_QUALITY_PS > 7)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n    #if (FXAA_QUALITY_PS > 8)\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n        #if (FXAA_QUALITY_PS > 9)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n            #if (FXAA_QUALITY_PS > 10)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n                #if (FXAA_QUALITY_PS > 11)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n                    #if (FXAA_QUALITY_PS > 12)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n                    }\n                    #endif\n                }\n                #endif\n            }\n            #endif\n        }\n        #endif\n    }\n    #endif\n                        }\n                        #endif\n                    }\n                    #endif\n                }\n                #endif\n            }\n            #endif\n        }\n        #endif\n    }\n    FxaaFloat dstN = posM.x - posN.x;\n    FxaaFloat dstP = posP.x - posM.x;\n    if(!horzSpan) dstN = posM.y - posN.y;\n    if(!horzSpan) dstP = posP.y - posM.y;\n    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n    FxaaFloat spanLength = (dstP + dstN);\n    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n    FxaaFloat spanLengthRcp = 1.0/spanLength;\n    FxaaBool directionN = dstN < dstP;\n    FxaaFloat dst = min(dstN, dstP);\n    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n    FxaaFloat subpixG = subpixF * subpixF;\n    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n    #if (FXAA_DISCARD == 1)\n        return FxaaTexTop(tex, posM);\n    #else\n        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n    #endif\n}\n#endif\nvoid main() {\n  gl_FragColor = FxaaPixelShader(\n    vUv,\n    vec4(0.0),\n    map,\n    map,\n    map,\n    resolution,\n    vec4(0.0),\n    vec4(0.0),\n    vec4(0.0),\n    0.75,\n    0.166,\n    0.0833,\n    0.0,\n    0.0,\n    0.0,\n    vec4(0.0)\n  );\n  gl_FragColor.a = texture2D(map, vUv).a;\n}" }], "techniques": [{ "name": "fxaa1", "attributes": {}, "uniforms": { "map": { "type": 35678 } } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.fxaa = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "fxaa_vert", "type": 35633, "uri": "\nuniform vec2 resolution;\nvarying vec2 vUV;\nvarying vec2 sampleCoordS;\nvarying vec2 sampleCoordE;\nvarying vec2 sampleCoordN;\nvarying vec2 sampleCoordW;\nvarying vec2 sampleCoordNW;\nvarying vec2 sampleCoordSE;\nvarying vec2 sampleCoordNE;\nvarying vec2 sampleCoordSW;\nvoid main(void) {\t\n\tvUV = uv;\n\tsampleCoordS = vUV + vec2( 0.0, 1.0) * resolution;\n\tsampleCoordE = vUV + vec2( 1.0, 0.0) * resolution;\n\tsampleCoordN = vUV + vec2( 0.0,-1.0) * resolution;\n\tsampleCoordW = vUV + vec2(-1.0, 0.0) * resolution;\n\tsampleCoordNW = vUV + vec2(-1.0,-1.0) * resolution;\n\tsampleCoordSE = vUV + vec2( 1.0, 1.0) * resolution;\n\tsampleCoordNE = vUV + vec2( 1.0,-1.0) * resolution;\n\tsampleCoordSW = vUV + vec2(-1.0, 1.0) * resolution;\n\tgl_Position = vec4(position.x, position.y, 0.0, 1.0);\n}" }, { "name": "fxaa_frag", "type": 35632, "uri": "uniform sampler2D map;\nuniform vec2 resolution;\nvarying vec2 vUV;\nvarying vec2 sampleCoordS;\nvarying vec2 sampleCoordE;\nvarying vec2 sampleCoordN;\nvarying vec2 sampleCoordW;\nvarying vec2 sampleCoordNW;\nvarying vec2 sampleCoordSE;\nvarying vec2 sampleCoordNE;\nvarying vec2 sampleCoordSW;\nconst float fxaaQualitySubpix = 1.0;\nconst float fxaaQualityEdgeThreshold = 0.166;\nconst float fxaaQualityEdgeThresholdMin = 0.0833;\nconst vec3 kLumaCoefficients = vec3(0.2126, 0.7152, 0.0722);\n#define FxaaLuma(rgba) dot(rgba.rgb, kLumaCoefficients)\nvoid main(){\n\tvec2 posM;\n\tposM.x = vUV.x;\n\tposM.y = vUV.y;\n\tvec4 rgbyM = texture2D(map, vUV, 0.0);\n\tfloat lumaM = FxaaLuma(rgbyM);\n\tfloat lumaS = FxaaLuma(texture2D(map, sampleCoordS, 0.0));\n\tfloat lumaE = FxaaLuma(texture2D(map, sampleCoordE, 0.0));\n\tfloat lumaN = FxaaLuma(texture2D(map, sampleCoordN, 0.0));\n\tfloat lumaW = FxaaLuma(texture2D(map, sampleCoordW, 0.0));\n\tfloat maxSM = max(lumaS, lumaM);\n\tfloat minSM = min(lumaS, lumaM);\n\tfloat maxESM = max(lumaE, maxSM);\n\tfloat minESM = min(lumaE, minSM);\n\tfloat maxWN = max(lumaN, lumaW);\n\tfloat minWN = min(lumaN, lumaW);\n\tfloat rangeMax = max(maxWN, maxESM);\n\tfloat rangeMin = min(minWN, minESM);\n\tfloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n\tfloat range = rangeMax - rangeMin;\n\tfloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n#ifndef MALI\n\tif(range < rangeMaxClamped) \n\t{\n\t\tgl_FragColor = rgbyM;\n\t\treturn;\n\t}\n#endif\n\tfloat lumaNW = FxaaLuma(texture2D(map, sampleCoordNW, 0.0));\n\tfloat lumaSE = FxaaLuma(texture2D(map, sampleCoordSE, 0.0));\n\tfloat lumaNE = FxaaLuma(texture2D(map, sampleCoordNE, 0.0));\n\tfloat lumaSW = FxaaLuma(texture2D(map, sampleCoordSW, 0.0));\n\tfloat lumaNS = lumaN + lumaS;\n\tfloat lumaWE = lumaW + lumaE;\n\tfloat subpixRcpRange = 1.0 / range;\n\tfloat subpixNSWE = lumaNS + lumaWE;\n\tfloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n\tfloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n\tfloat lumaNESE = lumaNE + lumaSE;\n\tfloat lumaNWNE = lumaNW + lumaNE;\n\tfloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n\tfloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n\tfloat lumaNWSW = lumaNW + lumaSW;\n\tfloat lumaSWSE = lumaSW + lumaSE;\n\tfloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n\tfloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n\tfloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n\tfloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n\tfloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n\tfloat edgeVert = abs(edgeVert3) + edgeVert4;\n\tfloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n\tfloat lengthSign = resolution.x;\n\tbool horzSpan = edgeHorz >= edgeVert;\n\tfloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n\tif (!horzSpan)\n\t{\n\t\tlumaN = lumaW;\n\t}\n\tif (!horzSpan) \n\t{\n\t\tlumaS = lumaE;\n\t}\n\tif (horzSpan) \n\t{\n\t\tlengthSign = resolution.y;\n\t}\n\tfloat subpixB = (subpixA * (1.0 / 12.0)) - lumaM;\n\tfloat gradientN = lumaN - lumaM;\n\tfloat gradientS = lumaS - lumaM;\n\tfloat lumaNN = lumaN + lumaM;\n\tfloat lumaSS = lumaS + lumaM;\n\tbool pairN = abs(gradientN) >= abs(gradientS);\n\tfloat gradient = max(abs(gradientN), abs(gradientS));\n\tif (pairN)\n\t{\n\t\tlengthSign = -lengthSign;\n\t}\n\tfloat subpixC = clamp(abs(subpixB) * subpixRcpRange, 0.0, 1.0);\n\tvec2 posB;\n\tposB.x = posM.x;\n\tposB.y = posM.y;\n\tvec2 offNP;\n\toffNP.x = (!horzSpan) ? 0.0 : resolution.x;\n\toffNP.y = (horzSpan) ? 0.0 : resolution.y;\n\tif (!horzSpan) \n\t{\n\t\tposB.x += lengthSign * 0.5;\n\t}\n\tif (horzSpan)\n\t{\n\t\tposB.y += lengthSign * 0.5;\n\t}\n\tvec2 posN;\n\tposN.x = posB.x - offNP.x * 1.5;\n\tposN.y = posB.y - offNP.y * 1.5;\n\tvec2 posP;\n\tposP.x = posB.x + offNP.x * 1.5;\n\tposP.y = posB.y + offNP.y * 1.5;\n\tfloat subpixD = ((-2.0) * subpixC) + 3.0;\n\tfloat lumaEndN = FxaaLuma(texture2D(map, posN, 0.0));\n\tfloat subpixE = subpixC * subpixC;\n\tfloat lumaEndP = FxaaLuma(texture2D(map, posP, 0.0));\n\tif (!pairN) \n\t{\n\t\tlumaNN = lumaSS;\n\t}\n\tfloat gradientScaled = gradient * 1.0 / 4.0;\n\tfloat lumaMM = lumaM - lumaNN * 0.5;\n\tfloat subpixF = subpixD * subpixE;\n\tbool lumaMLTZero = lumaMM < 0.0;\n\tlumaEndN -= lumaNN * 0.5;\n\tlumaEndP -= lumaNN * 0.5;\n\tbool doneN = abs(lumaEndN) >= gradientScaled;\n\tbool doneP = abs(lumaEndP) >= gradientScaled;\n\tif (!doneN) \n\t{\n\t\tposN.x -= offNP.x * 3.0;\n\t}\n\tif (!doneN) \n\t{\n\t\tposN.y -= offNP.y * 3.0;\n\t}\n\tbool doneNP = (!doneN) || (!doneP);\n\tif (!doneP) \n\t{\n\t\tposP.x += offNP.x * 3.0;\n\t}\n\tif (!doneP)\n\t{\n\t\tposP.y += offNP.y * 3.0;\n\t}\n\tif (doneNP)\n\t{\n\t\tif (!doneN) lumaEndN = FxaaLuma(texture2D(map, posN.xy, 0.0));\n\t\tif (!doneP) lumaEndP = FxaaLuma(texture2D(map, posP.xy, 0.0));\n\t\tif (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\tif (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\n\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\n\t\tif (!doneN) posN.x -= offNP.x * 12.0;\n\t\tif (!doneN) posN.y -= offNP.y * 12.0;\n\t\n\t\tdoneNP = (!doneN) || (!doneP);\n\t\n\t\tif (!doneP) posP.x += offNP.x * 12.0;\n\t\tif (!doneP) posP.y += offNP.y * 12.0;\n\t}\n\tfloat dstN = posM.x - posN.x;\n\tfloat dstP = posP.x - posM.x;\n\tif (!horzSpan)\n\t{\n\t\tdstN = posM.y - posN.y;\n\t}\n\tif (!horzSpan) \n\t{\n\t\tdstP = posP.y - posM.y;\n\t}\n\tbool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n\tfloat spanLength = (dstP + dstN);\n\tbool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n\tfloat spanLengthRcp = 1.0 / spanLength;\n\tbool directionN = dstN < dstP;\n\tfloat dst = min(dstN, dstP);\n\tbool goodSpan = directionN ? goodSpanN : goodSpanP;\n\tfloat subpixG = subpixF * subpixF;\n\tfloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n\tfloat subpixH = subpixG * fxaaQualitySubpix;\n\tfloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n\tfloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n\tif (!horzSpan)\n\t{\n\t\tposM.x += pixelOffsetSubpix * lengthSign;\n\t}\n\tif (horzSpan)\n\t{\n\t\tposM.y += pixelOffsetSubpix * lengthSign;\n\t}\n#ifdef MALI\n\tif(range < rangeMaxClamped) \n\t{\n\t\tgl_FragColor = rgbyM;\n\t}\n\telse\n\t{\n\t\tgl_FragColor = texture2D(map, posM, 0.0);\n\t}\n#else\n\tgl_FragColor = texture2D(map, posM, 0.0);\n#endif\n}" }], "techniques": [{ "name": "fxaa", "attributes": {}, "uniforms": { "map": { "type": 35678 } } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.linebasic = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "linebasic_vert", "type": 35633, "uri": "#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nuniform float linewidth;\nuniform vec2 resolution;\nattribute vec3 instanceStart;\nattribute vec3 instanceEnd;\nattribute vec3 instanceColorStart;\nattribute vec3 instanceColorEnd;\nvarying vec2 vUv;\n#ifdef USE_DASH\n\tuniform float dashScale;\n\tattribute float instanceDistanceStart;\n\tattribute float instanceDistanceEnd;\n\tvarying float vLineDistance;\n#endif\nvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\tfloat a = projectionMatrix[ 2 ][ 2 ];\n\tfloat b = projectionMatrix[ 3 ][ 2 ];\n\tfloat nearEstimate = - 0.5 * b / a;\n\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\tend.xyz = mix( start.xyz, end.xyz, alpha );\n}\nvoid main() {\n\t#ifdef USE_COLOR\n\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\t#endif\n\t#ifdef USE_DASH\n\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t#endif\n\tfloat aspect = resolution.x / resolution.y;\n\tvUv = uv;\n\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\tif ( perspective ) {\n\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\t\t\ttrimSegment( start, end );\n\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\t\t\ttrimSegment( end, start );\n\t\t}\n\t}\n\tvec4 clipStart = projectionMatrix * start;\n\tvec4 clipEnd = projectionMatrix * end;\n\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\tvec2 dir = ndcEnd - ndcStart;\n\tdir.x *= aspect;\n\tdir = normalize( dir );\n\tvec2 offset = vec2( dir.y, - dir.x );\n\tdir.x /= aspect;\n\toffset.x /= aspect;\n\tif ( position.x < 0.0 ) offset *= - 1.0;\n\tif ( position.y < 0.0 ) {\n\t\toffset += - dir;\n\t} else if ( position.y > 1.0 ) {\n\t\toffset += dir;\n\t}\n\toffset *= linewidth;\n\toffset /= resolution.y;\n\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\toffset *= clip.w;\n\tclip.xy += offset;\n\tgl_Position = clip;\n\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}" }, { "name": "linebasic_frag", "type": 35632, "uri": "uniform vec3 diffuse;\nuniform float opacity;\n#ifdef USE_DASH\n\tuniform float dashSize;\n\tuniform float gapSize;\n#endif\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vUv;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#ifdef USE_DASH\n\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard;\n\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard;\n\t#endif\n\tif ( abs( vUv.y ) > 1.0 ) {\n\t\tfloat a = vUv.x;\n\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\tfloat len2 = a * a + b * b;\n\t\tif ( len2 > 1.0 ) discard;\n\t}\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}" }], "techniques": [{ "name": "linebasic", "attributes": {}, "uniforms": { "linewidth": { "type": 5126, "value": 1 }, "dashScale": { "type": 5126, "value": 1 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "dashSize": { "type": 5126, "value": 1 }, "gapSize": { "type": 5126, "value": 1 }, "clippingPlanes[0]": { "type": 35666 } } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.linedashed = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "linedashed_vert", "type": 35633, "uri": "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n" }, { "name": "linedashed_frag", "type": 35632, "uri": "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n" }], "techniques": [{ "name": "linedashed", "attributes": {}, "uniforms": { "scale": { "type": 5126, "value": 1 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "dashSize": { "type": 5126, "value": 1 }, "totalSize": { "type": 5126, "value": 1 }, "clippingPlanes[0]": { "type": 35666 } } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.meshbasic = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "meshbasic_vert", "type": 35633, "uri": "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <custom_vertex>\nvoid main() {\n\t#include <custom_begin_vertex>\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n\t#include <custom_end_vertex>\n}\n" }, { "name": "meshbasic_frag", "type": 35632, "uri": "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <custom_fragment>\nvoid main() {\n\t#include <custom_begin_fragment>\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightmapTex = texture2D(lightMap, vUv2);\n\t\tfloat power = 5.0 * lightmapTex.a;\n\t\treflectedLight.indirectDiffuse += lightmapTex.rgb * power * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <custom_end_fragment>\n}\n" }], "techniques": [{ "name": "meshbasic", "attributes": {}, "uniforms": { "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "refractionRatio": { "type": 5126, "value": 0.98 }, "morphTargetInfluences[0]": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "aoMap": { "type": 35678 }, "aoMapIntensity": { "type": 5126, "value": 1 }, "reflectivity": { "type": 5126, "value": 1 }, "envMapIntensity": { "type": 5126, "value": 1 }, "envMap": { "type": 35678 }, "flipEnvMap": { "type": 5126, "value": 1 }, "maxMipLevel": { "type": 5124 }, "specularMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.meshlambert = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "meshlambert_vert", "type": 35633, "uri": "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <custom_vertex>\nvoid main() {\n\t#include <custom_begin_vertex>\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\t#include <custom_end_vertex>\n}\n" }, { "name": "meshlambert_frag", "type": 35632, "uri": "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <custom_fragment>\nvoid main() {\n\t#include <custom_begin_fragment>\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\t#include <custom_end_fragment>\n}\n" }], "techniques": [{ "name": "meshlambert", "attributes": {}, "uniforms": { "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "refractionRatio": { "type": 5126, "value": 0.98 }, "morphTargetInfluences[0]": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "emissive": { "type": 35665, "value": [0, 0, 0] }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "aoMap": { "type": 35678 }, "aoMapIntensity": { "type": 5126, "value": 1 }, "emissiveMap": { "type": 35678 }, "reflectivity": { "type": 5126, "value": 1 }, "envMapIntensity": { "type": 5126, "value": 1 }, "envMap": { "type": 35678 }, "flipEnvMap": { "type": 5126, "value": 1 }, "maxMipLevel": { "type": 5124 }, "specularMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.meshphong = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "meshphong_vert", "type": 35633, "uri": "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <custom_vertex>\nvoid main() {\n\t#include <custom_begin_vertex>\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\t#include <custom_end_vertex>\n}\n" }, { "name": "meshphong_frag", "type": 35632, "uri": "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <custom_fragment>\nvoid main() {\n\t#include <custom_begin_fragment>\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\t#include <custom_end_fragment>\n}\n" }], "techniques": [{ "name": "meshphong", "attributes": {}, "uniforms": { "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126, "value": 1 }, "displacementBias": { "type": 5126 }, "refractionRatio": { "type": 5126, "value": 0.98 }, "morphTargetInfluences[0]": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "emissive": { "type": 35665, "value": [0, 0, 0] }, "specular": { "type": 35665, "value": [0.066666, 0.066666, 0.066666] }, "shininess": { "type": 5126, "value": 30 }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "aoMap": { "type": 35678 }, "aoMapIntensity": { "type": 5126, "value": 1 }, "emissiveMap": { "type": 35678 }, "reflectivity": { "type": 5126, "value": 1 }, "envMapIntensity": { "type": 5126, "value": 1 }, "envMap": { "type": 35678 }, "flipEnvMap": { "type": 5126, "value": 1 }, "maxMipLevel": { "type": 5124 }, "gradientMap": { "type": 35678 }, "bumpMap": { "type": 35678 }, "bumpScale": { "type": 5126, "value": 1 }, "normalMap": { "type": 35678 }, "normalScale": { "type": 35664, "value": [1, 1] }, "specularMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.meshphysical = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "meshphysical_vert", "type": 35633, "uri": "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <custom_vertex>\nvoid main() {\n\t#include <custom_begin_vertex>\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\t#include <custom_end_vertex>\n}\n" }, { "name": "meshphysical_frag", "type": 35632, "uri": "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <custom_fragment>\nvoid main() {\n\t#include <custom_begin_fragment>\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\t#include <custom_end_fragment>\n}\n" }], "techniques": [{ "name": "meshphysical", "attributes": {}, "uniforms": { "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126, "value": 1 }, "displacementBias": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "emissive": { "type": 35665, "value": [0, 0, 0] }, "roughness": { "type": 5126, "value": 0.5 }, "metalness": { "type": 5126, "value": 0.5 }, "opacity": { "type": 5126, "value": 1 }, "clearCoat": { "type": 5126 }, "clearCoatRoughness": { "type": 5126 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "aoMap": { "type": 35678 }, "aoMapIntensity": { "type": 5126, "value": 1 }, "emissiveMap": { "type": 35678 }, "reflectivity": { "type": 5126, "value": 1 }, "envMapIntensity": { "type": 5126, "value": 1 }, "envMap": { "type": 35678 }, "flipEnvMap": { "type": 5126, "value": 1 }, "maxMipLevel": { "type": 5124 }, "refractionRatio": { "type": 5126, "value": 0.98 }, "bumpMap": { "type": 35678 }, "bumpScale": { "type": 5126, "value": 1 }, "normalMap": { "type": 35678 }, "normalScale": { "type": 35664, "value": [1, 1] }, "roughnessMap": { "type": 35678 }, "metalnessMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.normal = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "normal_vert", "type": 35633, "uri": "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n" }, { "name": "normal_frag", "type": 35632, "uri": "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n" }], "techniques": [{ "name": "normal", "attributes": {}, "uniforms": { "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126, "value": 1 }, "displacementBias": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "opacity": { "type": 5126, "value": 1 }, "bumpMap": { "type": 35678 }, "bumpScale": { "type": 5126, "value": 1 }, "normalMap": { "type": 35678 }, "normalScale": { "type": 35664, "value": [1, 1] } } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.particle = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "particle_vert", "type": 35633, "uri": "\n#include <common>\n#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\n\tattribute vec2 corner;\n#endif\nattribute vec3 startPosition;\nattribute vec3 startVelocity;\nattribute vec4 startColor;\nattribute vec3 startSize;\nattribute vec3 startRotation;\nattribute vec2 time;\n#if defined(COLOROGRADIENT)||defined(COLORTWOGRADIENTS)||defined(SIZETWOCURVES)||defined(SIZETWOCURVESSEPERATE)||defined(ROTATIONTWOCONSTANTS)||defined(ROTATIONTWOCURVES)\n  attribute vec4 random0;\n#endif\n#if defined(TEXTURESHEETANIMATIONTWOCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n  attribute vec4 random1;\n#endif\nattribute vec3 startWorldPosition;\nattribute vec4 startWorldRotation;\n#include <particle_common>\n#include <fog_pars_vertex>\nvoid main()\n{\n\tfloat age = u_currentTime - time.y;\n\tfloat t = age/time.x;\n\tif(t>1.0){ \t\t\t\n\t\t\tv_discard=1.0;\n\t\t\treturn;\n  }\n\t  \n\t#include <particle_affector>\n\tvec4 mvPosition = viewMatrix * vec4( center, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\tv_color = computeColor(startColor, t);\n\tv_texcoord = computeUV(uv, t);\n\tv_discard=0.0;\n\t#include <fog_vertex>\n}\n" }, { "name": "particle_frag", "type": 35632, "uri": "\n#include <common>\n#include <fog_pars_fragment>\nuniform sampler2D map;\nuniform vec3 diffuse;\nuniform float opacity;\nvarying float v_discard;\nvarying vec4 v_color;\nvarying vec2 v_texcoord;\n#ifdef RENDERMESH\n\tvarying vec4 v_mesh_color;\n#endif\nvoid main()\n{\t\n\t#ifdef RENDERMESH\n\t\tgl_FragColor=v_mesh_color;\n\t#else\n\t\tgl_FragColor=vec4(1.0);\t\n\t#endif\n\tif(v_discard!=0.0)\n\t\tdiscard;\n\tgl_FragColor*=texture2D(map,v_texcoord)*vec4(diffuse, opacity)*v_color*2.0;\n\t#include <fog_fragment>\n}" }], "techniques": [{ "name": "particle", "attributes": {}, "uniforms": { "u_currentTime": { "type": 5126 }, "u_gravity": { "type": 35665 }, "u_worldPosition": { "type": 35665, "value": [0, 0, 0] }, "u_worldRotation": { "type": 35666, "value": [0, 0, 0, 1] }, "u_startRotation3D": { "type": 35670 }, "u_scalingMode": { "type": 5124 }, "u_positionScale": { "type": 35665 }, "u_sizeScale": { "type": 35665 }, "u_lengthScale": { "type": 5126 }, "u_speeaScale": { "type": 5126 }, "u_simulationSpace": { "type": 5124 }, "u_spaceType": { "type": 5124 }, "u_velocityConst": { "type": 35665 }, "u_velocityCurveX[0]": { "type": 35664 }, "u_velocityCurveY[0]": { "type": 35664 }, "u_velocityCurveZ[0]": { "type": 35664 }, "u_velocityConstMax": { "type": 35665 }, "u_velocityCurveMaxX[0]": { "type": 35664 }, "u_velocityCurveMaxY[0]": { "type": 35664 }, "u_velocityCurveMaxZ[0]": { "type": 35664 }, "u_colorGradient[0]": { "type": 35666 }, "u_alphaGradient[0]": { "type": 35664 }, "u_colorGradientMax[0]": { "type": 35666 }, "u_alphaGradientMax[0]": { "type": 35664 }, "u_sizeCurve[0]": { "type": 35664 }, "u_sizeCurveMax[0]": { "type": 35664 }, "u_sizeCurveX[0]": { "type": 35664 }, "u_sizeCurveY[0]": { "type": 35664 }, "u_sizeCurveZ[0]": { "type": 35664 }, "u_sizeCurveMaxX[0]": { "type": 35664 }, "u_sizeCurveMaxY[0]": { "type": 35664 }, "u_sizeCurveMaxZ[0]": { "type": 35664 }, "u_rotationConst": { "type": 5126 }, "u_rotationConstMax": { "type": 5126 }, "u_rotationCurve[0]": { "type": 35664 }, "u_rotationCurveMax[0]": { "type": 35664 }, "u_rotationConstSeprarate": { "type": 35665 }, "u_rotationConstMaxSeprarate": { "type": 35665 }, "u_rotationCurveX[0]": { "type": 35664 }, "u_rotationCurveY[0]": { "type": 35664 }, "u_rotationCurveZ[0]": { "type": 35664 }, "u_rotationCurveW[0]": { "type": 35664 }, "u_rotationCurveMaxX[0]": { "type": 35664 }, "u_rotationCurveMaxY[0]": { "type": 35664 }, "u_rotationCurveMaxZ[0]": { "type": 35664 }, "u_rotationCurveMaxW[0]": { "type": 35664 }, "u_cycles": { "type": 5126 }, "u_subUV": { "type": 35666 }, "u_uvCurve[0]": { "type": 35664 }, "u_uvCurveMax[0]": { "type": 35664 }, "map": { "type": 35678 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 } } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.points = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "points_vert", "type": 35633, "uri": "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}\n" }, { "name": "points_frag", "type": 35632, "uri": "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n" }], "techniques": [{ "name": "points", "attributes": {}, "uniforms": { "size": { "type": 5126 }, "scale": { "type": 5126, "value": 1 }, "morphTargetInfluences[0]": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "map": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.shadow = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "shadow_vert", "type": 35633, "uri": "\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n" }, { "name": "shadow_frag", "type": 35632, "uri": "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n" }], "techniques": [{ "name": "shadow", "attributes": {}, "uniforms": { "color": { "type": 35665 }, "opacity": { "type": 5126, "value": 1 } } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
        ShaderLib.sprite = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "sprite_vert", "type": 35633, "uri": "\nuniform vec2 scale2D;\nuniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale = scale2D;\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n" }, { "name": "sprite_frag", "type": 35632, "uri": "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n" }], "techniques": [{ "name": "sprite", "attributes": {}, "uniforms": { "center": { "type": 35664, "value": [0.5, 0.5] }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } } }] }, "paper": {} }, "extensionsRequired": ["paper", "KHR_techniques_webgl"], "extensionsUsed": ["paper", "KHR_techniques_webgl"] };
    })(ShaderLib = egret3d.ShaderLib || (egret3d.ShaderLib = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ShaderChunk;
    (function (ShaderChunk) {
        ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";
        ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";
        ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";
        ShaderChunk.aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";
        ShaderChunk.aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
        ShaderChunk.beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";
        ShaderChunk.begin_vertex = "\nvec3 transformed = vec3( position );\n";
        ShaderChunk.bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit(\n ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit(\n );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
        ShaderChunk.bumpMap_pars_frag = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd(vec2 uv) {\n\t\tvec2 dSTdx = dFdx( uv );\n\t\tvec2 dSTdy = dFdy( uv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, uv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, uv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, uv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";
        ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";
        ShaderChunk.clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n";
        ShaderChunk.clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";
        ShaderChunk.clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";
        ShaderChunk.clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";
        ShaderChunk.color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
        ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";
        ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
        ShaderChunk.color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
        ShaderChunk.common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n";
        ShaderChunk.common_frag_def = "uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;";
        ShaderChunk.common_vert_def = "uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n#ifdef USE_COLOR\n\tattribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif";
        ShaderChunk.cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";
        ShaderChunk.defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n";
        ShaderChunk.displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";
        ShaderChunk.displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";
        ShaderChunk.dithering_fragment = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";
        ShaderChunk.dithering_pars_fragment = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n";
        ShaderChunk.emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";
        ShaderChunk.emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";
        ShaderChunk.encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";
        ShaderChunk.encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";
        ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifndef ENVMAP_MODE_REFRACTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.y = 1.0 - sampleUV.y;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\t\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, -1.0 ) );\n\t\treflectView = vec3(reflectView.x * 0.5 + 0.5, 1.0 - (reflectView.y * 0.5 + 0.5), 0.0);\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy);\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";
        ShaderChunk.envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";
        ShaderChunk.envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";
        ShaderChunk.envmap_physical_pars_fragment = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance(\n const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance(\n const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifndef ENVMAP_MODE_REFRACTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\t\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, -1.0 ) );\n\t\t\treflectView = vec3(reflectView.x * 0.5 + 0.5, 1.0 - (reflectView.y * 0.5 + 0.5), 0.0);\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";
        ShaderChunk.envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifndef ENVMAP_MODE_REFRACTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";
        ShaderChunk.fog_fragment = "#ifdef USE_FOG\n\tfloat fogDepth = length( vFogPosition );\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";
        ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying vec3 vFogPosition;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";
        ShaderChunk.fog_pars_vertex = "#ifdef USE_FOG\n\tvarying vec3 vFogPosition;\n#endif\n";
        ShaderChunk.fog_vertex = "#ifdef USE_FOG\n\tvFogPosition = mvPosition.xyz;\n#endif\n";
        ShaderChunk.gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";
        ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";
        ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
        ShaderChunk.lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if (NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight.position = vec3(pointLights[ i  * 15 + 0], pointLights[ i  * 15 + 1], pointLights[ i  * 15 + 2]);\n\t\tpointLight.color = vec3(pointLights[ i  * 15 + 3], pointLights[ i  * 15 + 4], pointLights[ i  * 15 + 5]);\n\t\tpointLight.distance = pointLights[ i  * 15 + 6];\n\t\tpointLight.decay = pointLights[ i  * 15 + 7];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tpointLight.shadow = int(pointLights[ i  * 15 + 8]);\n\t\tpointLight.shadowBias = pointLights[ i  * 15 + 9];\n\t\tpointLight.shadowRadius = pointLights[ i  * 15 + 10];\n\t\tpointLight.shadowMapSize = vec2(pointLights[ i  * 15 + 11], pointLights[ i  * 15 + 12]);\n\t\tpointLight.shadowCameraNear = pointLights[ i  * 15 + 13];\n\t\tpointLight.shadowCameraFar = pointLights[ i  * 15 + 14];\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if (NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight.position = vec3(spotLights[ i  * 18 + 0], spotLights[ i  * 18 + 1], spotLights[ i  * 18 + 2]);\n\t\tspotLight.direction = vec3(spotLights[ i  * 18 + 3], spotLights[ i  * 18 + 4], spotLights[ i  * 18 + 5]);\n\t\tspotLight.color = vec3(spotLights[ i  * 18 + 6], spotLights[ i  * 18 + 7], spotLights[ i  * 18 + 8]);\n\t\tspotLight.distance = spotLights[ i  * 18 + 9];\n\t\tspotLight.decay = spotLights[ i  * 18 + 10];\n\t\tspotLight.coneCos = spotLights[ i  * 18 + 11];\n\t\tspotLight.penumbraCos = spotLights[ i  * 18 + 12];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\t\n\t\tspotLight.shadow = int(spotLights[ i  * 18 + 13]);\n\t\tspotLight.shadowBias = spotLights[ i  * 18 + 14];\n\t\tspotLight.shadowRadius = spotLights[ i  * 18 + 15];\n\t\tspotLight.shadowMapSize = vec2(spotLights[ i  * 18 + 16], spotLights[ i  * 18 + 17]);\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if (NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight.direction = vec3(directionalLights[ i  * 11 + 0], directionalLights[ i  * 11 + 1], directionalLights[ i  * 11 + 2]);\n\t\tdirectionalLight.color = vec3(directionalLights[ i  * 11 + 3], directionalLights[ i  * 11 + 4], directionalLights[ i  * 11 + 5]);\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectionalLight.shadow = int(directionalLights[ i  * 11 + 6]);\n\t\tdirectionalLight.shadowBias = directionalLights[ i  * 11 + 7];\n\t\tdirectionalLight.shadowRadius = directionalLights[ i  * 11 + 8];\n\t\tdirectionalLight.shadowMapSize = vec2(directionalLights[ i  * 11 + 9], directionalLights[ i  * 11 + 10]);\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if (NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight.position = vec3(rectAreaLights[ i  * 12 + 0], rectAreaLights[ i  * 12 + 1], rectAreaLights[ i  * 12 + 2]);\n\t\trectAreaLight.color = vec3(rectAreaLights[ i  * 12 + 3], rectAreaLights[ i  * 12 + 4], rectAreaLights[ i  * 12 + 5]);\n\t\trectAreaLight.halfWidth = vec3(rectAreaLights[ i  * 12 + 6], rectAreaLights[ i  * 12 + 7], rectAreaLights[ i  * 12 + 8]);\n\t\trectAreaLight.halfHeight = vec3(rectAreaLights[ i  * 12 + 9], rectAreaLights[ i  * 12 + 10], rectAreaLights[ i  * 12 + 11]);\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if (NUM_HEMI_LIGHTS > 0 )\n\t\t\n\t\tHemisphereLight hemisphereLight;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\themisphereLight.direction = vec3(hemisphereLights[ i  * 9 + 0], hemisphereLights[ i  * 9 + 1], hemisphereLights[ i  * 9 + 2]);\n\t\t\themisphereLight.skyColor = vec3(hemisphereLights[ i  * 9 + 3], hemisphereLights[ i  * 9 + 4], hemisphereLights[ i  * 9 + 5]);\n\t\t\themisphereLight.groundColor = vec3(hemisphereLights[ i  * 9 + 6], hemisphereLights[ i  * 9 + 7], hemisphereLights[ i  * 9 + 8]);\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLight, geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n";
        ShaderChunk.lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";
        ShaderChunk.lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance(\n geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance(\n geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance(\n geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n";
        ShaderChunk.lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight.position = vec3(pointLights[ i  * 15 + 0], pointLights[ i  * 15 + 1], pointLights[ i  * 15 + 2]);\n\t\tpointLight.color = vec3(pointLights[ i  * 15 + 3], pointLights[ i  * 15 + 4], pointLights[ i  * 15 + 5]);\n\t\tpointLight.distance = pointLights[ i  * 15 + 6];\n\t\tpointLight.decay = pointLights[ i  * 15 + 7];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight.position = vec3(spotLights[ i  * 18 + 0], spotLights[ i  * 18 + 1], spotLights[ i  * 18 + 2]);\n\t\tspotLight.direction = vec3(spotLights[ i  * 18 + 3], spotLights[ i  * 18 + 4], spotLights[ i  * 18 + 5]);\n\t\tspotLight.color = vec3(spotLights[ i  * 18 + 6], spotLights[ i  * 18 + 7], spotLights[ i  * 18 + 8]);\n\t\tspotLight.distance = spotLights[ i  * 18 + 9];\n\t\tspotLight.decay = spotLights[ i  * 18 + 10];\n\t\tspotLight.coneCos = spotLights[ i  * 18 + 11];\n\t\tspotLight.penumbraCos = spotLights[ i  * 18 + 12];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight.direction = vec3(directionalLights[ i  * 11 + 0], directionalLights[ i  * 11 + 1], directionalLights[ i  * 11 + 2]);\n\t\tdirectionalLight.color = vec3(directionalLights[ i  * 11 + 3], directionalLights[ i  * 11 + 4], directionalLights[ i  * 11 + 5]);\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tHemisphereLight hemisphereLight;\n\t\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\themisphereLight.direction = vec3(hemisphereLights[ i  * 9 + 0], hemisphereLights[ i  * 9 + 1], hemisphereLights[ i  * 9 + 2]);\n\t\themisphereLight.skyColor = vec3(hemisphereLights[ i  * 9 + 3], hemisphereLights[ i  * 9 + 4], hemisphereLights[ i  * 9 + 5]);\n\t\themisphereLight.groundColor = vec3(hemisphereLights[ i  * 9 + 6], hemisphereLights[ i  * 9 + 7], hemisphereLights[ i  * 9 + 8]);\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLight, geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLight, backGeometry );\n\t\t#endif\n\t}\n#endif\n";
        ShaderChunk.lights_pars_begin = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform float directionalLights[NUM_DIR_LIGHTS * 11];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform float pointLights[NUM_POINT_LIGHTS * 15 ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform float spotLights[NUM_SPOT_LIGHTS * 18];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\n\tuniform sampler2D ltc_2;\n\tuniform float rectAreaLights[ NUM_RECT_AREA_LIGHTS * 12 ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform float hemisphereLights[ NUM_HEMI_LIGHTS * 9 ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n";
        ShaderChunk.lights_pars_maps = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance(\n const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance(\n const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifndef ENVMAP_MODE_REFRACTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, -1.0 ) );\n\t\t\treflectView = vec3(reflectView.x * 0.5 + 0.5, 1.0 - (reflectView.y * 0.5 + 0.5), 0.0);\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";
        ShaderChunk.lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
        ShaderChunk.lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";
        ShaderChunk.lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\n\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";
        ShaderChunk.lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";
        ShaderChunk.logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
        ShaderChunk.logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif\n";
        ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n";
        ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n";
        ShaderChunk.map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";
        ShaderChunk.map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";
        ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";
        ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n";
        ShaderChunk.metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";
        ShaderChunk.metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
        ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";
        ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
        ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";
        ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif\n";
        ShaderChunk.normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n";
        ShaderChunk.normal_fragment_maps = "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";
        ShaderChunk.packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;\nconst float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\n\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
        ShaderChunk.particle_affector = "vec3 lifeVelocity = computeVelocity(t);\nvec4 worldRotation;\nif(u_simulationSpace==1)\n\tworldRotation=startWorldRotation;\nelse\n\tworldRotation=u_worldRotation;\nvec3 gravity=u_gravity*age;\nvec3 center=computePosition(startVelocity, lifeVelocity, age, t,gravity,worldRotation); \n#ifdef SPHERHBILLBOARD\n\t\t  vec2 corner=corner.xy;\n\t     vec3 cameraUpVector =normalize(cameraUp);\n\t     vec3 sideVector = normalize(cross(cameraForward,cameraUpVector));\n\t     vec3 upVector = normalize(cross(sideVector,cameraForward));\n\t   \tcorner*=computeBillbardSize(startSize.xy,t);\n\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE)\n\t\t\tif(u_startRotation3D){\n\t\t\t\tvec3 rotation=vec3(startRotation.xy,computeRotation(startRotation.z,age,t));\n\t\t\t\tcenter += u_sizeScale.xzy*rotation_euler(corner.x*sideVector+corner.y*upVector,rotation);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfloat rot = computeRotation(startRotation.x, age,t);\n\t\t\t\tfloat c = cos(rot);\n\t\t\t\tfloat s = sin(rot);\n\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\n\t\t\t\tcorner=rotation*corner;\n\t\t\t\tcenter += u_sizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n\t\t\t}\n\t\t#else\n\t\t\tif(u_startRotation3D){\n\t\t\t\tcenter += u_sizeScale.xzy*rotation_euler(corner.x*sideVector+corner.y*upVector,startRotation);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfloat c = cos(startRotation.x);\n\t\t\t\tfloat s = sin(startRotation.x);\n\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\n\t\t\t\tcorner=rotation*corner;\n\t\t\t\tcenter += u_sizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n\t\t\t}\n\t\t#endif\n\t#endif\n\t#ifdef STRETCHEDBILLBOARD\n\t\tvec2 corner=corner.xy;\n\t\tvec3 velocity;\n\t\t#if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n\t   \t\tif(u_spaceType==0)\n\t  \t\t\t\tvelocity=rotation_quaternions(u_sizeScale*(startVelocity+lifeVelocity),worldRotation)+gravity;\n\t   \t\telse\n\t  \t\t\t\tvelocity=rotation_quaternions(u_sizeScale*startVelocity,worldRotation)+lifeVelocity+gravity;\n\t \t#else\n\t   \t\tvelocity= rotation_quaternions(u_sizeScale*startVelocity,worldRotation)+gravity;\n\t \t#endif\t\n\t\tvec3 cameraUpVector = normalize(velocity);\n\t\tvec3 direction = normalize(center-cameraPosition);\n\t   vec3 sideVector = normalize(cross(direction,cameraUpVector));\n\t\tsideVector=u_sizeScale.xzy*sideVector;\n\t\tcameraUpVector=length(vec3(u_sizeScale.x,0.0,0.0))*cameraUpVector;\n\t   vec2 size=computeBillbardSize(startSize.xy,t);\n\t   const mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\n\t   corner=rotaionZHalfPI*corner;\n\t   corner.y=corner.y-abs(corner.y);\n\t   float speed=length(velocity);\n\t   center +=sign(u_sizeScale.x)*(sign(u_lengthScale)*size.x*corner.x*sideVector+(speed*u_speeaScale+size.y*u_lengthScale)*corner.y*cameraUpVector);\n\t#endif\n\t#ifdef HORIZONTALBILLBOARD\n\t\tvec2 corner=corner.xy;\n\t   const vec3 cameraUpVector=vec3(0.0,0.0,1.0);\n\t   const vec3 sideVector = vec3(-1.0,0.0,0.0);\n\t\tfloat rot = computeRotation(startRotation.x, age,t);\n\t   float c = cos(rot);\n\t   float s = sin(rot);\n\t   mat2 rotation= mat2(c, -s, s, c);\n\t   corner=rotation*corner;\n\t\tcorner*=computeBillbardSize(startSize.xy,t);\n\t   center +=u_sizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n\t#endif\n\t#ifdef VERTICALBILLBOARD\n\t\tvec2 corner=corner.xy;\n\t   const vec3 cameraUpVector =vec3(0.0,1.0,0.0);\n\t   vec3 sideVector = normalize(cross(cameraForward,cameraUpVector));\n\t\tfloat rot = computeRotation(startRotation.x, age,t);\n\t   float c = cos(rot);\n\t   float s = sin(rot);\n\t   mat2 rotation= mat2(c, -s, s, c);\n\t   corner=rotation*corner;\n\t\tcorner*=computeBillbardSize(startSize.xy,t);\n\t   center +=u_sizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n\t#endif\n\t#ifdef RENDERMESH\n\t   vec3 size=computeMeshSize(startSize,t);\n\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE)\n\t\t\t\tif(u_startRotation3D){\n\t\t\t\t\tvec3 rotation=vec3(startRotation.xy,-computeRotation(startRotation.z, age,t));\n\t\t\t\t\tcenter+= rotation_quaternions(u_sizeScale*rotation_euler(position*size,rotation),worldRotation);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t#ifdef ROTATIONOVERLIFETIME\n\t\t\t\t\t\tfloat angle=computeRotation(startRotation.x, age,t);\n\t\t\t\t\t\tif(startPosition.x>0.1 || startPosition.x < -0.1||startPosition.y>0.1 || startPosition.y < -0.1){\n\t\t\t\t\t\t\tcenter+= (rotation_quaternions(rotation_axis(u_sizeScale*position*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(startPosition.xy,0.0))),angle),worldRotation));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t#ifdef SHAPE\n\t\t\t\t\t\t\t\tcenter+= u_sizeScale.xzy*(rotation_quaternions(rotation_axis(position*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\n\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tif(u_simulationSpace==1)\n\t\t\t\t\t\t\t\t\tcenter+=rotation_axis(u_sizeScale*position*size,vec3(0.0,0.0,-1.0),angle);\n\t\t\t\t\t\t\t\telse if(u_simulationSpace==0)\n\t\t\t\t\t\t\t\t\tcenter+=rotation_quaternions(u_sizeScale*rotation_axis(position*size,vec3(0.0,0.0,-1.0),angle),worldRotation);\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\t\t\t\t\t#ifdef ROTATIONSEPERATE\n\t\t\t\t\t\tvec3 angle=compute3DRotation(vec3(0.0,0.0,startRotation.z), age,t);\n\t\t\t\t\t\tcenter+= (rotation_quaternions(rotation_euler(u_sizeScale*position*size,vec3(angle.x,angle.y,angle.z)),worldRotation));\n\t\t\t\t\t#endif\t\n\t\t\t\t}\n\t\t#else\n\t\tif(u_startRotation3D){\n\t\t\tcenter+= rotation_quaternions(u_sizeScale*rotation_euler(position*size,startRotation),worldRotation);\n\t\t}\n\t\telse{\n\t\t\tif(startPosition.x>0.1 || startPosition.x < -0.1||startPosition.y>0.1 || startPosition.y < -0.1){\n\t\t\t\tif(u_simulationSpace==1)\n\t\t\t\t\tcenter+= rotation_axis(u_sizeScale*position*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(startPosition.xy,0.0))),startRotation.x);\n\t\t\t\telse if(u_simulationSpace==0)\n\t\t\t\t\tcenter+= (rotation_quaternions(u_sizeScale*rotation_axis(position*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(startPosition.xy,0.0))),startRotation.x),worldRotation));\n\t\t\t}\n\t\t\telse{\n\t\t\t\t#ifdef SHAPE\n\t\t\t\t\tif(u_simulationSpace==1)\n\t\t\t\t\t\tcenter+= u_sizeScale*rotation_axis(position*size,vec3(0.0,-1.0,0.0),startRotation.x);\n\t\t\t\t\telse if(u_simulationSpace==0)\n\t\t\t\t\t\tcenter+= rotation_quaternions(u_sizeScale*rotation_axis(position*size,vec3(0.0,-1.0,0.0),startRotation.x),worldRotation);\t\n\t\t\t\t#else\n\t\t\t\t\tif(u_simulationSpace==1)\n\t\t\t\t\t\tcenter+= rotation_axis(u_sizeScale*position*size,vec3(0.0,0.0,-1.0),startRotation.x);\n\t\t\t\t\telse if(u_simulationSpace==0)\n\t\t\t\t\t\tcenter+= rotation_quaternions(u_sizeScale*rotation_axis(position*size,vec3(0.0,0.0,-1.0),startRotation.x),worldRotation);\n\t\t\t\t#endif\n\t\t\t}\n\t\t}\n\t\t#endif\n\t\tv_mesh_color=vec4(color, 1.0);\n\t #endif";
        ShaderChunk.particle_common = "\nuniform float u_currentTime;\nuniform vec3 u_gravity;\nuniform vec3 u_worldPosition;\nuniform vec4 u_worldRotation;\nuniform bool u_startRotation3D;\nuniform int u_scalingMode;\nuniform vec3 u_positionScale;\nuniform vec3 u_sizeScale;\nuniform vec3 cameraForward;\nuniform vec3 cameraUp;\nuniform float u_lengthScale;\nuniform float u_speeaScale;\nuniform int u_simulationSpace;\n#if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n  uniform int u_spaceType;\n#endif\n#if defined(VELOCITYCONSTANT)||defined(VELOCITYTWOCONSTANT)\n  uniform vec3 u_velocityConst;\n#endif\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)\n  uniform vec2 u_velocityCurveX[4];\n  uniform vec2 u_velocityCurveY[4];\n  uniform vec2 u_velocityCurveZ[4];\n#endif\n#ifdef VELOCITYTWOCONSTANT\n  uniform vec3 u_velocityConstMax;\n#endif\n#ifdef VELOCITYTWOCURVE\n  uniform vec2 u_velocityCurveMaxX[4];\n  uniform vec2 u_velocityCurveMaxY[4];\n  uniform vec2 u_velocityCurveMaxZ[4];\n#endif\n#ifdef COLOROGRADIENT\n  uniform vec4 u_colorGradient[4];\n  uniform vec2 u_alphaGradient[4];\n#endif\n#ifdef COLORTWOGRADIENTS\n  uniform vec4 u_colorGradient[4];\n  uniform vec2 u_alphaGradient[4];\n  uniform vec4 u_colorGradientMax[4];\n  uniform vec2 u_alphaGradientMax[4];\n#endif\n#if defined(SIZECURVE)||defined(SIZETWOCURVES)\n  uniform vec2 u_sizeCurve[4];\n#endif\n#ifdef SIZETWOCURVES\n  uniform vec2 u_sizeCurveMax[4];\n#endif\n#if defined(SIZECURVESEPERATE)||defined(SIZETWOCURVESSEPERATE)\n  uniform vec2 u_sizeCurveX[4];\n  uniform vec2 u_sizeCurveY[4];\n  uniform vec2 u_sizeCurveZ[4];\n#endif\n#ifdef SIZETWOCURVESSEPERATE\n  uniform vec2 u_sizeCurveMaxX[4];\n  uniform vec2 u_sizeCurveMaxY[4];\n  uniform vec2 u_sizeCurveMaxZ[4];\n#endif\n#ifdef ROTATIONOVERLIFETIME\n  #if defined(ROTATIONCONSTANT)||defined(ROTATIONTWOCONSTANTS)\n    uniform float u_rotationConst;\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n    uniform float u_rotationConstMax;\n  #endif\n  #if defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\n    uniform vec2 u_rotationCurve[4];\n  #endif\n  #ifdef ROTATIONTWOCURVES\n    uniform vec2 u_rotationCurveMax[4];\n  #endif\n#endif\n#ifdef ROTATIONSEPERATE\n  #if defined(ROTATIONCONSTANT)||defined(ROTATIONTWOCONSTANTS)\n    uniform vec3 u_rotationConstSeprarate;\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n    uniform vec3 u_rotationConstMaxSeprarate;\n  #endif\n  #if defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\n    uniform vec2 u_rotationCurveX[4];\n    uniform vec2 u_rotationCurveY[4];\n    uniform vec2 u_rotationCurveZ[4];\n\t\tuniform vec2 u_rotationCurveW[4];\n  #endif\n  #ifdef ROTATIONTWOCURVES\n    uniform vec2 u_rotationCurveMaxX[4];\n    uniform vec2 u_rotationCurveMaxY[4];\n    uniform vec2 u_rotationCurveMaxZ[4];\n\t\tuniform vec2 u_rotationCurveMaxW[4];\n  #endif\n#endif\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONTWOCURVE)\n  uniform float u_cycles;\n  uniform vec4 u_subUV;\n  uniform vec2 u_uvCurve[4];\n#endif\n#ifdef TEXTURESHEETANIMATIONTWOCURVE\n  uniform vec2 u_uvCurveMax[4];\n#endif\nvarying float v_discard;\nvarying vec4 v_color;\nvarying vec2 v_texcoord;\n#ifdef RENDERMESH\n\tvarying vec4 v_mesh_color;\n#endif\nvec3 rotation_euler(in vec3 vector,in vec3 euler)\n{\n  float halfPitch = euler.x * 0.5;\n\tfloat halfYaw = euler.y * 0.5;\n\tfloat halfRoll = euler.z * 0.5;\n\tfloat sinPitch = sin(halfPitch);\n\tfloat cosPitch = cos(halfPitch);\n\tfloat sinYaw = sin(halfYaw);\n\tfloat cosYaw = cos(halfYaw);\n\tfloat sinRoll = sin(halfRoll);\n\tfloat cosRoll = cos(halfRoll);\n\tfloat quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\n\tfloat quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\n\tfloat quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\n\tfloat quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\n\t\n\tfloat x = quaX + quaX;\n  float y = quaY + quaY;\n  float z = quaZ + quaZ;\n  float wx = quaW * x;\n  float wy = quaW * y;\n  float wz = quaW * z;\n\tfloat xx = quaX * x;\n  float xy = quaX * y;\n\tfloat xz = quaX * z;\n  float yy = quaY * y;\n  float yz = quaY * z;\n  float zz = quaZ * z;\n  return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n              ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n              ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n\t\n}\nvec3 rotation_axis(in vec3 vector,in vec3 axis, in float angle)\n{\n\tfloat halfAngle = angle * 0.5;\n\tfloat sin = sin(halfAngle);\n\t\n\tfloat quaX = axis.x * sin;\n\tfloat quaY = axis.y * sin;\n\tfloat quaZ = axis.z * sin;\n\tfloat quaW = cos(halfAngle);\n\t\n\tfloat x = quaX + quaX;\n  float y = quaY + quaY;\n  float z = quaZ + quaZ;\n  float wx = quaW * x;\n  float wy = quaW * y;\n  float wz = quaW * z;\n\tfloat xx = quaX * x;\n  float xy = quaX * y;\n\tfloat xz = quaX * z;\n  float yy = quaY * y;\n  float yz = quaY * z;\n  float zz = quaZ * z;\n  return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n              ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n              ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n}\nvec3 rotation_quaternions(in vec3 v,in vec4 q) \n{\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)||defined(SIZECURVE)||defined(SIZECURVESEPERATE)||defined(SIZETWOCURVES)||defined(SIZETWOCURVESSEPERATE)\nfloat evaluate_curve_float(in vec2 curves[4],in float t)\n{\n\tfloat res;\n\tfor(int i=1;i<4;i++)\n\t{\n\t\tvec2 curve=curves[i];\n\t\tfloat curTime=curve.x;\n\t\tif(curTime>=t)\n\t\t{\n\t\t\tvec2 lastCurve=curves[i-1];\n\t\t\tfloat lastTime=lastCurve.x;\n\t\t\tfloat tt=(t-lastTime)/(curTime-lastTime);\n\t\t\tres=mix(lastCurve.y,curve.y,tt);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n#endif\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)||defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\nfloat evaluate_curve_total(in vec2 curves[4],in float t)\n{\n\tfloat res=0.0;\n\tfor(int i=1;i<4;i++)\n\t{\n\t\tvec2 curve=curves[i];\n\t\tfloat curTime=curve.x;\n\t\tvec2 lastCurve=curves[i-1];\n\t\tfloat lastValue=lastCurve.y;\n\t\t\n\t\tif(curTime>=t){\n\t\t\tfloat lastTime=lastCurve.x;\n\t\t\tfloat tt=(t-lastTime)/(curTime-lastTime);\n\t\t\tres+=(lastValue+mix(lastValue,curve.y,tt))/2.0*time.x*(t-lastTime);\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tres+=(lastValue+curve.y)/2.0*time.x*(curTime-lastCurve.x);\n\t\t}\n\t}\n\treturn res;\n}\n#endif\n#if defined(COLOROGRADIENT)||defined(COLORTWOGRADIENTS)\nvec4 evaluate_curve_color(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float t)\n{\n\tvec4 overTimeColor;\n\tfor(int i=1;i<4;i++)\n\t{\n\t\tvec2 gradientAlpha=gradientAlphas[i];\n\t\tfloat alphaKey=gradientAlpha.x;\n\t\tif(alphaKey>=t)\n\t\t{\n\t\t\tvec2 lastGradientAlpha=gradientAlphas[i-1];\n\t\t\tfloat lastAlphaKey=lastGradientAlpha.x;\n\t\t\tfloat age=(t-lastAlphaKey)/(alphaKey-lastAlphaKey);\n\t\t\toverTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<4;i++)\n\t{\n\t\tvec4 gradientColor=gradientColors[i];\n\t\tfloat colorKey=gradientColor.x;\n\t\tif(colorKey>=t)\n\t\t{\n\t\t\tvec4 lastGradientColor=gradientColors[i-1];\n\t\t\tfloat lastColorKey=lastGradientColor.x;\n\t\t\tfloat age=(t-lastColorKey)/(colorKey-lastColorKey);\n\t\t\toverTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn overTimeColor;\n}\n#endif\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONTWOCURVE)\nfloat evaluate_curve_frame(in vec2 gradientFrames[4],in float t)\n{\n\tfloat overTimeFrame;\n\tfor(int i=1;i<4;i++)\n\t{\n\t\tvec2 gradientFrame=gradientFrames[i];\n\t\tfloat key=gradientFrame.x;\n\t\tif(key>=t)\n\t\t{\n\t\t\tvec2 lastGradientFrame=gradientFrames[i-1];\n\t\t\tfloat lastKey=lastGradientFrame.x;\n\t\t\tfloat age=(t-lastKey)/(key-lastKey);\n\t\t\toverTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn floor(overTimeFrame);\n}\n#endif\nvec3 computeVelocity(in float t)\n{\n  vec3 res;\n  #ifdef VELOCITYCONSTANT\n\t res=u_velocityConst; \n  #endif\n  #ifdef VELOCITYCURVE\n     res= vec3(evaluate_curve_float(u_velocityCurveX,t),evaluate_curve_float(u_velocityCurveY,t),evaluate_curve_float(u_velocityCurveZ,t));\n  #endif\n  #ifdef VELOCITYTWOCONSTANT\n\t res=mix(u_velocityConst,u_velocityConstMax,vec3(random1.y,random1.z,random1.w)); \n  #endif\n  #ifdef VELOCITYTWOCURVE\n     res=vec3(mix(evaluate_curve_float(u_velocityCurveX,t),evaluate_curve_float(u_velocityCurveMaxX,t),random1.y),\n\t            mix(evaluate_curve_float(u_velocityCurveY,t),evaluate_curve_float(u_velocityCurveMaxY,t),random1.z),\n\t\t\t\t\t \t\tmix(evaluate_curve_float(u_velocityCurveZ,t),evaluate_curve_float(u_velocityCurveMaxZ,t),random1.w));\n  #endif\n\t\t\t\t\t\n  return res;\n} \nvec3 computePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float t,vec3 gravityVelocity,vec4 worldRotation)\n{\n   \tvec3 position;\n   \tvec3 lifePosition;\n\t\t#if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n\t\t\t#ifdef VELOCITYCONSTANT\n\t\t\t\t  position=startVelocity*age;\n\t\t\t\t  lifePosition=lifeVelocity*age;\n\t\t\t#endif\n\t\t\t#ifdef VELOCITYCURVE\n\t\t\t\t  position=startVelocity*age;\n\t\t\t\t  lifePosition=vec3(evaluate_curve_total(u_velocityCurveX,t),evaluate_curve_total(u_velocityCurveY,t),evaluate_curve_total(u_velocityCurveZ,t));\n\t\t\t#endif\n\t\t\t#ifdef VELOCITYTWOCONSTANT\n\t\t\t\t  position=startVelocity*age;\n\t\t\t\t  lifePosition=lifeVelocity*age;\n\t\t\t#endif\n\t\t\t#ifdef VELOCITYTWOCURVE\n\t\t\t\t  position=startVelocity*age;\n\t\t\t\t  lifePosition=vec3(mix(evaluate_curve_total(u_velocityCurveX,t),evaluate_curve_total(u_velocityCurveMaxX,t),random1.y)\n\t\t\t      \t\t\t\t\t\t\t\t,mix(evaluate_curve_total(u_velocityCurveY,t),evaluate_curve_total(u_velocityCurveMaxY,t),random1.z)\n\t\t\t      \t\t\t\t\t\t\t\t,mix(evaluate_curve_total(u_velocityCurveZ,t),evaluate_curve_total(u_velocityCurveMaxZ,t),random1.w));\n\t\t\t#endif\n\t\t\tvec3 finalPosition;\n\t\t\tif(u_spaceType==0){\n\t\t\t  if(u_scalingMode!=2)\n\t\t\t   finalPosition =rotation_quaternions(u_positionScale*(startPosition.xyz+position+lifePosition),worldRotation);\n\t\t\t  else\n\t\t\t   finalPosition =rotation_quaternions(u_positionScale*startPosition.xyz+position+lifePosition,worldRotation);\n\t\t\t}\n\t\t\telse{\n\t\t\t  if(u_scalingMode!=2)\n\t\t\t    finalPosition = rotation_quaternions(u_positionScale*(startPosition.xyz+position),worldRotation)+lifePosition;\n\t\t\t  else\n\t\t\t    finalPosition = rotation_quaternions(u_positionScale*startPosition.xyz+position,worldRotation)+lifePosition;\n\t\t\t}\n\t\t  #else\n\t\t\t position=startVelocity*age;\n\t\t\t vec3 finalPosition;\n\t\t\t if(u_scalingMode!=2)\n\t\t\t   finalPosition = rotation_quaternions(u_positionScale*(startPosition.xyz+position),worldRotation);\n\t\t\t else\n\t\t\t   finalPosition = rotation_quaternions(u_positionScale*startPosition.xyz+position,worldRotation);\n\t\t#endif\n  \n  if(u_simulationSpace==1)\n    finalPosition=finalPosition+startWorldPosition;\n  else if(u_simulationSpace==0) \n    finalPosition=finalPosition+u_worldPosition;\n  \n  finalPosition+=0.5*gravityVelocity*age;\n \n  return finalPosition;\n}\nvec4 computeColor(in vec4 color,in float t)\n{\n\t#ifdef COLOROGRADIENT\n\t  color*=evaluate_curve_color(u_alphaGradient,u_colorGradient,t);\n\t#endif\t\n\t#ifdef COLORTWOGRADIENTS\n\t  color*=mix(evaluate_curve_color(u_alphaGradient,u_colorGradient,t),evaluate_curve_color(u_alphaGradientMax,u_colorGradientMax,t),random0.y);\n\t#endif\n  return color;\n}\nvec2 computeBillbardSize(in vec2 size,in float t)\n{\n\t#ifdef SIZECURVE\n\t\tsize*=evaluate_curve_float(u_sizeCurve,t);\n\t#endif\n\t#ifdef SIZETWOCURVES\n\t  size*=mix(evaluate_curve_float(u_sizeCurve,t),evaluate_curve_float(u_sizeCurveMax,t),random0.z); \n\t#endif\n\t#ifdef SIZECURVESEPERATE\n\t\tsize*=vec2(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveY,t));\n\t#endif\n\t#ifdef SIZETWOCURVESSEPERATE\n\t  size*=vec2(mix(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveMaxX,t),random0.z)\n\t    \t\t\t\t,mix(evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveMaxY,t),random0.z));\n\t#endif\n\treturn size;\n}\n#ifdef RENDERMESH\nvec3 computeMeshSize(in vec3 size,in float t)\n{\n\t#ifdef SIZECURVE\n\t\tsize*=evaluate_curve_float(u_sizeCurve,t);\n\t#endif\n\t#ifdef SIZETWOCURVES\n\t  size*=mix(evaluate_curve_float(u_sizeCurve,t),evaluate_curve_float(u_sizeCurveMax,t),random0.z); \n\t#endif\n\t#ifdef SIZECURVESEPERATE\n\t\tsize*=vec3(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveZ,t));\n\t#endif\n\t#ifdef SIZETWOCURVESSEPERATE\n\t  size*=vec3(mix(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveMaxX,t),random0.z)\n\t  \t\t\t  \t,mix(evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveMaxY,t),random0.z)\n\t\t\t\t\t\t\t,mix(evaluate_curve_float(u_sizeCurveZ,t),evaluate_curve_float(u_sizeCurveMaxZ,t),random0.z));\n\t#endif\n\treturn size;\n}\n#endif\nfloat computeRotation(in float rotation,in float age,in float t)\n{ \n\t#ifdef ROTATIONOVERLIFETIME\n\t\t#ifdef ROTATIONCONSTANT\n\t\t\tfloat ageRot=u_rotationConst*age;\n\t        rotation+=ageRot;\n\t\t#endif\n\t\t#ifdef ROTATIONCURVE\n\t\t\trotation+=evaluate_curve_total(u_rotationCurve,t);\n\t\t#endif\n\t\t#ifdef ROTATIONTWOCONSTANTS\n\t\t\tfloat ageRot=mix(u_rotationConst,u_rotationConstMax,random0.w)*age;\n\t    rotation+=ageRot;\n\t  #endif\n\t\t#ifdef ROTATIONTWOCURVES\n\t\t\trotation+=mix(evaluate_curve_total(u_rotationCurve,t),evaluate_curve_total(u_rotationCurveMax,t),random0.w);\n\t\t#endif\n\t#endif\n\t#ifdef ROTATIONSEPERATE\n\t\t#ifdef ROTATIONCONSTANT\n\t\t\tfloat ageRot=u_rotationConstSeprarate.z*age;\n\t        rotation+=ageRot;\n\t\t#endif\n\t\t#ifdef ROTATIONCURVE\n\t\t\trotation+=evaluate_curve_total(u_rotationCurveZ,t);\n\t\t#endif\n\t\t#ifdef ROTATIONTWOCONSTANTS\n\t\t\tfloat ageRot=mix(u_rotationConstSeprarate.z,u_rotationConstMaxSeprarate.z,random0.w)*age;\n\t        rotation+=ageRot;\n\t    #endif\n\t\t#ifdef ROTATIONTWOCURVES\n\t\t\trotation+=mix(evaluate_curve_total(u_rotationCurveZ,t),evaluate_curve_total(u_rotationCurveMaxZ,t),random0.w));\n\t\t#endif\n\t#endif\n\treturn rotation;\n}\n#if defined(RENDERMESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE))\nvec3 compute3DRotation(in vec3 rotation,in float age,in float t)\n{ \n\t#ifdef ROTATIONOVERLIFETIME\n\t\t\t#ifdef ROTATIONCONSTANT\n\t\t\t\t\tfloat ageRot=u_rotationConst*age;\n\t\t\t    rotation+=ageRot;\n\t\t\t#endif\n\t\t\t#ifdef ROTATIONCURVE\n\t\t\t\t\trotation+=evaluate_curve_total(u_rotationCurve,t);\n\t\t\t#endif\n\t\t\t#ifdef ROTATIONTWOCONSTANTS\n\t\t\t\t\tfloat ageRot=mix(u_rotationConst,u_rotationConstMax,random0.w)*age;\n\t\t\t    rotation+=ageRot;\n\t\t\t#endif\n\t\t\t#ifdef ROTATIONTWOCURVES\n\t\t\t\t\trotation+=mix(evaluate_curve_total(u_rotationCurve,t),evaluate_curve_total(u_rotationCurveMax,t),random0.w);\n\t\t\t#endif\n\t#endif\n\t#ifdef ROTATIONSEPERATE\n\t\t\t\t#ifdef ROTATIONCONSTANT\n\t\t\t\t\tvec3 ageRot=u_rotationConstSeprarate*age;\n\t\t\t        rotation+=ageRot;\n\t\t\t\t#endif\n\t\t\t\t#ifdef ROTATIONCURVE\n\t\t\t\t\trotation+=vec3(evaluate_curve_total(u_rotationCurveX,t),evaluate_curve_total(u_rotationCurveY,t),evaluate_curve_total(u_rotationCurveZ,t));\n\t\t\t\t#endif\n\t\t\t\t#ifdef ROTATIONTWOCONSTANTS\n\t\t\t\t\tvec3 ageRot=mix(u_rotationConstSeprarate,u_rotationConstMaxSeprarate,random0.w)*age;\n\t\t\t        rotation+=ageRot;\n\t\t\t  #endif\n\t\t\t\t#ifdef ROTATIONTWOCURVES\n\t\t\t\t\trotation+=vec3(mix(evaluate_curve_total(u_rotationCurveX,t),evaluate_curve_total(u_rotationCurveMaxX,t),random0.w)\n\t\t\t        ,mix(evaluate_curve_total(u_rotationCurveY,t),evaluate_curve_total(u_rotationCurveMaxY,t),random0.w)\n\t\t\t        ,mix(evaluate_curve_total(u_rotationCurveZ,t),evaluate_curve_total(u_rotationCurveMaxZ,t),random0.w));\n\t\t\t\t#endif\n\t#endif\n\treturn rotation;\n}\n#endif\nvec2 computeUV(in vec2 uv,in float t)\n{ \n\t#ifdef TEXTURESHEETANIMATIONCURVE\n\t\tfloat cycleNormalizedAge=t*u_cycles;\n\t\tfloat uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n\t\tfloat frame=evaluate_curve_frame(u_uvCurve,uvNormalizedAge);\n\t\tuv.x *= u_subUV.x + u_subUV.z;\n\t\tuv.y *= u_subUV.y + u_subUV.w;\n\t\tfloat totalULength=frame*u_subUV.x;\n\t\tfloat floorTotalULength=floor(totalULength);\n\t  uv.x+=totalULength-floorTotalULength;\n\t\tuv.y+=floorTotalULength*u_subUV.y;\n    #endif\n\t#ifdef TEXTURESHEETANIMATIONTWOCURVE\n\t\tfloat cycleNormalizedAge=t*u_cycles;\n\t\tfloat uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n\t  float frame=floor(mix(evaluate_curve_frame(u_uvCurve,uvNormalizedAge),evaluate_curve_frame(u_uvCurveMax,uvNormalizedAge),random1.x));\n\t\tuv.x *= u_subUV.x + u_subUV.z;\n\t\tuv.y *= u_subUV.y + u_subUV.w;\n\t\tfloat totalULength=frame*u_subUV.x;\n\t\tfloat floorTotalULength=floor(totalULength);\n\t  uv.x+=totalULength-floorTotalULength;\n\t\tuv.y+=floorTotalULength*u_subUV.y;\n    #endif\n\treturn uv;\n}";
        ShaderChunk.premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";
        ShaderChunk.project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n";
        ShaderChunk.roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";
        ShaderChunk.roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
        ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\n\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";
        ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";
        ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";
        ShaderChunk.shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight.shadow = int(directionalLights[ i  * 11 + 6]);\n\t\tdirectionalLight.shadowBias = directionalLights[ i  * 11 + 7];\n\t\tdirectionalLight.shadowRadius = directionalLights[ i  * 11 + 8];\n\t\tdirectionalLight.shadowMapSize = vec2(directionalLights[ i  * 11 + 9], directionalLights[ i  * 11 + 10]);\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight.shadow = int(spotLights[ i  * 18 + 13]);\n\t\tspotLight.shadowBias = spotLights[ i  * 18 + 14];\n\t\tspotLight.shadowRadius = spotLights[ i  * 18 + 15];\n\t\tspotLight.shadowMapSize = vec2(spotLights[ i  * 18 + 16], spotLights[ i  * 18 + 17]);\n\t\tshadow *= bool(spotLight.shadow) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight.shadow = int(pointLights[ i  * 15 + 8]);\n\t\tpointLight.shadowBias = pointLights[ i  * 15 + 9];\n\t\tpointLight.shadowRadius = pointLights[ i  * 15 + 10];\n\t\tpointLight.shadowMapSize = vec2(pointLights[ i  * 15 + 11], pointLights[ i  * 15 + 12]);\n\t\tpointLight.shadowCameraNear = pointLights[ i  * 15 + 13];\n\t\tpointLight.shadowCameraFar = pointLights[ i  * 15 + 14];\n\t\tshadow *= bool(pointLight.shadow) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";
        ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
        ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\t\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( j + 0.5 ), 0.0 ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( j + 1.5 ), 0.0 ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( j + 2.5 ), 0.0 ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( j + 3.5 ), 0.0 ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";
        ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = skinned.xyz;\n#endif\n";
        ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\t\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";
        ShaderChunk.specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
        ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
        ShaderChunk.tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";
        ShaderChunk.tonemapping_pars_fragment = "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";
        ShaderChunk.uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
        ShaderChunk.uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\t\n\t#ifdef USE_LIGHTMAP\n\t\tuniform vec4 lightMapScaleOffset;\n\t#endif\n#endif";
        ShaderChunk.uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\t#ifdef USE_LIGHTMAP\n\t\tvUv2 = vec2(uv2.x * lightMapScaleOffset.x + lightMapScaleOffset.z, 1.0 - ((1.0 - uv2.y) * lightMapScaleOffset.y + lightMapScaleOffset.w));\n\t#else\t\n\t\tvUv2 = uv2;\n\t#endif\n#endif";
        ShaderChunk.uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";
        ShaderChunk.uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n";
        ShaderChunk.uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\t#if defined FLIP_V\n\t\tvUv = ( uvTransform * vec3( uv.x, 1.0 - uv.y, 1.0 ) ).xy;\n\t#else\n\t\tvUv = ( uvTransform * vec3( uv, 1.0 ) ).xy;\n\t#endif\n#endif";
        ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n";
    })(ShaderChunk = egret3d.ShaderChunk || (egret3d.ShaderChunk = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    // function promisify(loader: egret.HttpRequest | egret.Sound | any, resource: RES.ResourceInfo): Promise<any> {
    //     return new Promise((resolve, reject) => {
    //         let onSuccess = () => {
    //             let texture = loader['data'] ? loader['data'] : loader['response'];
    //             resolve(texture);
    //         }
    //         let onError = () => {
    //             let e = new RES.ResourceManagerError(1001, resource.url);
    //             reject(e);
    //         }
    //         loader.addEventListener(egret.Event.COMPLETE, onSuccess, this);
    //         loader.addEventListener(egret.IOErrorEvent.IO_ERROR, onError, this);
    //     });
    // }
    var _onlyImages = {};
    function _transformGLSLCode(code) {
        var transformedCode = code
            .replace(/\r/g, '\n') // \r to \n
            .replace(/[ \t]*\/\/.*\n/g, '\n') // remove //
            .replace(/[ \t]*\/\*[\s\S]*?\*\//g, '\n') // remove /* */
            .replace(/\n{2,}/g, '\n'); // \n+ to \n
        return transformedCode;
    }
    egret3d.BitmapDataProcessor = {
        onLoadStart: function (host, resource) {
            var _this = this;
            var loader = new egret.ImageLoader();
            loader.load(resource.root + resource.url);
            return new Promise(function (resolve, reject) {
                var onSuccess = function () {
                    var bitmapData = loader.data;
                    loader.removeEventListener(egret.Event.COMPLETE, onSuccess, _this);
                    loader.removeEventListener(egret.IOErrorEvent.IO_ERROR, onError, _this);
                    resolve(bitmapData);
                };
                var onError = function () {
                    loader.removeEventListener(egret.Event.COMPLETE, onSuccess, _this);
                    loader.removeEventListener(egret.IOErrorEvent.IO_ERROR, onError, _this);
                    var e = new RES.ResourceManagerError(1001, resource.url);
                    reject(e);
                };
                loader.addEventListener(egret.Event.COMPLETE, onSuccess, _this);
                loader.addEventListener(egret.IOErrorEvent.IO_ERROR, onError, _this);
            });
        },
        onRemoveStart: function (host, resource) {
            return Promise.resolve();
        }
    };
    egret3d.ShaderProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, 'json').then(function (result) {
                var subAssets = { assets: [] };
                var shaders = result.extensions.KHR_techniques_webgl.shaders;
                for (var _i = 0, shaders_1 = shaders; _i < shaders_1.length; _i++) {
                    var shader = shaders_1[_i];
                    subAssets.assets.push(shader.uri);
                }
                return loadSubAssets(subAssets, resource).then(function (texts) {
                    for (var i = 0, l = texts.length; i < l; ++i) {
                        shaders[i].uri = _transformGLSLCode(texts[i]);
                    }
                    var shader = egret3d.Shader.create(resource.name, result);
                    paper.Asset.register(shader);
                    return shader;
                });
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            if (data) {
                data.dispose();
            }
            return Promise.resolve();
        }
    };
    egret3d.ImageProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "bitmapdata").then(function (bitmapData) {
                if (_onlyImages[resource.name]) {
                    delete _onlyImages[resource.name];
                    return bitmapData.source;
                }
                var texture = egret3d.Texture
                    .create({ name: resource.name, source: bitmapData.source })
                    .setLiner(true)
                    .setRepeat(true)
                    .setMipmap(true);
                paper.Asset.register(texture);
                return texture;
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            if (data) {
                data.dispose();
            }
            return Promise.resolve();
        }
    };
    egret3d.TextureProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "json").then(function (data) {
                if ("asset" in data) {
                    var dataA_1 = data;
                    var glTFImage_1 = dataA_1.images[dataA_1.textures[0].source];
                    if (glTFImage_1.uri) {
                        var subAssets_1 = { assets: [] };
                        if (Array.isArray(glTFImage_1.uri)) {
                            for (var _i = 0, _a = glTFImage_1.uri; _i < _a.length; _i++) {
                                var uri = _a[_i];
                                _onlyImages[uri] = true;
                                subAssets_1.assets.push(uri);
                            }
                        }
                        else {
                            _onlyImages[glTFImage_1.uri] = true;
                            subAssets_1.assets.push(glTFImage_1.uri);
                        }
                        return loadSubAssets(subAssets_1, resource).then(function (images) {
                            for (var i = 0, l = subAssets_1.assets.length; i < l; ++i) {
                                var imageSource = images[i];
                                if (Array.isArray(glTFImage_1.uri)) {
                                    glTFImage_1.uri[i] = imageSource;
                                }
                                else {
                                    glTFImage_1.uri = imageSource;
                                }
                                host.save(RES.host.resourceConfig["getResource"](subAssets_1.assets[i]), imageSource);
                            }
                            var texture = egret3d.Texture.create(resource.name, dataA_1);
                            paper.Asset.register(texture);
                            return texture;
                        });
                    }
                }
                else {
                    var dataB = data;
                    var name_2 = dataB.name;
                    var filterMode = dataB.filterMode;
                    var format = dataB.format;
                    var mipmap_1 = dataB.mipmap;
                    var wrap = dataB.wrap;
                    var textureFormat_1 = 6408 /* RGBA */;
                    var exr = name_2.substring(name_2.lastIndexOf(".")); //兼容以前的
                    if (format === "RGB" || exr === ".jpg") {
                        textureFormat_1 = 6407 /* RGB */;
                    }
                    else if (format === "Gray") {
                        textureFormat_1 = 6409 /* Luminance */;
                    }
                    //Trilinear   Bilinear
                    var linear_1 = 0 /* Point */;
                    if (filterMode.indexOf("Trilinear") >= 0) {
                        linear_1 = 2 /* Trilinear */;
                    }
                    else if (filterMode.indexOf("Bilinear") >= 0) {
                        linear_1 = 1 /* Bilinear */;
                    }
                    var repeat_1 = false;
                    if (wrap.indexOf("Repeat") >= 0) {
                        repeat_1 = true;
                    }
                    var anisotropy_1 = 1;
                    if (dataB.anisotropy !== undefined) {
                        anisotropy_1 = dataB.anisotropy;
                    }
                    var premultiplyAlpha_1 = 0;
                    if (dataB.premultiply !== undefined) {
                        premultiplyAlpha_1 = dataB.premultiply > 0 ? 1 : 0;
                    }
                    // const subAssets: paper.ISerializedData = { assets: [name] };
                    // _onlyImages[name as string] = true;
                    // return loadSubAssets(subAssets, resource).then((images: gltf.ImageSource[]) => {
                    //     const texture = Texture
                    //         .create({ name: resource.name, source: images[0], format: textureFormat, premultiplyAlpha, anisotropy })
                    //         .setLiner(linear)
                    //         .setMipmap(mipmap)
                    //         .setRepeat(repeat);
                    //     paper.Asset.register(texture);
                    //     host.save((RES.host.resourceConfig as any)["getResource"](name), images[0]); // TODO
                    //     return texture;
                    // });
                    var imgResource_1 = RES.host.resourceConfig["getResource"](name_2);
                    if (imgResource_1) {
                        return host.load(imgResource_1, "bitmapdata").then(function (bitmapData) {
                            var texture = egret3d.Texture
                                .create({ name: resource.name, source: bitmapData.source, format: textureFormat_1, premultiplyAlpha: premultiplyAlpha_1, anisotropy: anisotropy_1 })
                                .setLiner(linear_1)
                                .setMipmap(mipmap_1)
                                .setRepeat(repeat_1);
                            paper.Asset.register(texture);
                            host.save(imgResource_1, bitmapData);
                            texture._bitmapData = bitmapData; // TODO
                            return texture;
                        });
                    }
                    else {
                        throw new Error(); // TODO
                    }
                }
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            if (data) {
                // host.save(imgResource, bitmapData);
                data.dispose();
            }
            return Promise.resolve();
        }
    };
    egret3d.MaterialProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "json").then(function (result) {
                var subAssets = { assets: [] };
                for (var _i = 0, _a = result.materials; _i < _a.length; _i++) {
                    var materialConfig = _a[_i];
                    subAssets.assets.push(materialConfig.extensions.KHR_techniques_webgl.technique);
                    var values = materialConfig.extensions.KHR_techniques_webgl.values;
                    if (values) {
                        for (var k in values) {
                            var value = values[k];
                            if (value && typeof value === "string") {
                                subAssets.assets.push(value);
                            }
                        }
                    }
                }
                return loadSubAssets(subAssets, resource).then(function () {
                    var material = egret3d.Material.create(resource.name, result);
                    paper.Asset.register(material);
                    return material;
                });
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            if (data) {
                data.dispose();
            }
            return Promise.resolve();
        }
    };
    egret3d.MeshProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "bin").then(function (result) {
                var parseResult = egret3d.GLTFAsset.parseFromBinary(result instanceof ArrayBuffer ? new Uint32Array(result) : result);
                var mesh = egret3d.Mesh.create(resource.name, parseResult.config, parseResult.buffers);
                paper.Asset.register(mesh);
                return mesh;
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            if (data && data.dispose) {
                data.dispose();
            }
            return Promise.resolve();
        }
    };
    egret3d.AnimationProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "bin").then(function (result) {
                var parseResult = egret3d.GLTFAsset.parseFromBinary(new Uint32Array(result));
                var animation = egret3d.AnimationAsset.create(resource.name, parseResult.config, parseResult.buffers);
                paper.Asset.register(animation);
                return animation;
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            if (data) {
                data.dispose();
            }
            return Promise.resolve();
        }
    };
    egret3d.PrefabProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "json").then(function (data) {
                return loadSubAssets(data, resource).then(function () {
                    var prefab = new paper.Prefab(data, resource.name); // TODO
                    prefab.initialize();
                    paper.Asset.register(prefab);
                    return prefab;
                });
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            if (data) {
                data.dispose();
            }
            return Promise.resolve();
        }
    };
    egret3d.SceneProcessor = {
        onLoadStart: function (host, resource) {
            return host.load(resource, "json").then(function (data) {
                return loadSubAssets(data, resource).then(function () {
                    var rawScene = new paper.RawScene(data, resource.name); // TODO
                    rawScene.initialize();
                    paper.Asset.register(rawScene);
                    return rawScene;
                });
            });
        },
        onRemoveStart: function (host, resource) {
            var data = host.get(resource);
            if (data) {
                data.dispose();
            }
            return Promise.resolve();
        }
    };
    function loadSubAssets(data, resource) {
        return Promise.all(data.assets.map((function (item) {
            var host = RES.host;
            var r = host.resourceConfig["getResource"](item);
            if (r) {
                return host.load(r).then(function (data) {
                    if (data instanceof paper.Asset) {
                        host.save(r, data);
                    }
                    return data;
                });
            }
            else {
                if (item.indexOf("builtin/") !== 0) {
                    console.error("加载不存在的资源", item);
                }
                return Promise.resolve();
            }
        })));
    }
    RES.processor.map("Shader", egret3d.ShaderProcessor);
    RES.processor.map("Texture", egret3d.ImageProcessor);
    RES.processor.map("TextureDesc", egret3d.TextureProcessor);
    RES.processor.map("Material", egret3d.MaterialProcessor);
    RES.processor.map("Mesh", egret3d.MeshProcessor);
    RES.processor.map("Animation", egret3d.AnimationProcessor);
    RES.processor.map("Prefab", egret3d.PrefabProcessor);
    RES.processor.map("Scene", egret3d.SceneProcessor);
    RES.processor.map("bitmapdata", egret3d.BitmapDataProcessor);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     * 正则表达式的工具类，提供一些引擎用到的正则表达式
     */
    var RegexpUtil = (function () {
        function RegexpUtil() {
        }
        // shader properties
        RegexpUtil.textureRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*'(.+)'[ ]*\{[ ]*([a-zA-Z]*)[ ]*([a-zA-Z]*)[ ]*\}/;
        RegexpUtil.vectorRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
        RegexpUtil.floatRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
        RegexpUtil.rangeRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
        // material
        RegexpUtil.vector4Regexp = /\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
        // 特效解析，[1,2],2,1
        RegexpUtil.vector3FloatOrRangeRegexp = /([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\])/;
        return RegexpUtil;
    }());
    egret3d.RegexpUtil = RegexpUtil;
    __reflect(RegexpUtil.prototype, "egret3d.RegexpUtil");
})(egret3d || (egret3d = {}));
// 0.04 处理utf8 string 不能用encode decode
var egret3d;
(function (egret3d) {
    var io;
    (function (io) {
        var BinReader = (function () {
            function BinReader(buf, seek) {
                if (seek === void 0) { seek = 0; }
                this._seek = seek;
                this._data = new DataView(buf, seek);
            }
            BinReader.prototype.seek = function (seek) {
                this._seek = seek;
            };
            BinReader.prototype.peek = function () {
                return this._seek;
            };
            BinReader.prototype.length = function () {
                return this._data.byteLength;
            };
            BinReader.prototype.canread = function () {
                return this._data.byteLength - this._seek;
            };
            BinReader.prototype.readStringAnsi = function () {
                var slen = this._data.getUint8(this._seek);
                this._seek++;
                var bs = "";
                for (var i = 0; i < slen; i++) {
                    bs += String.fromCharCode(this._data.getUint8(this._seek));
                    this._seek++;
                }
                return bs;
            };
            BinReader.utf8ArrayToString = function (array) {
                var ret = [];
                for (var i = 0; i < array.length; i++) {
                    var cc = array[i];
                    if (cc == 0)
                        break;
                    var ct = 0;
                    if (cc > 0xE0) {
                        ct = (cc & 0x0F) << 12;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        cc = array[++i];
                        ct |= cc & 0x3F;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0xC0) {
                        ct = (cc & 0x1F) << 6;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0x80) {
                        throw new Error("InvalidCharacterError");
                    }
                    else {
                        ret.push(String.fromCharCode(array[i]));
                    }
                }
                return ret.join('');
            };
            BinReader.prototype.readStringUtf8 = function () {
                var length = this._data.getInt8(this._seek);
                this._seek++;
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return BinReader.utf8ArrayToString(arr);
            };
            BinReader.prototype.readStringUtf8FixLength = function (length) {
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return BinReader.utf8ArrayToString(arr);
            };
            BinReader.prototype.readSingle = function () {
                var num = this._data.getFloat32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readDouble = function () {
                var num = this._data.getFloat64(this._seek, true);
                this._seek += 8;
                return num;
            };
            BinReader.prototype.readInt8 = function () {
                var num = this._data.getInt8(this._seek);
                this._seek += 1;
                return num;
            };
            BinReader.prototype.readUInt8 = function () {
                var num = this._data.getUint8(this._seek);
                this._seek += 1;
                return num;
            };
            BinReader.prototype.readInt16 = function () {
                var num = this._data.getInt16(this._seek, true);
                this._seek += 2;
                return num;
            };
            BinReader.prototype.readUInt16 = function () {
                var num = this._data.getUint16(this._seek, true);
                this._seek += 2;
                return num;
            };
            BinReader.prototype.readInt32 = function () {
                var num = this._data.getInt32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readUInt32 = function () {
                var num = this._data.getUint32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readUint8Array = function (target, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(this._seek);
                    this._seek++;
                }
                return target;
            };
            BinReader.prototype.readUint8ArrayByOffset = function (target, offset, length) {
                if (length === void 0) { length = 0; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(offset);
                    offset++;
                }
                return target;
            };
            BinReader.prototype.readUint16Array = function (target, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this.readUInt16();
                }
                return target;
            };
            BinReader.prototype.readSingleArray = function (target, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                // console.log(this._data.byteLength, this._data.byteOffset);
                for (var i = 0; i < length; i++) {
                    // target[i] = this._data.getFloat32(this._seek, true);
                    // this._seek += 4;
                    target[i] = this.readSingle();
                }
                return target;
            };
            Object.defineProperty(BinReader.prototype, "position", {
                get: function () {
                    return this.peek();
                },
                set: function (value) {
                    this.seek(value);
                },
                enumerable: true,
                configurable: true
            });
            BinReader.prototype.readBoolean = function () {
                return this.readUInt8() > 0;
            };
            BinReader.prototype.readByte = function () {
                return this.readUInt8();
            };
            BinReader.prototype.readBytes = function (target, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                return this.readUint8Array(target, offset, length);
            };
            BinReader.prototype.readUnsignedShort = function () {
                return this.readUInt16();
            };
            BinReader.prototype.readUnsignedInt = function () {
                return this.readUInt32();
            };
            BinReader.prototype.readFloat = function () {
                return this.readSingle();
            };
            BinReader.prototype.readUTFBytes = function (length) {
                var arry = new Uint8Array(length);
                return BinReader.utf8ArrayToString(this.readUint8Array(arry));
            };
            BinReader.prototype.readSymbolByte = function () {
                return this.readInt8();
            };
            BinReader.prototype.readShort = function () {
                return this.readInt16();
            };
            BinReader.prototype.readInt = function () {
                return this.readInt32();
            };
            return BinReader;
        }());
        io.BinReader = BinReader;
        __reflect(BinReader.prototype, "egret3d.io.BinReader");
        var BinWriter = (function () {
            function BinWriter() {
                var buf = new ArrayBuffer(1024);
                this._length = 0;
                this._buf = new Uint8Array(buf);
                this._data = new DataView(this._buf.buffer);
                this._seek = 0;
            }
            BinWriter.prototype.sureData = function (addlen) {
                var nextlen = this._buf.byteLength;
                while (nextlen < (this._length + addlen)) {
                    nextlen += 1024;
                }
                if (nextlen != this._buf.byteLength) {
                    var newbuf = new Uint8Array(nextlen);
                    for (var i = 0; i < this._length; i++) {
                        newbuf[i] = this._buf[i];
                    }
                    this._buf = newbuf;
                    this._data = new DataView(this._buf.buffer);
                }
                this._length += addlen;
            };
            BinWriter.prototype.getLength = function () {
                return length;
            };
            BinWriter.prototype.getBuffer = function () {
                return this._buf.buffer.slice(0, this._length);
            };
            BinWriter.prototype.seek = function (seek) {
                this._seek = seek;
            };
            BinWriter.prototype.peek = function () {
                return this._seek;
            };
            BinWriter.prototype.writeInt8 = function (num) {
                this.sureData(1);
                this._data.setInt8(this._seek, num);
                this._seek++;
            };
            BinWriter.prototype.writeUInt8 = function (num) {
                this.sureData(1);
                this._data.setUint8(this._seek, num);
                this._seek++;
            };
            BinWriter.prototype.writeInt16 = function (num) {
                this.sureData(2);
                this._data.setInt16(this._seek, num, true);
                this._seek += 2;
            };
            BinWriter.prototype.writeUInt16 = function (num) {
                this.sureData(2);
                this._data.setUint16(this._seek, num, true);
                this._seek += 2;
            };
            BinWriter.prototype.writeInt32 = function (num) {
                this.sureData(4);
                this._data.setInt32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeUInt32 = function (num) {
                this.sureData(4);
                this._data.setUint32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeSingle = function (num) {
                this.sureData(4);
                this._data.setFloat32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeDouble = function (num) {
                this.sureData(8);
                this._data.setFloat64(this._seek, num, true);
                this._seek += 8;
            };
            BinWriter.prototype.writeStringAnsi = function (str) {
                var slen = str.length;
                this.sureData(slen + 1);
                this._data.setUint8(this._seek, slen);
                this._seek++;
                for (var i = 0; i < slen; i++) {
                    this._data.setUint8(this._seek, str.charCodeAt(i));
                    this._seek++;
                }
            };
            BinWriter.prototype.writeStringUtf8 = function (str) {
                var bstr = BinWriter.stringToUtf8Array(str);
                this.writeUInt8(bstr.length);
                this.writeUint8Array(bstr);
            };
            BinWriter.stringToUtf8Array = function (str) {
                var bstr = [];
                for (var i = 0; i < str.length; i++) {
                    var c = str.charAt(i);
                    var cc = c.charCodeAt(0);
                    if (cc > 0xFFFF) {
                        throw new Error("InvalidCharacterError");
                    }
                    if (cc > 0x80) {
                        if (cc < 0x07FF) {
                            var c1 = (cc >>> 6) | 0xC0;
                            var c2 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2);
                        }
                        else {
                            var c1 = (cc >>> 12) | 0xE0;
                            var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                            var c3 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2, c3);
                        }
                    }
                    else {
                        bstr.push(cc);
                    }
                }
                return bstr;
            };
            BinWriter.prototype.writeStringUtf8DataOnly = function (str) {
                var bstr = BinWriter.stringToUtf8Array(str);
                this.writeUint8Array(bstr);
            };
            BinWriter.prototype.writeUint8Array = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = array.length;
                this.sureData(length);
                for (var i = offset; i < offset + length; i++) {
                    this._data.setUint8(this._seek, array[i]);
                    this._seek++;
                }
            };
            Object.defineProperty(BinWriter.prototype, "length", {
                get: function () {
                    return this._seek;
                },
                enumerable: true,
                configurable: true
            });
            BinWriter.prototype.writeByte = function (num) {
                this.writeUInt8(num);
            };
            BinWriter.prototype.writeBytes = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = 0; }
                this.writeUint8Array(array, offset, length);
            };
            BinWriter.prototype.writeUnsignedShort = function (num) {
                this.writeUInt16(num);
            };
            BinWriter.prototype.writeUnsignedInt = function (num) {
                this.writeUInt32(num);
            };
            BinWriter.prototype.writeFloat = function (num) {
                this.writeSingle(num);
            };
            BinWriter.prototype.writeUTFBytes = function (str) {
                var strArray = BinWriter.stringToUtf8Array(str);
                this.writeUint8Array(strArray);
            };
            BinWriter.prototype.writeSymbolByte = function (num) {
                this.writeInt8(num);
            };
            BinWriter.prototype.writeShort = function (num) {
                this.writeInt16(num);
            };
            BinWriter.prototype.writeInt = function (num) {
                this.writeInt32(num);
            };
            return BinWriter;
        }());
        io.BinWriter = BinWriter;
        __reflect(BinWriter.prototype, "egret3d.io.BinWriter");
    })(io = egret3d.io || (egret3d.io = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var utils;
    (function (utils) {
        function getRelativePath(targetPath, sourcePath) {
            var relPath = "";
            targetPath = targetPath.replace("\\", "/");
            sourcePath = sourcePath.replace("\\", "/");
            var targetPathArr = targetPath.split('/');
            var sourcePathArr = sourcePath.split('/');
            var targetPathLen = targetPathArr.length;
            var sourcePathLen = sourcePathArr.length;
            var i = 0;
            while (targetPathArr[i] == sourcePathArr[i] && i < targetPathLen && i < sourcePathLen) {
                i++;
            }
            for (var j = 0; j < sourcePathLen - i - 1; j++) {
                relPath += "../";
            }
            targetPathArr = targetPathArr.slice(i, targetPathArr.length);
            relPath = relPath + targetPathArr.join("/");
            relPath = relPath.replace(" ", "_");
            return relPath;
        }
        utils.getRelativePath = getRelativePath;
    })(utils = egret3d.utils || (egret3d.utils = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var webgl;
    (function (webgl_3) {
        // 运行时 draw call 排序优化使用。
        var _hashCode = 0;
        /**
         * @internal
         */
        var WebGLProgramBinder = (function () {
            function WebGLProgramBinder(program) {
                this.id = _hashCode++;
                this.attributes = [];
                this.globalUniforms = [];
                this.sceneUniforms = [];
                this.cameraUniforms = [];
                this.shadowUniforms = [];
                this.modelUniforms = [];
                this.uniforms = [];
                this.program = program;
            }
            WebGLProgramBinder.prototype.dispose = function () {
                var webgl = webgl_3.WebGLRenderState.webgl;
                webgl.deleteProgram(this.program);
            };
            WebGLProgramBinder.prototype.extract = function (technique) {
                var webgl = webgl_3.WebGLRenderState.webgl;
                var webglProgram = this.program;
                //
                var attributes = this.attributes;
                var totalAttributes = webgl.getProgramParameter(webglProgram, webgl.ACTIVE_ATTRIBUTES);
                for (var i = 0; i < totalAttributes; i++) {
                    var webglActiveInfo = webgl.getActiveAttrib(webglProgram, i);
                    var name_3 = webglActiveInfo.name;
                    var location_1 = webgl.getAttribLocation(webglProgram, name_3);
                    var semantic = "";
                    if (!technique.attributes[name_3]) {
                        semantic = egret3d.globalAttributeSemantics[name_3];
                        if (!semantic) {
                            console.error("未知Uniform定义：" + name_3);
                        }
                    }
                    else {
                        semantic = technique.attributes[name_3].semantic;
                    }
                    attributes.push({ name: name_3, type: webglActiveInfo.type, location: location_1, semantic: semantic });
                }
                //
                var globalUniforms = this.globalUniforms;
                var sceneUniforms = this.sceneUniforms;
                var cameraUniforms = this.cameraUniforms;
                var shadowUniforms = this.shadowUniforms;
                var modelUniforms = this.modelUniforms;
                var uniforms = this.uniforms;
                var totalUniforms = webgl.getProgramParameter(webglProgram, webgl.ACTIVE_UNIFORMS);
                for (var i = 0; i < totalUniforms; i++) {
                    var webglActiveInfo = webgl.getActiveUniform(webglProgram, i);
                    var name_4 = webglActiveInfo.name;
                    var location_2 = webgl.getUniformLocation(webglProgram, name_4);
                    var gltfUniform = technique.uniforms[name_4];
                    if (!gltfUniform) {
                        if (egret3d.globalUniformSemantics[name_4]) {
                            globalUniforms.push({ name: name_4, type: webglActiveInfo.type, size: webglActiveInfo.size, semantic: egret3d.globalUniformSemantics[name_4], location: location_2 });
                        }
                        else if (egret3d.sceneUniformSemantics[name_4]) {
                            sceneUniforms.push({ name: name_4, type: webglActiveInfo.type, size: webglActiveInfo.size, semantic: egret3d.sceneUniformSemantics[name_4], location: location_2 });
                        }
                        else if (egret3d.cameraUniformSemantics[name_4]) {
                            cameraUniforms.push({ name: name_4, type: webglActiveInfo.type, size: webglActiveInfo.size, semantic: egret3d.cameraUniformSemantics[name_4], location: location_2 });
                        }
                        else if (egret3d.shadowUniformSemantics[name_4]) {
                            shadowUniforms.push({ name: name_4, type: webglActiveInfo.type, size: webglActiveInfo.size, semantic: egret3d.shadowUniformSemantics[name_4], location: location_2 });
                        }
                        else if (egret3d.modelUniformSemantics[name_4]) {
                            modelUniforms.push({ name: name_4, type: webglActiveInfo.type, size: webglActiveInfo.size, semantic: egret3d.modelUniformSemantics[name_4], location: location_2 });
                        }
                        else {
                            //不在自定义中，也不在全局Uniform中
                            console.error("未知Uniform定义：" + name_4);
                        }
                    }
                    else {
                        uniforms.push({ name: name_4, type: webglActiveInfo.type, size: webglActiveInfo.size, semantic: gltfUniform.semantic, location: location_2 });
                        if (true) {
                            if (gltfUniform.semantic) {
                                console.log("自定义Uniform语义:" + name_4);
                            }
                        }
                    }
                    // if (!gltfUniform) {
                    //     semantic = globalUniformSemantics[name];
                    //     if (!semantic) {
                    //         //不在自定义中，也不在全局Uniform中
                    //         console.error("未知Uniform定义：" + name);
                    //     }
                    // }
                    // else {
                    //     semantic = gltfUniform.semantic;
                    // }
                    // if (semantic) {
                    //     globalUniforms.push({ name, type: webglActiveInfo.type, size: webglActiveInfo.size, semantic, location });
                    // }
                    // else {
                    //     uniforms.push({ name, type: webglActiveInfo.type, size: webglActiveInfo.size, location });
                    // }
                }
                //
                var activeUniforms = globalUniforms.concat(sceneUniforms).concat(cameraUniforms).concat(shadowUniforms).concat(modelUniforms).concat(uniforms);
                var samplerArrayNames = [];
                var samplerNames = [];
                // Sort.
                for (var _i = 0, activeUniforms_1 = activeUniforms; _i < activeUniforms_1.length; _i++) {
                    var uniform = activeUniforms_1[_i];
                    var name_5 = uniform.name;
                    if (uniform.type === 35678 /* SAMPLER_2D */ || uniform.type === 35680 /* SAMPLER_CUBE */) {
                        if (name_5.indexOf("[") > -1) {
                            samplerArrayNames.push(name_5);
                        }
                        else {
                            samplerNames.push(name_5);
                        }
                    }
                }
                //
                var textureUint = 0;
                var allNames = samplerNames.concat(samplerArrayNames);
                for (var _a = 0, activeUniforms_2 = activeUniforms; _a < activeUniforms_2.length; _a++) {
                    var uniform = activeUniforms_2[_a];
                    if (allNames.indexOf(uniform.name) < 0) {
                        continue;
                    }
                    var textureUnits = uniform.textureUnits;
                    if (!textureUnits) {
                        textureUnits = uniform.textureUnits = [];
                    }
                    textureUnits.length = uniform.size;
                    for (var i = 0; i < uniform.size; i++) {
                        textureUnits[i] = textureUint++;
                    }
                }
                return this;
            };
            return WebGLProgramBinder;
        }());
        webgl_3.WebGLProgramBinder = WebGLProgramBinder;
        __reflect(WebGLProgramBinder.prototype, "egret3d.webgl.WebGLProgramBinder");
    })(webgl = egret3d.webgl || (egret3d.webgl = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var webgl;
    (function (webgl) {
        /**
         * @internal
         */
        var WebGLShader = (function (_super) {
            __extends(WebGLShader, _super);
            function WebGLShader() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.programs = {};
                return _this;
            }
            WebGLShader.prototype.dispose = function () {
                if (!_super.prototype.dispose.call(this)) {
                    return false;
                }
                for (var k in this.programs) {
                    var program = this.programs[k];
                    if (program) {
                        program.dispose();
                    }
                    delete this.programs[k];
                }
                // this.programs;
                return true;
            };
            return WebGLShader;
        }(egret3d.Shader));
        webgl.WebGLShader = WebGLShader;
        __reflect(WebGLShader.prototype, "egret3d.webgl.WebGLShader");
        // Retargeting.
        egret3d.Shader = WebGLShader;
    })(webgl = egret3d.webgl || (egret3d.webgl = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var webgl;
    (function (webgl_4) {
        /**
         * @internal
         */
        var WebGLTexture = (function (_super) {
            __extends(WebGLTexture, _super);
            function WebGLTexture() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.webGLTexture = null;
                return _this;
            }
            WebGLTexture.prototype._uploadTexture = function (index) {
                var webgl = webgl_4.WebGLRenderState.webgl;
                var textureType;
                var uploadType;
                var image = this._image;
                var sampler = this._sampler;
                var extension = this._gltfTexture.extensions.paper;
                var format = extension.format || 6408 /* RGBA */;
                var dataType = extension.type || 5121 /* UnsignedByte */;
                // const isMutilyLayers = extension.layers !== undefined && extension.layers > 1; // TODO
                if (extension.depth !== undefined && extension.depth > 1) {
                    textureType = 32879 /* Texture3D */;
                    uploadType = textureType;
                }
                else if (extension.faces !== undefined && extension.faces > 1) {
                    textureType = 34067 /* TextureCube */;
                    uploadType = 34069 /* TextureCubeStart */;
                }
                else {
                    textureType = 3553 /* Texture2D */;
                    uploadType = textureType;
                }
                // else if (extension.height! > 1) { // TODO
                //     textureType = gltf.TextureType.Texture2D;
                //     uploadType = textureType;
                // }
                // else {
                //     textureType = gltf.TextureType.Texture1D;
                //     uploadType = textureType;
                // }
                this.type = textureType;
                if (!this.webGLTexture) {
                    this.webGLTexture = webgl.createTexture();
                }
                webgl.activeTexture(33984 /* Texture2DStart */ + index);
                webgl.bindTexture(textureType, this.webGLTexture);
                webgl.pixelStorei(3317 /* UNPACK_ALIGNMENT */, extension.unpackAlignment || 4 /* Four */);
                webgl.pixelStorei(37440 /* UNPACK_FLIP_Y_WEBGL */, extension.flipY || 0);
                webgl.pixelStorei(37441 /* UNPACK_PREMULTIPLY_ALPHA_WEBGL */, extension.premultiplyAlpha || 0);
                webgl_4.setTexturexParameters(textureType, sampler, extension.anisotropy || 1);
                if (image.uri !== undefined) {
                    if (Array.isArray(image.uri)) {
                        var index_1 = 0;
                        for (var _i = 0, _a = image.uri; _i < _a.length; _i++) {
                            var uri = _a[_i];
                            webgl.texImage2D(uploadType + (index_1++), 0, format, format, dataType, uri);
                        }
                    }
                    else {
                        webgl.texImage2D(uploadType, 0, format, format, dataType, image.uri);
                    }
                }
                else if (image.bufferView !== undefined) {
                    var width = extension.width;
                    var height = extension.height;
                    var buffers = this.buffers;
                    if (Array.isArray(image.bufferView)) {
                        var index_2 = 0;
                        for (var _b = 0, _c = image.bufferView; _b < _c.length; _b++) {
                            var bufferView = _c[_b];
                            webgl.texImage2D(uploadType + (index_2++), 0, format, width, height, 0, format, dataType, buffers[bufferView]);
                        }
                    }
                    else {
                        webgl.texImage2D(uploadType, 0, format, width, height, 0, format, dataType, buffers[image.bufferView]);
                    }
                }
                if (extension.levels === 0) {
                    webgl.generateMipmap(textureType);
                }
                if (image.uri && image.uri.hasOwnProperty("src")) {
                    image.uri.src = ""; // wx
                    delete image.uri;
                }
                return this;
            };
            WebGLTexture.prototype.dispose = function () {
                var image = this._image;
                if (image && image.uri) {
                    if (Array.isArray(image.uri)) {
                        for (var _i = 0, _a = image.uri; _i < _a.length; _i++) {
                            var uri = _a[_i];
                            if (uri.hasOwnProperty("src")) {
                                uri.src = ""; // wx
                            }
                        }
                    }
                    else {
                        if (image.uri.hasOwnProperty("src")) {
                            image.uri.src = ""; // wx
                        }
                    }
                    delete image.uri;
                }
                if (!_super.prototype.dispose.call(this)) {
                    return false;
                }
                if (this.webGLTexture) {
                    var webgl_5 = webgl_4.WebGLRenderState.webgl;
                    webgl_5.deleteTexture(this.webGLTexture);
                }
                this.webGLTexture = null;
                return true;
            };
            WebGLTexture.prototype.bindTexture = function (index) {
                if (this._sourceDirty) {
                    this._uploadTexture(index);
                    this._sourceDirty = false;
                }
                else {
                    var webgl_6 = webgl_4.WebGLRenderState.webgl;
                    webgl_6.activeTexture(33984 /* Texture2DStart */ + index);
                    webgl_6.bindTexture(this.type, this.webGLTexture);
                }
                return this;
            };
            return WebGLTexture;
        }(egret3d.Texture));
        webgl_4.WebGLTexture = WebGLTexture;
        __reflect(WebGLTexture.prototype, "egret3d.webgl.WebGLTexture");
        // Retargeting.
        egret3d.Texture = WebGLTexture;
    })(webgl = egret3d.webgl || (egret3d.webgl = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var webgl;
    (function (webgl_7) {
        /**
         * @internal
         */
        var WebGLRenderTexture = (function (_super) {
            __extends(WebGLRenderTexture, _super);
            function WebGLRenderTexture() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.webGLTexture = null;
                _this.frameBuffer = null;
                _this.renderBuffer = null;
                return _this;
            }
            WebGLRenderTexture.prototype._uploadTexture = function () {
                var webgl = webgl_7.WebGLRenderState.webgl;
                var type;
                var uploadType;
                var sampler = this._sampler;
                var extension = this._gltfTexture.extensions.paper;
                var width = extension.width;
                var height = extension.height;
                var format = extension.format || 6408 /* RGBA */;
                var dataType = extension.type || 5121 /* UnsignedByte */;
                if (extension.depth !== undefined && extension.depth > 1) {
                    type = 32879 /* Texture3D */;
                    uploadType = type;
                }
                else if (extension.faces !== undefined && extension.faces > 1) {
                    type = 34067 /* TextureCube */;
                    uploadType = 34069 /* TextureCubeStart */;
                }
                else if (extension.height > 1) {
                    type = 3553 /* Texture2D */;
                    uploadType = type;
                }
                else {
                    type = -1 /* Texture1D */;
                    uploadType = type;
                }
                this.type = type;
                if (!this.webGLTexture) {
                    this.webGLTexture = webgl.createTexture();
                }
                webgl.bindTexture(type, this.webGLTexture);
                // webgl.pixelStorei(gltf.WebGL.UNPACK_ALIGNMENT, extension.unpackAlignment || gltf.TextureAlignment.Four);
                // webgl.pixelStorei(gltf.WebGL.UNPACK_FLIP_Y_WEBGL, extension.flipY || 0);
                // webgl.pixelStorei(gltf.WebGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, extension.premultiplyAlpha || 0);
                webgl_7.setTexturexParameters(type, sampler, extension.anisotropy || 1);
                webgl.texImage2D(type, 0, format, width, height, 0, format, dataType, null);
                if (extension.layers === 0) {
                    webgl.generateMipmap(type);
                }
            };
            WebGLRenderTexture.prototype._uploadBuffer = function () {
                var webgl = webgl_7.WebGLRenderState.webgl;
                var extension = this._gltfTexture.extensions.paper;
                var width = extension.width;
                var height = extension.height;
                var depthBuffer = extension.depthBuffer || false;
                var stencilBuffer = extension.stencilBuffer || false;
                if (!this.frameBuffer) {
                    this.frameBuffer = webgl.createFramebuffer();
                }
                webgl.bindTexture(this.type, this.webGLTexture);
                webgl.bindFramebuffer(36160 /* FrameBuffer */, this.frameBuffer);
                webgl.framebufferTexture2D(36160 /* FrameBuffer */, 36064 /* COLOR_ATTACHMENT0 */, this.type, this.webGLTexture, 0);
                if (depthBuffer || stencilBuffer) {
                    if (!this.renderBuffer) {
                        this.renderBuffer = webgl.createRenderbuffer();
                    }
                    webgl.bindRenderbuffer(36161 /* RenderBuffer */, this.renderBuffer);
                    if (depthBuffer && stencilBuffer) {
                        webgl.renderbufferStorage(36161 /* RenderBuffer */, 34041 /* DEPTH_STENCIL */, width, height);
                        webgl.framebufferRenderbuffer(36160 /* FrameBuffer */, 33306 /* DEPTH_STENCIL_ATTACHMENT */, 36161 /* RenderBuffer */, this.renderBuffer);
                    }
                    else if (depthBuffer) {
                        webgl.renderbufferStorage(36161 /* RenderBuffer */, 33189 /* DEPTH_COMPONENT16 */, width, height);
                        webgl.framebufferRenderbuffer(36160 /* FrameBuffer */, 36096 /* DEPTH_ATTACHMENT */, 36161 /* RenderBuffer */, this.renderBuffer);
                    }
                    else {
                        webgl.renderbufferStorage(36161 /* RenderBuffer */, 32854 /* RGBA4 */, width, height);
                    }
                }
                // webgl.bindTexture(this.type, null);
                // webgl.bindFramebuffer(gltf.WebGL.FrameBuffer, null);
                // webgl.bindRenderbuffer(gltf.WebGL.RenderBuffer, null);
            };
            WebGLRenderTexture.prototype.dispose = function () {
                if (!_super.prototype.dispose.call(this)) {
                    return false;
                }
                var webgl = webgl_7.WebGLRenderState.webgl;
                if (this.webGLTexture) {
                    webgl.deleteTexture(this.webGLTexture);
                }
                if (this.frameBuffer) {
                    webgl.deleteFramebuffer(this.frameBuffer);
                }
                if (this.renderBuffer) {
                    webgl.deleteRenderbuffer(this.renderBuffer);
                }
                //
                this.webGLTexture = null;
                this.frameBuffer = null;
                this.renderBuffer = null;
                return true;
            };
            WebGLRenderTexture.prototype.bindTexture = function (index) {
                if (this._sourceDirty) {
                    this._uploadTexture();
                    this._sourceDirty = false;
                }
                else {
                    var webgl_8 = webgl_7.WebGLRenderState.webgl;
                    webgl_8.activeTexture(33984 /* Texture2DStart */ + index);
                    webgl_8.bindTexture(this.type, this.webGLTexture);
                }
                return this;
            };
            WebGLRenderTexture.prototype.activateTexture = function () {
                if (this._sourceDirty) {
                    this._uploadTexture();
                    this._sourceDirty = false;
                }
                if (this._bufferDirty) {
                    this._uploadBuffer();
                    this._bufferDirty = false;
                }
                else {
                    var webgl_9 = webgl_7.WebGLRenderState.webgl;
                    webgl_9.bindFramebuffer(36160 /* FrameBuffer */, this.frameBuffer);
                    if (this.renderBuffer) {
                        webgl_9.bindRenderbuffer(36161 /* RenderBuffer */, this.renderBuffer);
                    }
                }
                return this;
            };
            WebGLRenderTexture.prototype.generateMipmap = function () {
                if (this._gltfTexture.extensions.paper.levels === 0) {
                    var webgl_10 = webgl_7.WebGLRenderState.webgl;
                    webgl_10.bindTexture(this.type, this.webGLTexture);
                    webgl_10.generateMipmap(this.type);
                    // webgl.bindTexture(this.type, null);
                    return true;
                }
                return false;
            };
            return WebGLRenderTexture;
        }(egret3d.RenderTexture));
        webgl_7.WebGLRenderTexture = WebGLRenderTexture;
        __reflect(WebGLRenderTexture.prototype, "egret3d.webgl.WebGLRenderTexture");
        // Retargetting.
        egret3d.RenderTexture = WebGLRenderTexture;
    })(webgl = egret3d.webgl || (egret3d.webgl = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var webgl;
    (function (webgl_11) {
        /**
         * @internal
         */
        var WebGLMesh = (function (_super) {
            __extends(WebGLMesh, _super);
            function WebGLMesh() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.ibos = [];
                _this.vbo = null;
                return _this;
            }
            WebGLMesh.prototype.onReferenceCountChange = function (isZero) {
                if (isZero && this.vbo) {
                    if (this.config && this.config.skins) {
                        return false;
                    }
                    var webgl_12 = webgl_11.WebGLRenderState.webgl;
                    webgl_12.deleteBuffer(this.vbo);
                    for (var _i = 0, _a = this.ibos; _i < _a.length; _i++) {
                        var ibo = _a[_i];
                        ibo && webgl_12.deleteBuffer(ibo);
                    }
                    //
                    this.ibos.length = 0;
                    this.vbo = null;
                    return true;
                }
                return false;
            };
            WebGLMesh.prototype.createBuffer = function () {
                var webgl = webgl_11.WebGLRenderState.webgl;
                var vbo = webgl.createBuffer();
                var primitives = this._glTFMesh.primitives;
                if (vbo) {
                    this.vbo = vbo;
                    var attributeNames = [];
                    for (var k in primitives[0].attributes) {
                        attributeNames.push(k);
                    }
                    var subMeshIndex = 0;
                    for (var _i = 0, primitives_1 = primitives; _i < primitives_1.length; _i++) {
                        var primitive = primitives_1[_i];
                        if (primitive.indices !== undefined) {
                            var ibo = webgl.createBuffer();
                            if (ibo) {
                                this.ibos[subMeshIndex] = ibo;
                                webgl.bindBuffer(34963 /* ElementArrayBuffer */, ibo);
                                webgl.bufferData(34963 /* ElementArrayBuffer */, this.getBufferLength(this.getAccessor(primitive.indices)), this._drawMode);
                                this.uploadSubIndexBuffer(subMeshIndex);
                            }
                            else {
                                this.ibos[subMeshIndex] = null;
                                console.error("Create webgl element buffer error.");
                            }
                        }
                        subMeshIndex++;
                    }
                    // 先提交 ElementArrayBuffer，后提交 ArrayBuffer。
                    var vertexBufferViewAccessor = this.getAccessor(this._glTFMesh.primitives[0].attributes.POSITION || 0);
                    var vertexBuffer = this.createTypeArrayFromBufferView(this.getBufferView(vertexBufferViewAccessor), 5126 /* Float */);
                    webgl.bindBuffer(34962 /* ArrayBuffer */, vbo);
                    webgl.bufferData(34962 /* ArrayBuffer */, vertexBuffer.byteLength, this._drawMode);
                    this.uploadVertexBuffer(attributeNames);
                }
                else {
                    console.error("Create webgl buffer error.");
                }
            };
            /**
             * 更新该网格的顶点缓存。
             * @param uploadAttributes 要更新的顶点属性名，可以为一个属性，或属性列表，或 `null` （更新所有属性）。
             * @param offset 更新顶点的偏移。 [0: 不偏移，N: 从 N + 1 个顶点开始] （默认：0）
             * @param count 更新顶点的总数。 [0: 所有顶点，N: N 个顶点] （默认：0）
             */
            WebGLMesh.prototype.uploadVertexBuffer = function (uploadAttributes, offset, count) {
                if (uploadAttributes === void 0) { uploadAttributes = null; }
                if (offset === void 0) { offset = 0; }
                if (count === void 0) { count = 0; }
                if (!this.vbo) {
                    return;
                }
                var attributes = this._glTFMesh.primitives[0].attributes;
                var webgl = webgl_11.WebGLRenderState.webgl;
                webgl.bindBuffer(34962 /* ArrayBuffer */, this.vbo);
                if (!uploadAttributes) {
                    uploadAttributes = [];
                    for (var k in this._glTFMesh.primitives[0].attributes) {
                        uploadAttributes.push(k);
                    }
                }
                if (Array.isArray(uploadAttributes)) {
                    for (var _i = 0, uploadAttributes_1 = uploadAttributes; _i < uploadAttributes_1.length; _i++) {
                        var attributeName = uploadAttributes_1[_i];
                        var accessorIndex = attributes[attributeName];
                        if (accessorIndex !== undefined) {
                            var accessor = this.getAccessor(accessorIndex);
                            var bufferOffset = this.getBufferOffset(accessor);
                            var subVertexBuffer = this.createTypeArrayFromAccessor(accessor, offset, count);
                            if (offset > 0) {
                                bufferOffset += offset * accessor.typeCount * egret3d.GLTFAsset.getComponentTypeCount(accessor.componentType);
                            }
                            webgl.bufferSubData(34962 /* ArrayBuffer */, bufferOffset, subVertexBuffer);
                        }
                        else {
                            console.warn("Error arguments.");
                        }
                    }
                }
                else {
                    var accessorIndex = attributes[uploadAttributes];
                    if (accessorIndex !== undefined) {
                        var accessor = this.getAccessor(accessorIndex);
                        var bufferOffset = this.getBufferOffset(accessor);
                        if (offset > 0) {
                            bufferOffset += offset * accessor.typeCount * egret3d.GLTFAsset.getComponentTypeCount(accessor.componentType);
                        }
                        var subVertexBuffer = this.createTypeArrayFromAccessor(accessor);
                        webgl.bufferSubData(34962 /* ArrayBuffer */, bufferOffset, subVertexBuffer);
                    }
                    else {
                        console.warn("Error arguments.");
                    }
                }
            };
            /**
             * 更新该网格的索引缓存。
             * @param subMeshIndex
             */
            WebGLMesh.prototype.uploadSubIndexBuffer = function (subMeshIndex, offset, count) {
                if (subMeshIndex === void 0) { subMeshIndex = 0; }
                if (!this.vbo) {
                    return;
                }
                if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                    var primitive = this._glTFMesh.primitives[subMeshIndex];
                    if (primitive.indices !== undefined) {
                        var accessor = this.getAccessor(primitive.indices);
                        var subIndexBuffer = this.createTypeArrayFromAccessor(accessor, offset, count);
                        var ibo = this.ibos[subMeshIndex];
                        var webgl_13 = webgl_11.WebGLRenderState.webgl;
                        webgl_13.bindBuffer(34963 /* ElementArrayBuffer */, ibo);
                        webgl_13.bufferSubData(34963 /* ElementArrayBuffer */, 0, subIndexBuffer);
                    }
                    else {
                        console.warn("Error arguments.");
                    }
                }
                else {
                    console.warn("Error arguments.");
                }
            };
            return WebGLMesh;
        }(egret3d.Mesh));
        webgl_11.WebGLMesh = WebGLMesh;
        __reflect(WebGLMesh.prototype, "egret3d.webgl.WebGLMesh");
        // Retargeting.
        egret3d.Mesh = WebGLMesh;
    })(webgl = egret3d.webgl || (egret3d.webgl = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var webgl;
    (function (webgl) {
        /**
         * @internal
         */
        var BeginSystem = (function (_super) {
            __extends(BeginSystem, _super);
            function BeginSystem() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._canvasSizeDirty = true;
                _this._canvas = null;
                return _this;
            }
            BeginSystem.prototype._updateCanvas = function () {
                var canvas = this._canvas;
                var screenSize = egret3d.stage.screenSize;
                var viewport = egret3d.stage.viewport;
                // Update canvas size and rotate.
                var parentElement = canvas.parentElement;
                canvas.width = viewport.w;
                canvas.height = viewport.h;
                // canvas.width = viewport.w * window.devicePixelRatio;
                // canvas.height = viewport.h * window.devicePixelRatio;
                canvas.style.top = (parentElement ? parentElement.offsetTop : 0) + "px";
                canvas.style.position = "absolute";
                canvas.style[egret.web.getPrefixStyleName("transformOrigin")] = "0% 0% 0px";
                // canvas.scale(window.devicePixelRatio, window.devicePixelRatio);
                if (egret3d.stage.rotated) {
                    // canvas.style.width = h + "px";
                    // canvas.style.height = w + "px";
                    canvas.style.left = (parentElement ? parentElement.offsetLeft : 0) + screenSize.w + "px";
                    var transform = "matrix(0," + screenSize.h / canvas.width + "," + -screenSize.w / canvas.height + ",0,0,0)";
                    canvas.style[egret.web.getPrefixStyleName("transform")] = transform;
                }
                else {
                    // canvas.style.width = w + "px";
                    // canvas.style.height = h + "px";
                    // canvas.style[egret.web.getPrefixStyleName("transform")] = null;
                    canvas.style.left = (parentElement ? parentElement.offsetLeft : 0) + "px";
                    var transform = "matrix(" + screenSize.w / canvas.width + ",0,0," + screenSize.h / canvas.height + ",0,0)";
                    canvas.style[egret.web.getPrefixStyleName("transform")] = transform;
                }
            };
            BeginSystem.prototype.onAwake = function (config) {
                var _this = this;
                var globalEntity = paper.Application.sceneManager.globalEntity;
                var parentElement = config.canvas.parentElement;
                var screenWidth = parentElement ? parentElement.clientWidth : window.innerWidth;
                var screenHeight = parentElement ? parentElement.clientHeight : window.innerHeight;
                this._canvas = config.canvas;
                globalEntity.addComponent(egret3d.RenderState, config);
                globalEntity.addComponent(egret3d.Stage, {
                    size: { w: config.contentWidth, h: config.contentHeight },
                    screenSize: { w: screenWidth, h: screenHeight },
                });
                globalEntity.addComponent(egret3d.DefaultMeshes);
                globalEntity.addComponent(egret3d.DefaultShaders);
                globalEntity.addComponent(egret3d.DefaultTextures);
                globalEntity.addComponent(egret3d.DefaultMaterials);
                globalEntity.addComponent(egret3d.DrawCallCollecter);
                globalEntity.addComponent(egret3d.CameraAndLightCollecter);
                globalEntity.addComponent(egret3d.ContactCollecter);
                globalEntity.addComponent(egret3d.InputCollecter);
                // Update canvas when screen resized.
                egret3d.stage.onScreenResize.add(function () {
                    _this._canvasSizeDirty = true;
                }, this);
                egret3d.stage.onResize.add(function () {
                    _this._canvasSizeDirty = true;
                }, this);
            };
            BeginSystem.prototype.onFrame = function () {
                var screenSize = egret3d.stage.screenSize;
                var parentElement = this._canvas.parentElement;
                var screenWidth = parentElement ? parentElement.clientWidth : window.innerWidth;
                var screenHeight = parentElement ? parentElement.clientHeight : window.innerHeight;
                if (screenSize.w !== screenWidth || screenSize.h !== screenHeight) {
                    egret3d.stage.screenSize = { w: screenWidth, h: screenHeight };
                }
                if (this._canvasSizeDirty) {
                    this._updateCanvas();
                    this._canvasSizeDirty = false;
                }
            };
            return BeginSystem;
        }(paper.BaseSystem));
        webgl.BeginSystem = BeginSystem;
        __reflect(BeginSystem.prototype, "egret3d.webgl.BeginSystem");
    })(webgl = egret3d.webgl || (egret3d.webgl = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var webgl;
    (function (webgl_14) {
        var _patternInclude = /^[ \t]*#include +<([\w\d./]+)>/gm;
        var _patternLoop = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
        function _replace(match, include) {
            var flag = true;
            var chunk = "";
            if (include in egret3d.ShaderChunk) {
                chunk = egret3d.ShaderChunk[include];
            }
            else if (include in egret3d.renderState.defaultCustomShaderChunks) {
                flag = false;
                chunk = egret3d.renderState.customShaderChunks ? egret3d.renderState.customShaderChunks[include] || "" : "";
            }
            if (chunk) {
                return chunk.replace(_patternInclude, _replace);
            }
            if (flag) {
                console.error("Can not resolve #include <" + include + ">");
            }
            return "";
        }
        function _loopReplace(match, start, end, snippet) {
            var unroll = "";
            for (var i = parseInt(start); i < parseInt(end); i++) {
                unroll += snippet.replace(/ i /g, " " + i + " ");
            }
            return unroll;
        }
        function _parseIncludes(string) {
            return string.replace(_patternInclude, _replace);
        }
        function _replaceShaderNums(string) {
            var directionalLights = egret3d.cameraAndLightCollecter.directionalLights, spotLights = egret3d.cameraAndLightCollecter.spotLights, rectangleAreaLights = egret3d.cameraAndLightCollecter.rectangleAreaLights, pointLights = egret3d.cameraAndLightCollecter.pointLights, hemisphereLights = egret3d.cameraAndLightCollecter.hemisphereLights;
            return string
                .replace(new RegExp("NUM_DIR_LIGHTS" /* NUM_DIR_LIGHTS */, "g"), directionalLights.length.toString())
                .replace(new RegExp("NUM_SPOT_LIGHTS" /* NUM_SPOT_LIGHTS */, "g"), spotLights.length.toString())
                .replace(new RegExp("NUM_RECT_AREA_LIGHTS" /* NUM_RECT_AREA_LIGHTS */, "g"), rectangleAreaLights.length.toString())
                .replace(new RegExp("NUM_POINT_LIGHTS" /* NUM_POINT_LIGHTS */, "g"), pointLights.length.toString())
                .replace(new RegExp("NUM_HEMI_LIGHTS" /* NUM_HEMI_LIGHTS */, "g"), hemisphereLights.length.toString())
                .replace(new RegExp("NUM_CLIPPING_PLANES" /* NUM_CLIPPING_PLANES */, "g"), "0")
                .replace(new RegExp("UNION_CLIPPING_PLANES" /* UNION_CLIPPING_PLANES */, "g"), "0");
        }
        function _unrollLoops(string) {
            return string.replace(_patternLoop, _loopReplace);
        }
        /**
         * @internal
         */
        var WebGLRenderSystem = (function (_super) {
            __extends(WebGLRenderSystem, _super);
            function WebGLRenderSystem() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._drawCallCollecter = paper.Application.sceneManager.globalEntity.getComponent(egret3d.DrawCallCollecter);
                _this._cameraAndLightCollecter = paper.Application.sceneManager.globalEntity.getComponent(egret3d.CameraAndLightCollecter);
                _this._renderState = paper.Application.sceneManager.globalEntity.getComponent(egret3d.RenderState);
                //
                _this._modelViewMatrix = egret3d.Matrix4.create();
                _this._modelViewPojectionMatrix = egret3d.Matrix4.create();
                _this._inverseModelViewMatrix = egret3d.Matrix3.create();
                //
                _this._cacheProgram = null;
                _this._cacheScene = null;
                _this._cacheCamera = null;
                //
                _this._cacheLight = null;
                //
                _this._cacheMesh = null;
                _this._cacheSubMeshIndex = -1;
                //
                _this._cacheMaterial = null;
                _this._cacheMaterialVersion = -1;
                //
                _this._cacheLightmapIndex = -1;
                //
                _this._backupCamera = null;
                return _this;
            }
            WebGLRenderSystem.prototype._getWebGLShader = function (gltfShader, defines) {
                var webgl = webgl_14.WebGLRenderState.webgl;
                var shader = webgl.createShader(gltfShader.type);
                var shaderContent = _parseIncludes(gltfShader.uri);
                shaderContent = _replaceShaderNums(shaderContent);
                shaderContent = defines + _unrollLoops(shaderContent);
                webgl.shaderSource(shader, shaderContent);
                webgl.compileShader(shader);
                var parameter = webgl.getShaderParameter(shader, 35713 /* CompileStatus */);
                if (!parameter) {
                    console.error("Shader compile:" + gltfShader.name + " error! ->" + webgl.getShaderInfoLog(shader) + "\n" + ". did you want see the code?");
                    // if (confirm("Shader compile:" + gltfShader.name + " error! ->" + webgl.getShaderInfoLog(shader) + "\n" + ". did you want see the code?")) {
                    //     alert(gltfShader.uri);
                    // }
                    webgl.deleteShader(shader);
                    return null;
                }
                return shader;
            };
            WebGLRenderSystem.prototype._updateGlobalUniforms = function (program, camera, drawCall, renderer, currentScene, forceUpdate) {
                var webgl = webgl_14.WebGLRenderState.webgl;
                var cameraAndLightCollecter = this._cameraAndLightCollecter;
                var renderState = this._renderState;
                var globalUniforms = program.globalUniforms;
                var modelUniforms = program.modelUniforms;
                var context = camera.context;
                var matrix = drawCall.matrix;
                var i = 0;
                //
                this._modelViewMatrix.multiply(camera.worldToCameraMatrix, matrix);
                this._modelViewPojectionMatrix.multiply(camera.worldToClipMatrix, matrix);
                // Global.
                if (forceUpdate) {
                    var activeScene = paper.Application.sceneManager.activeScene;
                    var fog = activeScene.fog;
                    i = globalUniforms.length;
                    while (i--) {
                        var _a = globalUniforms[i], semantic = _a.semantic, location_3 = _a.location;
                        switch (semantic) {
                            case "_TONE_MAPPING_EXPOSURE" /* _TONE_MAPPING_EXPOSURE */:
                                webgl.uniform1f(location_3, renderState.toneMappingExposure);
                                break;
                            case "_TONE_MAPPING_WHITE_POINT" /* _TONE_MAPPING_WHITE_POINT */:
                                webgl.uniform1f(location_3, renderState.toneMappingWhitePoint);
                                break;
                            case "_AMBIENTLIGHTCOLOR" /* _AMBIENTLIGHTCOLOR */:
                                var currenAmbientColor = activeScene.ambientColor;
                                webgl.uniform3f(location_3, currenAmbientColor.r, currenAmbientColor.g, currenAmbientColor.b);
                                break;
                            case "_FOG_NEAR" /* _FOG_NEAR */:
                                webgl.uniform1f(location_3, fog.near);
                                break;
                            case "_FOG_FAR" /* _FOG_FAR */:
                                webgl.uniform1f(location_3, fog.far);
                                break;
                            case "_FOG_DENSITY" /* _FOG_DENSITY */:
                                webgl.uniform1f(location_3, fog.density);
                                break;
                            case "_FOG_COLOR" /* _FOG_COLOR */:
                                var fogColor = fog.color;
                                webgl.uniform3f(location_3, fogColor.r, fogColor.g, fogColor.b);
                                break;
                            case "_RESOLUTION" /* _RESOLUTION */:
                                webgl.uniform2f(location_3, 1.0 / egret3d.stage.viewport.w, 1.0 / egret3d.stage.viewport.h);
                                break;
                        }
                    }
                }
                // Scene.
                if (currentScene !== this._cacheScene) {
                    if (currentScene) {
                        var sceneUniforms = program.sceneUniforms;
                        i = sceneUniforms.length;
                        while (i--) {
                            var _b = sceneUniforms[i], semantic = _b.semantic, location_4 = _b.location;
                            switch (semantic) {
                                case "_LIGHTMAPINTENSITY" /* _LIGHTMAPINTENSITY */:
                                    webgl.uniform1f(location_4, currentScene.lightmapIntensity);
                                    break;
                            }
                        }
                    }
                    this._cacheScene = currentScene;
                }
                // Camera.
                if (camera !== this._cacheCamera) {
                    var cameraUniforms = program.cameraUniforms;
                    var rawData = camera.cameraToWorldMatrix.rawData;
                    i = cameraUniforms.length;
                    while (i--) {
                        var _c = cameraUniforms[i], semantic = _c.semantic, location_5 = _c.location;
                        switch (semantic) {
                            case "VIEW" /* VIEW */:
                                webgl.uniformMatrix4fv(location_5, false, camera.worldToCameraMatrix.rawData);
                                break;
                            case "PROJECTION" /* PROJECTION */:
                                webgl.uniformMatrix4fv(location_5, false, camera.projectionMatrix.rawData);
                                break;
                            case "_VIEWPROJECTION" /* _VIEWPROJECTION */:
                                webgl.uniformMatrix4fv(location_5, false, camera.worldToClipMatrix.rawData);
                                break;
                            case "_CAMERA_FORWARD" /* _CAMERA_FORWARD */:
                                webgl.uniform3f(location_5, -rawData[8], -rawData[9], -rawData[10]);
                                break;
                            case "_CAMERA_UP" /* _CAMERA_UP */:
                                webgl.uniform3f(location_5, rawData[4], rawData[5], rawData[6]);
                                break;
                            case "_CAMERA_POS" /* _CAMERA_POS */:
                                webgl.uniform3f(location_5, rawData[12], rawData[13], rawData[14]);
                                break;
                            case "_DIRECTLIGHTS" /* _DIRECTLIGHTS */:
                                if (context.directLightBuffer.byteLength > 0) {
                                    webgl.uniform1fv(location_5, context.directLightBuffer);
                                }
                                break;
                            case "_SPOTLIGHTS" /* _SPOTLIGHTS */:
                                if (context.spotLightBuffer.byteLength > 0) {
                                    webgl.uniform1fv(location_5, context.spotLightBuffer);
                                }
                                break;
                            case "_RECTAREALIGHTS" /* _RECTAREALIGHTS */:
                                if (context.pointLightBuffer.length > 0) {
                                    webgl.uniform1fv(location_5, context.rectangleAreaLightBuffer);
                                }
                                break;
                            case "_POINTLIGHTS" /* _POINTLIGHTS */:
                                if (context.pointLightBuffer.length > 0) {
                                    webgl.uniform1fv(location_5, context.pointLightBuffer);
                                }
                                break;
                            case "_HEMILIGHTS" /* _HEMILIGHTS */:
                                if (context.hemisphereLightBuffer.byteLength > 0) {
                                    webgl.uniform1fv(location_5, context.hemisphereLightBuffer);
                                }
                                break;
                            case "_LOG_DEPTH_BUFFC" /* _LOG_DEPTH_BUFFC */:
                                webgl.uniform1f(location_5, context.logDepthBufFC);
                                break;
                        }
                    }
                    this._cacheCamera = camera;
                }
                // TODO
                if (cameraAndLightCollecter.currentShadowLight && this._cacheLight !== cameraAndLightCollecter.currentShadowLight) {
                    var shadowUniforms = program.shadowUniforms;
                    var light = this._cacheLight = cameraAndLightCollecter.currentShadowLight;
                    i = shadowUniforms.length;
                    while (i--) {
                        var _d = shadowUniforms[i], semantic = _d.semantic, location_6 = _d.location;
                        switch (semantic) {
                            case "_REFERENCEPOSITION" /* _REFERENCEPOSITION */:
                                var rawData = light.transform.localToWorldMatrix.rawData;
                                webgl.uniform3f(location_6, rawData[12], rawData[13], rawData[14]);
                                break;
                            case "_NEARDICTANCE" /* _NEARDICTANCE */:
                                webgl.uniform1f(location_6, light.shadow.near);
                                break;
                            case "_FARDISTANCE" /* _FARDISTANCE */:
                                webgl.uniform1f(location_6, light.shadow.far);
                                break;
                        }
                    }
                }
                // Model.
                i = modelUniforms.length;
                while (i--) {
                    var uniform = modelUniforms[i];
                    var semantic = uniform.semantic, location_7 = uniform.location;
                    switch (semantic) {
                        case "MODEL" /* MODEL */:
                            webgl.uniformMatrix4fv(location_7, false, matrix.rawData);
                            break;
                        case "MODELVIEW" /* MODELVIEW */:
                            webgl.uniformMatrix4fv(location_7, false, this._modelViewMatrix.rawData);
                            break;
                        case "MODELVIEWPROJECTION" /* MODELVIEWPROJECTION */:
                            webgl.uniformMatrix4fv(location_7, false, this._modelViewPojectionMatrix.rawData);
                            break;
                        case "MODELVIEWINVERSE" /* MODELVIEWINVERSE */:
                            webgl.uniformMatrix3fv(location_7, false, this._inverseModelViewMatrix.getNormalMatrix(this._modelViewMatrix).rawData);
                            break;
                        case "JOINTMATRIX" /* JOINTMATRIX */:
                            var skinnedMeshRenderer = renderer.source || renderer;
                            webgl.uniformMatrix4fv(location_7, false, skinnedMeshRenderer.boneMatrices);
                            break;
                        case "_BONETEXTURE" /* _BONETEXTURE */:
                            if (uniform.textureUnits && uniform.textureUnits.length === 1) {
                                var skinnedMeshRenderer_1 = renderer.source || renderer;
                                var texture = skinnedMeshRenderer_1.boneTexture; //TODO可能有空
                                var unit = uniform.textureUnits[0];
                                webgl.uniform1i(location_7, unit);
                                texture.bindTexture(unit);
                            }
                            else {
                                console.error("Error texture unit.");
                            }
                            break;
                        case "_BONETEXTURESIZE" /* _BONETEXTURESIZE */:
                            {
                                var skinnedMeshRenderer_2 = renderer.source || renderer;
                                webgl.uniform1i(location_7, skinnedMeshRenderer_2.boneTexture.width);
                                break;
                            }
                        case "_CLOCK" /* _CLOCK */:
                            webgl.uniform4fv(location_7, renderState.caches.clockBuffer);
                            break;
                        case "_ROTATION" /* _ROTATION */:
                            webgl.uniform1f(location_7, renderer.transform.euler.z);
                            break;
                        case "_SCALE2D" /* _SCALE2D */:
                            var scale = renderer.transform.scale;
                            webgl.uniform2f(location_7, scale.x, scale.y);
                            break;
                        case "_DIRECTIONSHADOWMAT" /* _DIRECTIONSHADOWMAT */:
                            webgl.uniformMatrix4fv(location_7, false, context.directShadowMatrix);
                            break;
                        case "_SPOTSHADOWMAT" /* _SPOTSHADOWMAT */:
                            webgl.uniformMatrix4fv(location_7, false, context.spotShadowMatrix);
                            break;
                        case "_POINTSHADOWMAT" /* _POINTSHADOWMAT */:
                            webgl.uniformMatrix4fv(location_7, false, context.pointShadowMatrix);
                            break;
                        case "_DIRECTIONSHADOWMAP" /* _DIRECTIONSHADOWMAP */:
                            var directShadowLen = context.directShadowMaps.length;
                            if (directShadowLen > 0 && uniform.textureUnits) {
                                var units = uniform.textureUnits;
                                webgl.uniform1iv(location_7, units);
                                for (var i_4 = 0, l = units.length; i_4 < l; i_4++) {
                                    var directShadowMap = context.directShadowMaps[i_4] || egret3d.DefaultTextures.WHITE; //对应灯光可能不产生投影，但是阴影贴图数量是全局值，这里使用默认贴图防止报错
                                    var unit = units[i_4];
                                    var texture = directShadowMap;
                                    texture.bindTexture(unit);
                                }
                            }
                            break;
                        case "_POINTSHADOWMAP" /* _POINTSHADOWMAP */:
                            var pointShadowLen = context.pointShadowMaps.length;
                            if (pointShadowLen > 0 && uniform.textureUnits) {
                                var units = uniform.textureUnits;
                                webgl.uniform1iv(location_7, units);
                                for (var i_5 = 0, l = units.length; i_5 < l; i_5++) {
                                    var pointShadowMap = context.pointShadowMaps[i_5] || egret3d.DefaultTextures.WHITE;
                                    var unit = units[i_5];
                                    var texture = pointShadowMap;
                                    texture.bindTexture(unit);
                                }
                            }
                            break;
                        case "_SPOTSHADOWMAP" /* _SPOTSHADOWMAP */:
                            var spotShadowLen = context.spotShadowMaps.length;
                            if (spotShadowLen > 0 && uniform.textureUnits) {
                                var units = uniform.textureUnits;
                                webgl.uniform1iv(location_7, units);
                                for (var i_6 = 0, l = units.length; i_6 < l; i_6++) {
                                    var spotShadowMaps = context.spotShadowMaps[i_6] || egret3d.DefaultTextures.WHITE;
                                    var unit = units[i_6];
                                    var texture = spotShadowMaps;
                                    texture.bindTexture(unit);
                                }
                            }
                            break;
                        case "_LIGHTMAP_SCALE_OFFSET" /* _LIGHTMAP_SCALE_OFFSET */:
                            var lightmapScaleOffset = renderer.lightmapScaleOffset;
                            webgl.uniform4f(location_7, lightmapScaleOffset.x, lightmapScaleOffset.y, lightmapScaleOffset.z, lightmapScaleOffset.w);
                            break;
                        case "_LIGHTMAPTEX" /* _LIGHTMAPTEX */:
                            var lightmapIndex = renderer.lightmapIndex;
                            if (lightmapIndex >= 0 && lightmapIndex !== this._cacheLightmapIndex) {
                                if (uniform.textureUnits && uniform.textureUnits.length === 1) {
                                    var texture = currentScene.lightmaps[lightmapIndex] || egret3d.DefaultTextures.WHITE; //TODO可能有空
                                    var unit = uniform.textureUnits[0];
                                    webgl.uniform1i(location_7, unit);
                                    texture.bindTexture(unit);
                                }
                                else {
                                    console.error("Error texture unit.");
                                }
                                this._cacheLightmapIndex = lightmapIndex;
                            }
                            break;
                    }
                }
            };
            WebGLRenderSystem.prototype._updateUniforms = function (program, material) {
                var webgl = webgl_14.WebGLRenderState.webgl;
                var technique = material.technique;
                var techniqueState = technique.states || null;
                var renderState = this._renderState;
                //
                if (material._dirty) {
                    material._update();
                }
                // 
                if (technique.program !== program.id) {
                    technique.program = program.id;
                }
                // Update states.
                renderState.updateState(techniqueState);
                //
                var unifroms = technique.uniforms;
                for (var _i = 0, _a = program.uniforms; _i < _a.length; _i++) {
                    var programUniform = _a[_i];
                    var location_8 = programUniform.location;
                    var uniform = unifroms[programUniform.name];
                    var value = uniform.value;
                    switch (uniform.type) {
                        case 35670 /* BOOL */:
                        case 5124 /* INT */:
                            if (programUniform.size > 1) {
                                webgl.uniform1iv(location_8, value);
                            }
                            else {
                                webgl.uniform1i(location_8, value);
                            }
                            break;
                        case 5126 /* FLOAT */:
                            if (programUniform.size > 1) {
                                webgl.uniform1fv(location_8, value);
                            }
                            else {
                                webgl.uniform1f(location_8, value);
                            }
                            break;
                        case 35671 /* BOOL_VEC2 */:
                        case 35667 /* INT_VEC2 */:
                            webgl.uniform2iv(location_8, value);
                            break;
                        case 35672 /* BOOL_VEC3 */:
                        case 35668 /* INT_VEC3 */:
                            webgl.uniform3iv(location_8, value);
                            break;
                        case 35673 /* BOOL_VEC4 */:
                        case 35669 /* INT_VEC4 */:
                            webgl.uniform4iv(location_8, value);
                            break;
                        case 35664 /* FLOAT_VEC2 */:
                            webgl.uniform2fv(location_8, value);
                            break;
                        case 35665 /* FLOAT_VEC3 */:
                            webgl.uniform3fv(location_8, value);
                            break;
                        case 35666 /* FLOAT_VEC4 */:
                            webgl.uniform4fv(location_8, value);
                            break;
                        case 35674 /* FLOAT_MAT2 */:
                            webgl.uniformMatrix2fv(location_8, false, value);
                            break;
                        case 35675 /* FLOAT_MAT3 */:
                            webgl.uniformMatrix3fv(location_8, false, value);
                            break;
                        case 35676 /* FLOAT_MAT4 */:
                            webgl.uniformMatrix4fv(location_8, false, value);
                            break;
                        case 35678 /* SAMPLER_2D */:
                        case 35680 /* SAMPLER_CUBE */:
                            if (programUniform.textureUnits && programUniform.textureUnits.length === 1) {
                                var unit = programUniform.textureUnits[0];
                                var texture = value;
                                var isInvalide = !texture || texture.isDisposed;
                                if (programUniform.name === "envMap" /* EnvMap */) {
                                    if (isInvalide) {
                                        texture = renderState.caches.skyBoxTexture || egret3d.DefaultTextures.WHITE; // TODO
                                    }
                                    material.setFloat("flipEnvMap" /* FlipEnvMap */, texture.type === 34067 /* TextureCube */ ? 1.0 : -1.0);
                                    material.setFloat("maxMipLevel" /* MaxMipLevel */, texture.levels);
                                }
                                else if (isInvalide) {
                                    texture = egret3d.DefaultTextures.WHITE; // TODO
                                }
                                webgl.uniform1i(location_8, unit);
                                texture.bindTexture(unit);
                            }
                            else {
                                console.error("Error texture unit");
                            }
                            break;
                    }
                }
            };
            WebGLRenderSystem.prototype._updateAttributes = function (program, mesh, subMeshIndex) {
                var webgl = webgl_14.WebGLRenderState.webgl;
                var renderState = this._renderState;
                var attributes = mesh.glTFMesh.primitives[subMeshIndex].attributes;
                var attributeCount = 0;
                //
                if (mesh.vbo) {
                    webgl.bindBuffer(34962 /* ArrayBuffer */, mesh.vbo);
                }
                else {
                    mesh.createBuffer();
                }
                // vbo.
                for (var _i = 0, _a = program.attributes; _i < _a.length; _i++) {
                    var attribute = _a[_i];
                    var location_9 = attribute.location;
                    var accessorIndex = attributes[attribute.semantic];
                    if (accessorIndex !== undefined) {
                        var accessor = mesh.getAccessor(accessorIndex);
                        webgl.vertexAttribPointer(location_9, accessor.typeCount, accessor.componentType, accessor.normalized !== undefined ? accessor.normalized : false, 0, mesh.getBufferOffset(accessor)); // TODO normalized应该来源于mesh，应该还没有
                        webgl.enableVertexAttribArray(location_9);
                    }
                    else {
                        webgl.disableVertexAttribArray(location_9);
                    }
                    attributeCount++;
                }
                //
                if (attributeCount !== renderState.caches.attributeCount) {
                    for (var i = attributeCount, l = renderState.caches.attributeCount; i < l; ++i) {
                        webgl.disableVertexAttribArray(i);
                    }
                    renderState.caches.attributeCount = attributeCount;
                }
                // ibo.
                var ibo = mesh.ibos[subMeshIndex];
                if (ibo) {
                    webgl.bindBuffer(34963 /* ElementArrayBuffer */, ibo);
                }
            };
            WebGLRenderSystem.prototype._render = function (camera, renderTarget, material) {
                var renderState = this._renderState;
                renderState.updateRenderTarget(renderTarget);
                renderState.updateViewport(camera.viewport, renderTarget);
                renderState.clearBuffer(camera.bufferMask, camera.backgroundColor);
                // Skybox.
                var skyBox = camera.entity.getComponent(egret3d.SkyBox);
                if (skyBox && skyBox.material && skyBox.isActiveAndEnabled) {
                    var skyBoxDrawCall = this._drawCallCollecter.skyBox;
                    var material_1 = skyBox.material;
                    var texture = (material_1.shader === egret3d.DefaultShaders.CUBE) ? material_1.getTexture("tCube" /* CubeMap */) :
                        ((material_1.shader === egret3d.DefaultShaders.EQUIRECT) ? material_1.getTexture("tEquirect" /* EquirectMap */) : material_1.getTexture());
                    if (renderState.caches.skyBoxTexture !== texture) {
                        renderState._updateTextureDefines("envMap" /* EnvMap */, texture);
                        renderState.caches.skyBoxTexture = texture;
                    }
                    if (!skyBoxDrawCall.mesh) {
                        // DefaultMeshes.SPHERE;
                        skyBoxDrawCall.mesh = egret3d.DefaultMeshes.CUBE;
                    }
                    skyBoxDrawCall.matrix = camera.gameObject.transform.localToWorldMatrix;
                    this.draw(skyBoxDrawCall, material_1);
                }
                else if (renderState.caches.skyBoxTexture) {
                    renderState._updateTextureDefines("envMap" /* EnvMap */, null);
                    renderState.caches.skyBoxTexture = null;
                }
                // Draw opaques.
                for (var _i = 0, _a = camera.context.opaqueCalls; _i < _a.length; _i++) {
                    var drawCall = _a[_i];
                    this.draw(drawCall, material);
                }
                // Draw transparents.
                for (var _b = 0, _c = camera.context.transparentCalls; _b < _c.length; _b++) {
                    var drawCall = _c[_b];
                    this.draw(drawCall, material);
                }
                //
                if (renderState.renderTarget && renderState.renderTarget.generateMipmap()) {
                    renderState.clearState(); // Fixed there is no texture bound to the unit 0 error.
                }
                // Egret 2D.
                var webgl = webgl_14.WebGLRenderState.webgl;
                webgl.pixelStorei(webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1); // TODO 解决字体模糊。
                for (var _d = 0, _e = this.groups[0].entities; _d < _e.length; _d++) {
                    var entity = _e[_d];
                    var egret2DRenderer = entity.getComponent(egret3d.Egret2DRenderer);
                    if (camera.cullingMask & egret2DRenderer.gameObject.layer) {
                        if (egret2DRenderer._order < 0) {
                            egret2DRenderer._order = renderState.caches.egret2DOrderCount++;
                        }
                        egret2DRenderer._draw();
                        renderState.clearState();
                        this._cacheProgram = null; //防止2d的program污染3d的
                    }
                }
            };
            WebGLRenderSystem.prototype._renderShadow = function (light) {
                var collecter = this._cameraAndLightCollecter;
                if (collecter.currentShadowLight !== light) {
                    collecter.currentShadowLight = light;
                    var webgl_15 = webgl_14.WebGLRenderState.webgl;
                    var renderState_1 = this._renderState;
                    var shadow = light.shadow;
                    var shadowMapSize = shadow.mapSize;
                    var camera = egret3d.cameraAndLightCollecter.currentCamera = egret3d.cameraAndLightCollecter.shadowCamera;
                    var drawCalls = camera.context.shadowCalls;
                    var viewport = camera.viewport;
                    var isPoint = light.constructor === egret3d.PointLight;
                    //generate depth map
                    var shadowMaterial = (isPoint) ? egret3d.DefaultMaterials.SHADOW_DISTANCE : egret3d.DefaultMaterials.SHADOW_DEPTH_3201;
                    renderState_1.updateRenderTarget(shadow._renderTarget);
                    renderState_1.clearBuffer(16640 /* DepthAndColor */, egret3d.Color.WHITE);
                    for (var i = 0, l = (isPoint ? 6 : 1); i < l; i++) {
                        //update shadowMatrix
                        shadow._onUpdate(i);
                        //update draw call
                        camera._update();
                        webgl_15.viewport(viewport.x * shadowMapSize, viewport.y * shadowMapSize, viewport.w * shadowMapSize, viewport.h * shadowMapSize);
                        for (var _i = 0, drawCalls_1 = drawCalls; _i < drawCalls_1.length; _i++) {
                            var drawCall = drawCalls_1[_i];
                            this.draw(drawCall, shadowMaterial);
                        }
                        //防止点光源camera因为缓存没有更新 TODO
                        this._cacheCamera = null;
                    }
                }
                collecter.currentCamera = null;
                collecter.currentShadowLight = null;
            };
            WebGLRenderSystem.prototype.getMatchers = function () {
                return [
                    paper.Matcher.create(egret3d.Egret2DRenderer),
                ];
            };
            WebGLRenderSystem.prototype.onAwake = function () {
                var renderState = this._renderState;
                renderState.render = this.render.bind(this);
                renderState.draw = this.draw.bind(this);
            };
            WebGLRenderSystem.prototype.onFrame = function () {
                if (!webgl_14.WebGLRenderState.webgl) {
                    return;
                }
                var cameras = this._cameraAndLightCollecter.cameras;
                if (cameras.length > 0) {
                    var isPlayerMode = paper.Application.playerMode === 1 /* Player */;
                    var clock = paper.clock;
                    var renderState_2 = this._renderState;
                    var editorScene = paper.Application.sceneManager.editorScene;
                    renderState_2.caches.egret2DOrderCount = 0;
                    renderState_2.caches.cullingMask = 0 /* Nothing */;
                    renderState_2.caches.clockBuffer[0] = clock.time; // TODO more clock info.
                    // Render lights shadows. TODO 
                    // if (camera.cullingMask !== renderState.caches.cullingMask) {
                    var lights = this._cameraAndLightCollecter.lights;
                    if (lights.length > 0) {
                        for (var _i = 0, lights_6 = lights; _i < lights_6.length; _i++) {
                            var light = lights_6[_i];
                            if (light.castShadows && light.shadow._onUpdate) {
                                this._renderShadow(light);
                            }
                        }
                    }
                    //     renderState.caches.cullingMask = camera.cullingMask;
                    // }
                    for (var _a = 0, cameras_1 = cameras; _a < cameras_1.length; _a++) {
                        var camera = cameras_1[_a];
                        var scene = camera.entity.scene;
                        if (camera.renderTarget
                            || camera._previewRenderTarget
                            || (isPlayerMode ? scene !== editorScene : scene === editorScene)) {
                            this.render(camera);
                        }
                    }
                    this._cacheProgram = null; //TODO
                }
                else {
                    this._renderState.clearBuffer(16640 /* DepthAndColor */, egret3d.Color.BLACK);
                }
            };
            WebGLRenderSystem.prototype.onFrameCleanup = function () {
                this._drawCallCollecter.drawCallCount = 0;
            };
            WebGLRenderSystem.prototype.render = function (camera, material) {
                if (material === void 0) { material = null; }
                var cameraAndLightCollecter = this._cameraAndLightCollecter;
                var renderTarget = camera.renderTarget || camera._previewRenderTarget;
                if (cameraAndLightCollecter.currentCamera !== camera) {
                    cameraAndLightCollecter.currentCamera = camera;
                    camera._update();
                    //TODO
                    if (camera.gameObject._beforeRenderBehaviorCount > 0) {
                        var flag = false;
                        var isEditor = paper.Application.playerMode === 4 /* Editor */;
                        for (var _i = 0, _a = camera.entity.components; _i < _a.length; _i++) {
                            var component = _a[_i];
                            if (component.isActiveAndEnabled &&
                                component.constructor.isBehaviour &&
                                (!isEditor || component.constructor.executeInEditMode) &&
                                component.onBeforeRender) {
                                flag = !component.onBeforeRender() || flag;
                            }
                        }
                        if (flag) {
                            return;
                        }
                    }
                    //
                    var isPostprocessing = false;
                    var postprocessings = camera.entity.getComponents(egret3d.CameraPostprocessing, true);
                    if (postprocessings.length > 0) {
                        for (var _b = 0, postprocessings_1 = postprocessings; _b < postprocessings_1.length; _b++) {
                            var postprocessing = postprocessings_1[_b];
                            if (postprocessing.isActiveAndEnabled) {
                                isPostprocessing = true;
                                break;
                            }
                        }
                    }
                    if (!isPostprocessing) {
                        this._backupCamera = null;
                        this._render(camera, renderTarget, material);
                    }
                    else {
                        this._render(camera, camera.postprocessingRenderTarget, material);
                        for (var _c = 0, postprocessings_2 = postprocessings; _c < postprocessings_2.length; _c++) {
                            var postprocessing = postprocessings_2[_c];
                            if (postprocessing.isActiveAndEnabled) {
                                this._backupCamera = camera;
                                postprocessing.onRender(camera);
                                this._backupCamera = null;
                            }
                        }
                        camera.swapPostprocessingRenderTarget();
                    }
                }
                else {
                    this._render(camera, renderTarget, material);
                }
                //
                cameraAndLightCollecter.currentCamera = this._backupCamera;
            };
            WebGLRenderSystem.prototype.draw = function (drawCall, material) {
                if (material === void 0) { material = null; }
                var renderer = drawCall.renderer;
                material = material || drawCall.material;
                if (renderer && renderer.gameObject._beforeRenderBehaviorCount > 0) {
                    var flag = false;
                    var isEditor = paper.Application.playerMode === 4 /* Editor */;
                    for (var _i = 0, _a = renderer.entity.components; _i < _a.length; _i++) {
                        var component = _a[_i];
                        if (component.constructor.isBehaviour &&
                            (!isEditor || component.constructor.executeInEditMode) &&
                            component.onBeforeRender) {
                            flag = !component.onBeforeRender() || flag;
                        }
                    }
                    if (flag) {
                        return;
                    }
                }
                var webgl = webgl_14.WebGLRenderState.webgl;
                var renderState = this._renderState;
                var camera = egret3d.cameraAndLightCollecter.currentCamera;
                var activeScene = paper.Application.sceneManager.activeScene;
                var currentScene = renderer ? renderer.gameObject.scene : null; // 后期渲染 renderer 为空。
                var mesh = drawCall.mesh;
                var shader = material.shader;
                var programs = shader.programs;
                renderState._updateDrawDefines(renderer);
                var programKey = renderState.defines.definesMask
                    + material.defines.definesMask
                    + (currentScene || activeScene).defines.definesMask;
                var program = null;
                if (true) {
                    var flag = false;
                    if (mesh.isDisposed) {
                        console.error("The mesh has been disposed.", renderer ? renderer.gameObject.path : mesh.name);
                        flag = true;
                    }
                    if (shader.isDisposed) {
                        console.error("The shader has been disposed.", renderer ? renderer.gameObject.path : shader.name);
                        flag = true;
                    }
                    if (material.isDisposed) {
                        console.error("The material has been disposed.", renderer ? renderer.gameObject.path : material.name);
                        flag = true;
                    }
                    if (flag) {
                        return;
                    }
                }
                if (programKey in programs) {
                    program = programs[programKey];
                }
                else {
                    var extensions = shader.config.extensions.KHR_techniques_webgl;
                    var defines = [
                        renderState.defines,
                        (currentScene || activeScene).defines,
                        material.defines,
                    ];
                    renderState.customShaderChunks = shader.customs;
                    //
                    var vertexWebGLShader = this._getWebGLShader(extensions.shaders[0], renderState.getPrefixVertex(egret3d.Defines.link(defines, 1 /* Vertex */))); // TODO 顺序依赖
                    var fragmentWebGLShader = this._getWebGLShader(extensions.shaders[1], renderState.getPrefixFragment(egret3d.Defines.link(defines, 2 /* Fragment */))); // TODO 顺序依赖
                    if (vertexWebGLShader && fragmentWebGLShader) {
                        var webGLProgram = webgl.createProgram();
                        webgl.attachShader(webGLProgram, vertexWebGLShader);
                        webgl.attachShader(webGLProgram, fragmentWebGLShader);
                        // TODO bindAttribLocation
                        webgl.linkProgram(webGLProgram);
                        var programLog = webgl.getProgramInfoLog(webGLProgram).trim();
                        var vertexLog = webgl.getShaderInfoLog(vertexWebGLShader).trim();
                        var fragmentLog = webgl.getShaderInfoLog(fragmentWebGLShader).trim();
                        var parameter = webgl.getProgramParameter(webGLProgram, 35714 /* LinkStatus */);
                        if (parameter) {
                            program = new webgl_14.WebGLProgramBinder(webGLProgram).extract(material.technique);
                            // if (programLog) {
                            //     console.warn("getProgramInfoLog:", shader.name, programLog, vertexLog, fragmentLog);
                            // }
                        }
                        else {
                            console.error("getProgramInfoLog:", shader.name, programLog, vertexLog, fragmentLog);
                            webgl.deleteProgram(webGLProgram);
                        }
                        webgl.deleteShader(vertexWebGLShader);
                        webgl.deleteShader(fragmentWebGLShader);
                    }
                    programs[programKey] = program;
                }
                //
                if (program) {
                    var forceUpdate = false;
                    if (program !== this._cacheProgram) {
                        webgl.useProgram(program.program);
                        this._cacheProgram = program;
                        this._cacheScene = null;
                        this._cacheCamera = null;
                        this._cacheLight = null;
                        this._cacheMesh = null;
                        this._cacheMaterial = null;
                        this._cacheMaterialVersion = -1;
                        this._cacheLightmapIndex = -1;
                        forceUpdate = true;
                    }
                    //
                    var subMeshIndex = drawCall.subMeshIndex;
                    var primitive = mesh.glTFMesh.primitives[subMeshIndex];
                    var drawMode = primitive.mode === undefined ? 4 /* Triangles */ : primitive.mode;
                    var vertexAccessor = mesh.getAccessor(primitive.attributes.POSITION || 0); //
                    var bufferOffset = mesh.getBufferOffset(vertexAccessor);
                    // Update global uniforms.
                    this._updateGlobalUniforms(program, camera, drawCall, renderer, currentScene, forceUpdate);
                    // Update attributes.
                    if (this._cacheMesh !== mesh || this._cacheSubMeshIndex !== subMeshIndex) {
                        this._updateAttributes(program, mesh, subMeshIndex);
                        this._cacheSubMeshIndex = subMeshIndex;
                        this._cacheMesh = mesh;
                    }
                    // Update uniforms.
                    if (this._cacheMaterial !== material || this._cacheMaterialVersion !== material._version) {
                        this._updateUniforms(program, material);
                        this._cacheMaterialVersion = material._version;
                        this._cacheMaterial = material;
                    }
                    //  TODO
                    // if (techniqueState && renderer.transform._worldMatrixDeterminant < 0) {
                    //     if (techniqueState.functions!.frontFace[0] === CCW) {
                    //         webgl.frontFace(CW);
                    //     }
                    //     else {
                    //         webgl.frontFace(CCW);
                    //     }
                    // }
                    // Draw.
                    if (primitive.indices !== undefined) {
                        var indexAccessor = mesh.getAccessor(primitive.indices);
                        webgl.drawElements(drawMode, drawCall.count || indexAccessor.count, indexAccessor.componentType, 0); //TODO 暂时不支持交错
                    }
                    else {
                        webgl.drawArrays(drawMode, 0, vertexAccessor.count);
                    }
                    this._drawCallCollecter.drawCallCount++;
                    if (drawCall.drawCount >= 0) {
                        drawCall.drawCount++;
                    }
                }
            };
            return WebGLRenderSystem;
        }(paper.BaseSystem));
        webgl_14.WebGLRenderSystem = WebGLRenderSystem;
        __reflect(WebGLRenderSystem.prototype, "egret3d.webgl.WebGLRenderSystem", ["egret3d.IRenderSystem"]);
    })(webgl = egret3d.webgl || (egret3d.webgl = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var webgl;
    (function (webgl) {
        /**
         * @internal
         */
        var InputSystem = (function (_super) {
            __extends(InputSystem, _super);
            function InputSystem() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._hasTouch = false;
                _this._canvas = null;
                _this._onPointerEvent = function (event) {
                    if (!egret3d.inputCollecter.isActiveAndEnabled) {
                        return;
                    }
                    var rotated = egret3d.stage.rotated;
                    var canvas = _this._canvas;
                    var downPointers = egret3d.inputCollecter._downPointers;
                    var holdPointers = egret3d.inputCollecter._holdPointers;
                    var pointer = egret3d.inputCollecter.getPointer(event.pointerId);
                    var prevEvent = pointer.event;
                    pointer.event = event;
                    pointer.position.set(event.clientX - (canvas.offsetLeft || 0.0), event.clientY - (canvas.offsetTop || 0.0), 0.0);
                    if (rotated) {
                        pointer.position.x += egret3d.stage.screenSize.w;
                    }
                    egret3d.stage.screenToStage(pointer.position, pointer.position);
                    switch (event.type) {
                        case "pointerover":
                            if (holdPointers.length > 0 && event.buttons === 0 /* None */) {
                                _this._pointerUp(pointer, true);
                            }
                            egret3d.inputCollecter.onPointerOver.dispatch(pointer, egret3d.inputCollecter.onPointerOver);
                            event.preventDefault();
                            break;
                        case "pointerenter":
                            egret3d.inputCollecter.onPointerEnter.dispatch(pointer, egret3d.inputCollecter.onPointerEnter);
                            event.preventDefault();
                            break;
                        case "pointerdown":
                            if (downPointers.indexOf(pointer) < 0 && holdPointers.indexOf(pointer) < 0) {
                                pointer.downPosition.copy(pointer.position);
                                downPointers.push(pointer);
                                holdPointers.push(pointer);
                                egret3d.inputCollecter.onPointerDown.dispatch(pointer, egret3d.inputCollecter.onPointerDown);
                                event.preventDefault();
                            }
                            break;
                        case "pointermove":
                            if (event.target === canvas || holdPointers.length > 0) {
                                egret3d.inputCollecter.onPointerMove.dispatch(pointer, egret3d.inputCollecter.onPointerMove);
                                event.preventDefault();
                            }
                            else {
                                pointer.event = prevEvent;
                            }
                            break;
                        case "pointerup":
                            if (!_this._pointerUp(pointer, false)) {
                                pointer.event = prevEvent;
                                event.preventDefault();
                            }
                            break;
                        case "pointercancel":
                            if (!_this._pointerUp(pointer, true)) {
                                pointer.event = prevEvent;
                                event.preventDefault();
                            }
                            break;
                        case "pointerout":
                            egret3d.inputCollecter.onPointerOut.dispatch(pointer, egret3d.inputCollecter.onPointerOut);
                            event.preventDefault();
                            break;
                        case "pointerleave":
                            egret3d.inputCollecter.onPointerLeave.dispatch(pointer, egret3d.inputCollecter.onPointerLeave);
                            event.preventDefault();
                            break;
                    }
                };
                _this._onMouseWheelEvent = function (event) {
                    if (!egret3d.inputCollecter.isActiveAndEnabled) {
                        return;
                    }
                    if (event.detail) {
                        egret3d.inputCollecter.mouseWheel = -1 * event.detail;
                    }
                    else if (event.wheelDelta) {
                        egret3d.inputCollecter.mouseWheel = event.wheelDelta / 120;
                    }
                    else {
                        egret3d.inputCollecter.mouseWheel = 0;
                    }
                    egret3d.inputCollecter.onMouseWheel.dispatch(_this);
                    event.preventDefault();
                };
                _this._onMouseEvent = function (event) {
                    if (!egret3d.inputCollecter.isActiveAndEnabled) {
                        return;
                    }
                    event.isPrimary = true;
                    event.pointerId = 1;
                    event.pressure = 0;
                    event.tangentialPressure = 0;
                    event.twist = 0;
                    event.width = 1;
                    event.height = 1;
                    event.tiltX = 0;
                    event.tiltY = 0;
                    event.pointerType = "mouse";
                    var rotated = egret3d.stage.rotated;
                    var pointerEvent = event;
                    var canvas = _this._canvas;
                    var downPointers = egret3d.inputCollecter._downPointers;
                    var holdPointers = egret3d.inputCollecter._holdPointers;
                    var pointer = egret3d.inputCollecter.getPointer(pointerEvent.pointerId);
                    var prevEvent = pointer.event;
                    pointer.event = pointerEvent;
                    pointer.position.set(event.clientX - (canvas.offsetLeft || 0.0), event.clientY - (canvas.offsetTop || 0.0), 0.0);
                    if (rotated) {
                        pointer.position.x += egret3d.stage.screenSize.w;
                    }
                    egret3d.stage.screenToStage(pointer.position, pointer.position);
                    switch (event.type) {
                        case "mouseover":
                            if (holdPointers.length > 0 && event.buttons === 0 /* None */) {
                                event.type = "pointerup";
                                _this._pointerUp(pointer, true);
                            }
                            event.type = "pointerover";
                            egret3d.inputCollecter.onPointerOver.dispatch(pointer, egret3d.inputCollecter.onPointerOver);
                            event.preventDefault();
                            break;
                        case "mouseenter":
                            event.type = "pointerenter";
                            egret3d.inputCollecter.onPointerEnter.dispatch(pointer, egret3d.inputCollecter.onPointerEnter);
                            event.preventDefault();
                            break;
                        case "mousedown":
                            if (downPointers.indexOf(pointer) < 0 && holdPointers.indexOf(pointer) < 0) {
                                pointer.downPosition.copy(pointer.position);
                                downPointers.push(pointer);
                                holdPointers.push(pointer);
                                event.type = "pointerdown";
                                egret3d.inputCollecter.onPointerDown.dispatch(pointer, egret3d.inputCollecter.onPointerDown);
                                event.preventDefault();
                            }
                            break;
                        case "mousemove":
                            if (event.target === canvas || holdPointers.length > 0) {
                                event.type = "pointermove";
                                egret3d.inputCollecter.onPointerMove.dispatch(pointer, egret3d.inputCollecter.onPointerMove);
                                event.preventDefault();
                            }
                            else {
                                pointer.event = prevEvent;
                            }
                            break;
                        case "mouseup":
                            event.type = "pointerup";
                            if (!_this._pointerUp(pointer, false)) {
                                pointer.event = prevEvent;
                                event.preventDefault();
                            }
                            break;
                        case "mousecancel":
                            event.type = "pointercancel";
                            if (!_this._pointerUp(pointer, true)) {
                                pointer.event = prevEvent;
                                event.preventDefault();
                            }
                            break;
                        case "mouseout":
                            event.type = "pointerout";
                            egret3d.inputCollecter.onPointerOut.dispatch(pointer, egret3d.inputCollecter.onPointerOut);
                            event.preventDefault();
                            break;
                        case "mouseleave":
                            event.type = "pointerleave";
                            egret3d.inputCollecter.onPointerLeave.dispatch(pointer, egret3d.inputCollecter.onPointerLeave);
                            event.preventDefault();
                            break;
                    }
                };
                _this._onTouchEvent = function (event) {
                    if (!egret3d.inputCollecter.isActiveAndEnabled) {
                        return;
                    }
                    if (!_this._hasTouch) {
                        _this._hasTouch = true;
                        _this._removeMouseEvent(); // TODO 同时支持 mouse 和 touch.
                    }
                    var touch = event.changedTouches[0];
                    if (!touch) {
                        // WX BUG.
                        console.error("WX touch error.", event.type);
                        return;
                    }
                    event.isPrimary = true; // TODO
                    event.pointerId = touch.identifier + 2;
                    event.pressure = touch.force || 0.5; // TODO egret build bug
                    event.tangentialPressure = 0;
                    event.twist = 0;
                    event.width = (touch.radiusX || 0) * 2; // TODO egret build bug
                    event.height = (touch.radiusY || 0) * 2; // TODO egret build bug
                    event.tiltX = 0;
                    event.tiltY = 0;
                    event.pointerType = "touch";
                    event.button = 0;
                    event.buttons = (event.type === "touchstart" || event.type === "touchmove") ? 1 : 0;
                    event.clientX = touch.clientX;
                    event.clientY = touch.clientY;
                    event.pageX = touch.pageX;
                    event.pageY = touch.pageY;
                    event.screenX = touch.screenX;
                    event.screenY = touch.screenY;
                    var rotated = egret3d.stage.rotated;
                    var pointerEvent = event;
                    var canvas = _this._canvas;
                    var downPointers = egret3d.inputCollecter._downPointers;
                    var holdPointers = egret3d.inputCollecter._holdPointers;
                    var pointer = egret3d.inputCollecter.getPointer(pointerEvent.pointerId);
                    var prevEvent = pointer.event;
                    pointer.event = pointerEvent;
                    pointer.position.set(pointerEvent.clientX - (canvas.offsetLeft || 0.0), pointerEvent.clientY - (canvas.offsetTop || 0.0), 0.0);
                    if (rotated) {
                        pointer.position.x += egret3d.stage.screenSize.w;
                    }
                    egret3d.stage.screenToStage(pointer.position, pointer.position);
                    switch (event.type) {
                        case "touchstart":
                            if (downPointers.indexOf(pointer) < 0 && holdPointers.indexOf(pointer) < 0) {
                                pointer.downPosition.copy(pointer.position);
                                downPointers.push(pointer);
                                holdPointers.push(pointer);
                                event.type = "pointerdown";
                                egret3d.inputCollecter.onPointerDown.dispatch(pointer, egret3d.inputCollecter.onPointerDown);
                                event.preventDefault();
                            }
                            break;
                        case "touchmove":
                            if (event.target === canvas || holdPointers.length > 0) {
                                event.type = "pointermove";
                                egret3d.inputCollecter.onPointerMove.dispatch(pointer, egret3d.inputCollecter.onPointerMove);
                                for (var i = 0, l = event.targetTouches.length; i < l; ++i) {
                                    var eachTouch = event.targetTouches[i];
                                    if (eachTouch && eachTouch !== touch) {
                                        var eachPointer = egret3d.inputCollecter.getPointer(eachTouch.identifier + 2);
                                        var eachPointerEvent = eachPointer.event;
                                        if (!eachPointerEvent) {
                                            continue;
                                        }
                                        eachPointerEvent.pressure = eachTouch.force || 0.5; // TODO egret build bug
                                        eachPointerEvent.width = (eachTouch.radiusX || 0) * 2; // TODO egret build bug
                                        eachPointerEvent.height = (eachTouch.radiusY || 0) * 2; // TODO egret build bug
                                        eachPointerEvent.clientX = eachTouch.clientX;
                                        eachPointerEvent.clientY = eachTouch.clientY;
                                        eachPointerEvent.pageX = eachTouch.pageX;
                                        eachPointerEvent.pageY = eachTouch.pageY;
                                        eachPointerEvent.screenX = eachTouch.screenX;
                                        eachPointerEvent.screenY = eachTouch.screenY;
                                        eachPointerEvent.type = "pointermove";
                                        eachPointer.position.set(eachPointerEvent.clientX - (canvas.offsetLeft || 0.0), eachPointerEvent.clientY - (canvas.offsetTop || 0.0), 0.0);
                                        if (rotated) {
                                            eachPointer.position.x += egret3d.stage.screenSize.w;
                                        }
                                        egret3d.stage.screenToStage(eachPointer.position, eachPointer.position);
                                        egret3d.inputCollecter.onPointerMove.dispatch(eachPointer, egret3d.inputCollecter.onPointerMove);
                                    }
                                }
                                event.preventDefault();
                            }
                            else {
                                pointer.event = prevEvent;
                            }
                            break;
                        case "touchend":
                            event.type = "pointerup";
                            if (!_this._pointerUp(pointer, false)) {
                                pointer.event = prevEvent;
                                event.preventDefault();
                            }
                            break;
                        case "touchcancel":
                            event.type = "pointercancel";
                            if (!_this._pointerUp(pointer, true)) {
                                pointer.event = prevEvent;
                                event.preventDefault();
                            }
                            break;
                    }
                };
                _this._onContextMenu = function (event) {
                    if (egret3d.inputCollecter._downPointers.length > 0 ||
                        egret3d.inputCollecter._holdPointers.length > 0 ||
                        egret3d.inputCollecter._upPointers.length > 0) {
                        event.preventDefault();
                    }
                };
                _this._onKeyEvent = function (event) {
                    if (!egret3d.inputCollecter.isActiveAndEnabled) {
                        return;
                    }
                    var downKeys = egret3d.inputCollecter._downKeys;
                    var holdKeys = egret3d.inputCollecter._holdKeys;
                    var upKeys = egret3d.inputCollecter._upKeys;
                    var key = egret3d.inputCollecter.getKey(event.code);
                    key.event = event;
                    switch (event.type) {
                        case "keydown":
                            if (downKeys.indexOf(key) < 0 && holdKeys.indexOf(key) < 0) {
                                downKeys.push(key);
                                holdKeys.push(key);
                                egret3d.inputCollecter.onKeyDown.dispatch(key, egret3d.inputCollecter.onKeyDown);
                            }
                            break;
                        case "keyup": {
                            var isDown = false;
                            var index = downKeys.indexOf(key);
                            if (index >= 0) {
                                isDown = true;
                                downKeys.splice(index, 1);
                            }
                            index = holdKeys.indexOf(key);
                            if (index >= 0) {
                                isDown = true;
                                holdKeys.splice(index, 1);
                            }
                            if (isDown && upKeys.indexOf(key) < 0) {
                                upKeys.push(key);
                                egret3d.inputCollecter.onKeyUp.dispatch(key, egret3d.inputCollecter.onKeyUp);
                            }
                            break;
                        }
                    }
                };
                return _this;
            }
            InputSystem.prototype._pointerUp = function (pointer, isCancel) {
                if (pointer.event.buttons !== 0 /* None */) {
                    return false;
                }
                var isDown = false;
                var downPointers = egret3d.inputCollecter._downPointers;
                var holdPointers = egret3d.inputCollecter._holdPointers;
                var upPointers = egret3d.inputCollecter._upPointers;
                var index = downPointers.indexOf(pointer);
                if (index >= 0) {
                    isDown = true;
                    downPointers.splice(index, 1);
                }
                index = holdPointers.indexOf(pointer);
                if (index >= 0) {
                    isDown = true;
                    holdPointers.splice(index, 1);
                }
                if (isDown && upPointers.indexOf(pointer) < 0) {
                    egret3d.inputCollecter.removePointer(pointer.event.pointerId);
                    upPointers.push(pointer);
                    if (isCancel) {
                        egret3d.inputCollecter.onPointerCancel.dispatch(pointer, egret3d.inputCollecter.onPointerCancel);
                    }
                    else {
                        egret3d.inputCollecter.onPointerUp.dispatch(pointer, egret3d.inputCollecter.onPointerUp);
                    }
                    return true;
                }
                return false;
            };
            InputSystem.prototype._removeMouseEvent = function () {
                var canvas = this._canvas;
                canvas.removeEventListener("mouseover", this._onMouseEvent);
                canvas.removeEventListener("mouseenter", this._onMouseEvent);
                canvas.removeEventListener("mousedown", this._onMouseEvent);
                window.removeEventListener("mousemove", this._onMouseEvent);
                window.removeEventListener("mouseup", this._onMouseEvent);
                canvas.removeEventListener("mouseout", this._onMouseEvent);
                canvas.removeEventListener("mouseleave", this._onMouseEvent);
            };
            InputSystem.prototype.onAwake = function (config) {
                this._canvas = config.canvas;
            };
            InputSystem.prototype.onEnable = function () {
                var canvas = this._canvas;
                // if ((window as any).PointerEvent) { // TODO 会无故触发 pointercancel （PVP 项目）
                //     Pointer events.
                //     canvas.addEventListener("pointerover", this._onPointerEvent);
                //     canvas.addEventListener("pointerenter", this._onPointerEvent);
                //     canvas.addEventListener("pointerdown", this._onPointerEvent);
                //     window.addEventListener("pointermove", this._onPointerEvent);
                //     window.addEventListener("pointerup", this._onPointerEvent);
                //     canvas.addEventListener("pointercancel", this._onPointerEvent);
                //     canvas.addEventListener("pointerout", this._onPointerEvent);
                //     canvas.addEventListener("pointerleave", this._onPointerEvent);
                // }
                // else {
                // Mouse events.
                if (!this._hasTouch) {
                    canvas.addEventListener("mousedown", this._onMouseEvent);
                    canvas.addEventListener("mouseover", this._onMouseEvent);
                    canvas.addEventListener("mouseenter", this._onMouseEvent);
                    window.addEventListener("mousemove", this._onMouseEvent);
                    window.addEventListener("mouseup", this._onMouseEvent);
                    canvas.addEventListener("mouseout", this._onMouseEvent);
                    canvas.addEventListener("mouseleave", this._onMouseEvent);
                }
                // Touch events.
                canvas.addEventListener("touchstart", this._onTouchEvent);
                canvas.addEventListener("touchmove", this._onTouchEvent);
                canvas.addEventListener("touchend", this._onTouchEvent);
                window.addEventListener("touchcancel", this._onTouchEvent);
                // }
                // Context menu event.
                window.addEventListener("contextmenu", this._onContextMenu);
                // Mouse wheel event.
                canvas.addEventListener("mousewheel", this._onMouseWheelEvent);
                // Key events.
                window.addEventListener("keydown", this._onKeyEvent);
                window.addEventListener("keyup", this._onKeyEvent);
            };
            InputSystem.prototype.onDisable = function () {
                var canvas = this._canvas;
                // Pointer events.
                canvas.removeEventListener("pointerover", this._onPointerEvent);
                canvas.removeEventListener("pointerenter", this._onPointerEvent);
                canvas.removeEventListener("pointerdown", this._onPointerEvent);
                window.removeEventListener("pointermove", this._onPointerEvent);
                window.removeEventListener("pointerup", this._onPointerEvent);
                canvas.removeEventListener("pointercancel", this._onPointerEvent);
                canvas.removeEventListener("pointerout", this._onPointerEvent);
                canvas.removeEventListener("pointerleave", this._onPointerEvent);
                // Mouse events.
                this._removeMouseEvent();
                // Touch events.
                canvas.removeEventListener("touchstart", this._onTouchEvent);
                canvas.removeEventListener("touchmove", this._onTouchEvent);
                canvas.removeEventListener("touchend", this._onTouchEvent);
                window.removeEventListener("touchcancel", this._onTouchEvent);
                // Context menu event.
                window.removeEventListener("contextmenu", this._onContextMenu);
                // Mouse wheel event.
                canvas.removeEventListener("mousewheel", this._onMouseWheelEvent);
                // Key events.
                window.removeEventListener("keydown", this._onKeyEvent);
                window.removeEventListener("keyup", this._onKeyEvent);
                egret3d.inputCollecter._clear();
            };
            InputSystem.prototype.onFrame = function (deltaTime) {
                if (egret3d.inputCollecter.isActiveAndEnabled) {
                    egret3d.inputCollecter._update(deltaTime);
                }
            };
            InputSystem.prototype.onFrameCleanup = function () {
                if (egret3d.inputCollecter.isActiveAndEnabled) {
                    egret3d.inputCollecter._clear();
                }
            };
            return InputSystem;
        }(paper.BaseSystem));
        webgl.InputSystem = InputSystem;
        __reflect(InputSystem.prototype, "egret3d.webgl.InputSystem");
    })(webgl = egret3d.webgl || (egret3d.webgl = {}));
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 已丢失或不支持的组件数据备份。
     */
    var MissingComponent = (function (_super) {
        __extends(MissingComponent, _super);
        function MissingComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 已丢失或不支持的组件数据。
             */
            _this.missingObject = null;
            return _this;
        }
        Object.defineProperty(MissingComponent.prototype, "missingClass", {
            /**
             * 丢失的组件类名
             */
            get: function () {
                if (this.missingObject) {
                    return this.missingObject.class;
                }
                return "";
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.editor.property("TEXT" /* TEXT */, { readonly: true })
        ], MissingComponent.prototype, "missingClass", null);
        __decorate([
            paper.serializedField
        ], MissingComponent.prototype, "missingObject", void 0);
        return MissingComponent;
    }(paper.Component));
    paper.MissingComponent = MissingComponent;
    __reflect(MissingComponent.prototype, "paper.MissingComponent");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var _runEditor = false;
    /**
     * 引擎启动入口。
     * @param options
     */
    function runEgret(options) {
        return __awaiter(this, void 0, void 0, function () {
            var isWeb, urlSearchParams, playerDiv, canvas, param, param, param, _a, systemManager, gameObjectContext;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!options) {
                            options = {};
                        }
                        {
                            // TODO
                            egret.Sound = egret.web ? egret.web.HtmlSound : egret['wxgame']['HtmlSound']; //TODO:Sound
                            egret.Capabilities["renderMode" + ""] = "webgl";
                            isWeb = !window.canvas;
                            urlSearchParams = isWeb ? new URLSearchParams(location.search) : null;
                            playerDiv = isWeb ? document.getElementsByClassName("egret-player")[0] : null;
                            canvas = _getMainCanvas(options, playerDiv);
                            if (options.playerMode === undefined) {
                                param = urlSearchParams !== null ? urlSearchParams.get("player-mode") : "";
                                if (param) {
                                    options.playerMode = parseInt(param);
                                }
                                else {
                                    options.playerMode = _parseInt(playerDiv, "data-player-mode", 1 /* Player */);
                                }
                            }
                            if (options.entry === undefined) {
                                param = urlSearchParams !== null ? urlSearchParams.get("entry") : "";
                                if (param) {
                                    options.entry = param;
                                }
                                else {
                                    options.entry = _parseString(playerDiv, "data-entry", "");
                                }
                            }
                            if (options.scene === undefined) {
                                param = urlSearchParams !== null ? urlSearchParams.get("scene") : "";
                                if (param) {
                                    options.scene = param.split("\\").join('/');
                                }
                                else {
                                    options.scene = _parseString(playerDiv, "data-scene", "");
                                }
                            }
                            if (options.tickRate === undefined) {
                                options.tickRate = _parseInt(playerDiv, "data-tick-rate", 0);
                            }
                            if (options.frameRate === undefined) {
                                options.frameRate = _parseInt(playerDiv, "data-frame-rate", 0);
                            }
                            if (options.contentWidth === undefined) {
                                options.contentWidth = _parseInt(playerDiv, "data-content-width", 1136);
                            }
                            if (options.contentHeight === undefined) {
                                options.contentHeight = _parseInt(playerDiv, "data-content-height", 640);
                            }
                            if (options.alpha === undefined) {
                                options.alpha = _parseBoolean(playerDiv, "data-alpha", false);
                            }
                            if (options.antialias === undefined) {
                                options.alpha = _parseBoolean(playerDiv, "data-antialias", true);
                            }
                            if (options.antialiasSamples === undefined) {
                                options.antialiasSamples = 4;
                            }
                            if (options.showStats === undefined) {
                                options.showStats = _parseBoolean(playerDiv, "data-show-stats", !paper.Application.isMobile);
                            }
                            if (options.showInspector === undefined) {
                                options.showInspector = _parseBoolean(playerDiv, "data-show-inspector", !paper.Application.isMobile);
                            }
                            options.canvas = canvas;
                            options.webgl =
                                canvas.getContext("webgl", options) ||
                                    canvas.getContext("experimental-webgl", options);
                        }
                        if (!(options.playerMode === 4 /* Editor */)) return [3 /*break*/, 2];
                        if (!!_runEditor) return [3 /*break*/, 2];
                        _runEditor = true;
                        return [4 /*yield*/, _entity(options)];
                    case 1:
                        _b.sent();
                        return [2 /*return*/];
                    case 2:
                        _a = paper.Application, systemManager = _a.systemManager, gameObjectContext = _a.gameObjectContext;
                        paper.Application.initialize(options);
                        systemManager
                            .preRegister(egret3d.webgl.BeginSystem, gameObjectContext, 0 /* Begin */, options)
                            .preRegister(egret3d.webgl.WebGLRenderSystem, gameObjectContext, 8000 /* Renderer */, options)
                            .preRegister(egret3d.webgl.InputSystem, gameObjectContext, 10000 /* End */, options)
                            .preRegister(egret3d.CollisionSystem, gameObjectContext, 3000 /* FixedUpdate */)
                            .preRegister(egret3d.AnimationSystem, gameObjectContext, 5000 /* Animation */)
                            .preRegister(egret3d.MeshRendererSystem, gameObjectContext, 7000 /* BeforeRenderer */)
                            .preRegister(egret3d.SkinnedMeshRendererSystem, gameObjectContext, 7000 /* BeforeRenderer */)
                            .preRegister(egret3d.particle.ParticleSystem, gameObjectContext, 7000 /* BeforeRenderer */)
                            .preRegister(egret3d.Egret2DRendererSystem, gameObjectContext, 7000 /* BeforeRenderer */, options)
                            .preRegister(egret3d.CameraAndLightSystem, gameObjectContext, 7000 /* BeforeRenderer */);
                        paper.Application.registerSystems();
                        paper.Application.start();
                        if (!!_runEditor) return [3 /*break*/, 4];
                        return [4 /*yield*/, _entity(options)];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4: return [4 /*yield*/, _scene(options)];
                    case 5:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    }
    egret3d.runEgret = runEgret;
    function _parseBoolean(playerDiv, attributeName, defaultValue) {
        if (playerDiv !== null) {
            var attribute = playerDiv.getAttribute(attributeName);
            if (attribute !== null && attribute !== "auto") {
                return attribute === "true";
            }
        }
        return defaultValue;
    }
    function _parseInt(playerDiv, attributeName, defaultValue) {
        if (playerDiv !== null) {
            var attribute = playerDiv.getAttribute(attributeName);
            if (attribute !== null && attribute !== "auto") {
                return parseInt(attribute);
            }
        }
        return defaultValue;
    }
    function _parseString(playerDiv, attributeName, defaultValue) {
        if (playerDiv !== null) {
            var attribute = playerDiv.getAttribute(attributeName);
            if (attribute !== null && attribute !== "auto") {
                return attribute;
            }
        }
        return defaultValue;
    }
    function _getMainCanvas(options, playerDiv) {
        if (window.canvas) {
            return window.canvas;
        }
        if (options.canvas) {
            return options.canvas;
        }
        var canvas = document.createElement("canvas");
        playerDiv.appendChild(canvas);
        return canvas;
    }
    function _entity(options) {
        return __awaiter(this, void 0, void 0, function () {
            var entity;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!options.entry) return [3 /*break*/, 2];
                        entity = global[options.entry] || window[options.entry] || null;
                        if (!(entity !== null)) return [3 /*break*/, 2];
                        return [4 /*yield*/, entity()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    }
    function _scene(options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!options.scene) return [3 /*break*/, 3];
                        return [4 /*yield*/, RES.loadConfig("resource/default.res.json", "resource/")];
                    case 1:
                        _a.sent(); // TODO
                        return [4 /*yield*/, RES.getResAsync(options.scene)];
                    case 2:
                        _a.sent();
                        paper.Application.sceneManager.createScene(options.scene);
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    }
})(egret3d || (egret3d = {}));
window.gltf = gltf;
window.paper = paper;
window.egret3d = egret3d;
var egret3d;
(function (egret3d) {
    /**
     * 胶囊体碰撞组件。
     * - 与 Y 轴对齐。
     */
    var CapsuleCollider = (function (_super) {
        __extends(CapsuleCollider, _super);
        function CapsuleCollider() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.colliderType = egret3d.ColliderType.Capsule;
            _this.capsule = egret3d.Capsule.create(egret3d.Vector3.ZERO, 0.25, 0.5);
            return _this;
        }
        CapsuleCollider.prototype.raycast = function (ray, raycastInfo) {
            if (raycastInfo === void 0) { raycastInfo = null; }
            return egret3d._colliderRaycast(this, this.capsule, null, ray, raycastInfo, true);
        };
        __decorate([
            paper.editor.property("NESTED" /* NESTED */),
            paper.serializedField
        ], CapsuleCollider.prototype, "capsule", void 0);
        CapsuleCollider = __decorate([
            paper.allowMultiple
        ], CapsuleCollider);
        return CapsuleCollider;
    }(paper.BaseComponent));
    egret3d.CapsuleCollider = CapsuleCollider;
    __reflect(CapsuleCollider.prototype, "egret3d.CapsuleCollider", ["egret3d.ICapsuleCollider", "egret3d.ICollider", "egret3d.IRaycast"]);
})(egret3d || (egret3d = {}));
